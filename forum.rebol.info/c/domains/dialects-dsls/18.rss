<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Dialects/DSLs - AltRebol</title>
    <link>https://forum.rebol.info/c/domains/dialects-dsls/18</link>
    <description>Topics in the &#39;Dialects/DSLs&#39; category Discussion focused on the creation of dialects and DSLs using Rebol. Rebmu talk is appropriate here.</description>
    
      <lastBuildDate>Mon, 29 Nov 2021 15:36:40 +0000</lastBuildDate>
      <atom:link href="https://forum.rebol.info/c/domains/dialects-dsls/18.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>Dialecting URL!s...Should They Ever Be Strings?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>So I just tried to use a URL! in PARSE and found it was an error.  It's an error in R3-Alpha, too:</p>
<pre><code>r3-alpha&gt;&gt; parse http://example.com/foo [http://example.com "/foo"]
** Script error: PARSE - invalid rule or usage of rule: http://example.com
</code></pre>
<p>Red treats it as a string:</p>
<pre><code>red&gt;&gt; parse http://example.com/foo [http://example.com "/foo"]
== true
</code></pre>
<p><strong>But if you think about it, this is a pretty limited application of the datatype.</strong></p>
<ul>
<li>
<p>If your input is a string, you're saving two characters over putting it in braces or quotes, like <strong><code>["http://example.com" "/foo"]</code></strong></p>
<ul>
<li>Ren-C has generic quoting, so there's quoted URL!s with a single character as another option... <strong><code>['http://example.com "/foo"]</code></strong>
</li>
</ul>
</li>
<li>
<p>If what you're matching against is a URL it's only going to match the very beginning part.</p>
</li>
</ul>
<h2>Could It Fetch Rules From A Network?</h2>
<p>In some cases--like the COMPILE dialect--you can build a list of code and libraries to put together, along with user natives.  It's neat there to have URLs be interpreted as fetching from the network.</p>
<p>But that seems a bit strange for UPARSE.  You'd depend on caching <em>(you wouldn't want to do a network fetch each time you hit the URL! in the rule...?)</em>  In Ren-C you can kind of do this minus the caching, e.g.</p>
<pre><code>uparse data [... :(load http://example.com/rules/) ...]
</code></pre>
<h2>Could It Be Commentary?</h2>
<p>In the test dialect, I thought it might be nice to just be able to drop URLs in the middle of things without having to make them comments.  It doesn't save that much, but can look more clean:</p>
<pre><code>[
    #386
    http://en.wikipedia.org/wiki/Some_Related_Topic
    (1 + 1 = 2)
]
</code></pre>
<p>I've also sometimes wondered about this for function specifications.</p>
<pre><code>foo: func [
    http://example.com/this-explains-this-function
    return: [integer!]
    arg [integer!]
][
    ...
]
</code></pre>
<p>This doesn't seem a good fit for PARSE behavior, but I kind of want to mention the idea of different ways that URL! might be used.</p>
<h2>In UPARSE It's Customizable...Leave it Open?</h2>
<p>One possibility would be to say that URL! doesn't do anything by default, and you can make a URL! combinator that decides what it does do.</p>
<p>How useful would it be?  I don't know.</p>
<p><strong>I'm just questioning whether the knee-jerk response of treating URL! as a string (or matching a URL! value if block parsing) is obviously the way to go.</strong></p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/dialecting-url-s-should-they-ever-be-strings/1763">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/dialecting-url-s-should-they-ever-be-strings/1763</link>
          <pubDate>Mon, 29 Nov 2021 15:36:40 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1763</guid>
          <source url="https://forum.rebol.info/t/dialecting-url-s-should-they-ever-be-strings/1763.rss">Dialecting URL!s...Should They Ever Be Strings?</source>
        </item>
        <item>
          <title>USCII Seen With New Eyes</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>In 2008 I used R3-Alpha to make some 5x7 bitmaps out of a stock font I found, plus some data to make symbols for the missing control characters.  The way I defined the missing characters was with blocks of data, like:</p>
<pre><code>[
    code: 10
    name: "Line Feed"
    abbr: "LF"
    description: {
        On typewriters, printers, and some terminal emulators, moves the
        cursor down one row without affecting its column position. On Unix,
        used to mark end-of-line.
    }
    image: [
        "XXX  "
        "  X  "
        "  X  "
        "  X  "
        "XXXXX"
        " XXX "
        "  X  "
    ]
    notes: {
        A spin on the carraige return which emphasizes the "downness" of
        a feed, but also with a horizontal suggestion of the current line
    }
    rating: 'good
] 
</code></pre>
<p>Besides not needing commas on the strings, this doesn't really buy a whole lot over JSON.  The script had a couple of talking points--that PNG encoding and IMAGE! was built in, and that you could put BINARY! data directly in your script as hex.  But largely unremarkable.</p>
<p>Not that the point was to demo "great Rebol practices", really.  I was just using it as a tool.  <em>(And it was 2008, so I had just found the language...one shouldn't expect much regardless.)</em></p>
<p><strong>I've gotten it working under Redbol emulation--which is kind of a cool trick in and of itself.</strong>  This involved patching up the bad IMAGE! code well enough to work with the script, but it felt worth it to run the rest of it.</p>
<p><strong>But the real fun begins moving to modern ideas.</strong>  So I put aside a copy as a historical version to keep as a Redbol test, but then started updating it to the new world...</p>
<h2>Rethought With UTF-8 and a Dialect</h2>
<p>When you take away the BLOCK! and start using the parts in the box, what you get is a lot more remarkable.</p>
<pre><code>=== LF: Line Feed (10) ===

◼◼◼▢▢
▢▢◼▢▢
▢▢◼▢▢
▢▢◼▢▢
◼◼◼◼◼
▢◼◼◼▢
▢▢◼▢▢

description: {
    On typewriters, printers, and some terminal emulators, moves the
    cursor down one row without affecting its column position. On Unix,
    used to mark end-of-line.
}
notes: {
    A spin on the carraige return which emphasizes the "downness" of
    a feed, but also with a horizontal suggestion of the current line
}
rating: good
</code></pre>
<p>It's much more interesting:</p>
<ul>
<li>
<p>UTF-8 means that we can use solid and hollow boxes to represent the bitmap.  They're legal characters in WORD!s, so instead of 7 TEXT!s the bitmap can be represented as 7 WORD!s and still be LOAD-able.</p>
</li>
<li>
<p>A section-divider can do double duty for the attributes.  A SET-WORD! becomes the shorthand, the name can be turned into regular WORD!s spanning up to a GROUP! that contains the codepoint.</p>
</li>
<li>
<p>There were multiple shorthands in some cases (e.g. 17, Device Control 1, can be known as DC1 or XON).  instead of a SET-WORD! like <strong>LF:</strong> that can be a SET-PATH!, like <strong>DC1/XON:</strong>.</p>
</li>
<li>
<p>Since it's a dialect, there's no need to put a tick mark on the rating of "good/fair/poor".</p>
</li>
</ul>
<h2>A Fluid Format that You Transform With UPARSE</h2>
<p>The first thing I did was to transform the new representation back to the old representation with UPARSE.  <a href="https://forum.rebol.info/t/collect-of-set-word-text-uparse-reduce/1712">I wrote about how it could be better if UPARSE had REDUCE</a>...</p>
<p>So it's not optimal, and we wouldn't need such a transformation step anyway if processing directly.  You'd use GATHER/EMIT.</p>
<p>But I'm pasting it here just to make the point that in just a couple of minutes I was able to have the old code up and running on the new format:</p>
<pre><code>override-data: uparse load %uscii-5x7-english-c0.reb [
    collect [while keep ^ collect [
        '===
        [
            abbr: set-word! (abbr: as text! abbr)
            | abbr: set-path! (abbr: as block! abbr)
        ]
        name: between &lt;here&gt; [code: into group! integer!]
        '===

        keep (compose [
            code: (code)
            name: (spaced inert name)
            abbr: (abbr)
            image:  ; coming up...
        ])

        keep ^ collect 7 [w: word!, keep (as text! w)]

        opt [keep ^ 'description:, keep text!]
        opt [keep ^ 'notes:, keep text!]
        opt [keep ^ 'rating:, keep ^ ^ word!]
    ]]
]
</code></pre>
<h2>IMO, This is Rebol's "Deep Lake"</h2>
<p>Breaking free of the JSON mindset and using the parts really makes this work:</p>
<p><a href="https://github.com/hostilefork/uscii/blob/master/uscii-5x7-english-c0.reb">https://github.com/hostilefork/uscii/blob/master/uscii-5x7-english-c0.reb</a></p>
<p>Revisiting this and the Whitespace interpreter are just really good examples of the form.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/uscii-seen-with-new-eyes/1713">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/uscii-seen-with-new-eyes/1713</link>
          <pubDate>Sun, 12 Sep 2021 13:15:30 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1713</guid>
          <source url="https://forum.rebol.info/t/uscii-seen-with-new-eyes/1713.rss">USCII Seen With New Eyes</source>
        </item>
        <item>
          <title>Boris&#39;s &quot;NEW-EACH&quot; Loop Dialecting Proposals</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>Here are some ideas for what kinds of things you might put in a FOR-EACH variable block besides just words, and some other ideas:</p>
<p><a href="https://gitlab.com/hiiamboris/red-mezz-warehouse/-/blob/master/foreach-design.md" class="inline-onebox">foreach-design.md · master · hi i am boris / Red mezz warehouse · GitLab</a></p>
<p>It's definitely worth thinking about how to ask for the iteration counter automatically while iterating.  Or getting the position <em>and</em> the value somehow at once, instead of being forced to iterate by position and remember to say <code>pos.1</code> to get the value.  We've had some hare-brained schemes for that come down the pipe.</p>
<p>The simple idea of just asking for it in the vars spec feels pretty solid.  I'm not thrilled about the <strong>/var</strong> notation, but it's a desirable feature and certainly in reach:</p>
<pre><code>&gt;&gt; for-each [/i x y] [#a &lt;b&gt; #c &lt;d&gt; #e] [
       print [i x y]
   ]
1 #a &lt;b&gt;
2 #c &lt;d&gt;
3 #e
</code></pre>
<p>But some of the other proposals are a bit heavy, like a type constraint and then skipping out of iterations where the type doesn't match:</p>
<pre><code>&gt;&gt; for-each [/i x [text! group!] y] ["a" &lt;b&gt; #c &lt;d&gt; (e)] [
       print [i x y]
   ]
1 "a" &lt;b&gt;
3 (e)
</code></pre>
<p>The semantic combinatorics start to add up.  He says that the index keeps counting regardless of whether the iteration was skipped or not... but, is that obvious?</p>
<p>And isn't the following kind of clearer:</p>
<pre><code>&gt;&gt; for-each [/i x y] ["a" &lt;b&gt; #c &lt;d&gt; "e"] [
       match [text! group!] x else [continue]   
       print [index x y]
   ]
1 "a" &lt;b&gt;
3 (e)
</code></pre>
<h2>Things to Avoid: Overdesign, "Parts of Speech" Abuse</h2>
<p>I think we should be cautious about overdesigning such  core constructs.  (But certainly these things--whether you think they are monstrosities or not--are exactly the kind of thing that people are supposed to be empowered to make if it pleases them.  It's supposed to be a <em>personal</em> language, and you personalize it to the extent of your tastes.)</p>
<p>As we want to know the loop iteration you're on, maybe the better angle isn't to be abusing word decorations in such weird ways...but to use refinements as labels and then name the variable after it.  I wouldn't call the loop counter the "index" because the index is in the series position... so, /COUNTER or   /COUNT maybe?</p>
<pre><code>&gt;&gt; for-each [/count i x y] [#a &lt;b&gt; #c &lt;d&gt; #e] [
       print [i x y]
   ]
</code></pre>
<p>Commas would probably make it clearer, so good we have them:</p>
<pre><code>&gt;&gt; for-each [/count i, x y] [#a &lt;b&gt; #c &lt;d&gt; #e] [
       print [i x y]
   ]
</code></pre>
<p>You could get the series position with <strong>/here</strong>.  And <a class="mention" href="/u/blackattr">@BlackATTR</a> and <a class="mention" href="/u/gchiu">@gchiu</a> and I have talked about things like wanting to know if you were on the first or last iteration.  Well, why not <strong>/first?</strong> and <strong>/last?</strong></p>
<pre><code>&gt;&gt; for-each [/first? f, /last? l, x y] [#a &lt;b&gt; #c &lt;d&gt; #e] [
       print [f l x y]
   ]
true false #a &lt;b&gt;
false false #c &lt;d&gt;
false true #e
</code></pre>
<p>Some of these could apply to other loop forms like COUNT-UP I guess...</p>
<pre><code>&gt;&gt; count-up [/first? f, /last? l, x] 3 [print [f l x]]
true false 1
false false 2
false true 3
</code></pre>
<p>People who really want shorthands to say that "just a refinement means /count" could put a little preprocessor adapting the spec to the more verbose form.  But I'd rather use the verbose version.</p>
<h2>Generalized Generators Throw A Thorn in This</h2>
<p>In moving to a generalized FOR that runs over a generator, the values are being provided by something that gets called N times and returns answers.  The underlying pattern can be shown by the rewrite:</p>
<pre><code>&gt;&gt; for [/first? f, /last? l, x y] (each [#a &lt;b&gt; #c &lt;d&gt; #e]) [
       print [f l x y]
   ]
</code></pre>
<p>EACH is a generator.  And FOR is something that calls that generator N times.</p>
<p>But not all generators operate on series, some fabricate data out of thin air.  So they'd have no series position to answer /HERE with.  And while we can universally answer the "is this the first iteration" in the iteration construct itself, not all generators know if they're on the last time you're calling them...they provide data for each call until they return NULL.</p>
<p>So I guess the mechanics would have to be to try and request these as output parameters from the generator, and it either has them or it doesn't.  Yay for multi-returns, amiright?  <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
<p>But since the answers are coming from the generator you'd probably have to put your questions for it in front of the variable for the iteration # you are asking:</p>
<pre><code>&gt;&gt; for [/first? f, x, /last? l, y] (each [#a &lt;b&gt; #c &lt;d&gt; #e]) [
       print [f l x y]
   ]
</code></pre>
<p>This moves the LAST? question so it would ostensibly be grouped with the request for Y.</p>
<h2>Weird Thought... "FOR specs", like "FUNC specs"?</h2>
<p>It occurred to me like we might actually want to think about documenting these like specs.</p>
<pre><code>&gt;&gt; data: [#a &lt;b&gt; #c &lt;d&gt; #e]

&gt;&gt; for-each [
       /first? f [logic!]
       x [tag!] "Maybe document what this is for with a TEXT!?"
       /last? l [logic!]
       y [issue!] "Same here..."
   ] data [
       print [f l x y]
   ]
</code></pre>
<p>It could introduce concepts like <code>&lt;skip&gt;</code> able parameters.</p>
<p>Of course you wouldn't have to use such wacky things if you didn't want to, I'm just saying you could.  <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/boriss-new-each-loop-dialecting-proposals/1682">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/boriss-new-each-loop-dialecting-proposals/1682</link>
          <pubDate>Tue, 24 Aug 2021 04:53:47 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1682</guid>
          <source url="https://forum.rebol.info/t/boriss-new-each-loop-dialecting-proposals/1682.rss">Boris&#39;s &quot;NEW-EACH&quot; Loop Dialecting Proposals</source>
        </item>
        <item>
          <title>Isotopes and Divergence in Function Spec Dialect</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>Right now we have a couple of dark alleys in the function spec dialect.</p>
<h2>"Divergence" (always throws, fails, etc....never returns)</h2>
<p>Today's vocabulary word is <a href="https://en.wikipedia.org/wiki/Divergence_(computer_science)">divergent functions</a>...when a function never returns a result in a "normal" way.</p>
<p>All functions that can FAIL or be THROWN or RETURN'd across have divergence as an <em>option</em> (which is, right now, all functions).  But it becomes an issue of what to say when there really is no type a function <em>ever</em> returns...what do you put in the spec?</p>
<p>Lately I've been using just <strong><code>[return: []]</code></strong>.  That might look perfect...by saying there's no types you can return, then any return would generate an error.</p>
<p>But Ren-C is complicated... you've got things like invisible functions, as well as BAD-WORD! isotopes.  And NULL which is a bit of a pickle too--<strong><a href="https://forum.rebol.info/t/revisiting-opt-in-the-func-spec-dialect/1658">I've written about revisiting <code>&lt;opt&gt;</code> in its own post.</a></strong></p>
<h2>What About Isotopes?</h2>
<p>If you say your function returns <strong>[bad-word!]</strong>, that doesn't cover isotope forms.</p>
<p>Right now, there's no type checking on isotopes.  Any function can return any isotope right now--they're outside of type checking.</p>
<p>We could narrow it down to just certain isotopes by putting them in the spec as BAD-WORD!s, like <strong>[integer! ~none~]</strong>...though there's no place to store a list of such isotopes at present :-/</p>
<p>Returning <strong>[ any-value!]</strong> is already pretty wordy.  Having to say <strong>[  any-value!]</strong> is a hassle.  The reasoning I had for letting any function return any isotope was that they're close enough to being errors anyway to a caller...so erroring in the type checking didn't serve that much of a point, for the wordiness.</p>
<h2>What About Invisibility?</h2>
<p>You can't say plain RETURN these days with no argument unless your function has <strong><code>&lt;invisible&gt;</code></strong> in the return spec (or if it has <strong><code>return: &lt;none&gt;</code></strong> which just ignores whatever you return anyway and gives back NONE).  That's another weird notational tic.</p>
<p>I just wanted to mention these issues.  No great answers right now, so we've just got the mediocre answers.  It's working, so...not the biggest priority.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/isotopes-and-divergence-in-function-spec-dialect/1667">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/isotopes-and-divergence-in-function-spec-dialect/1667</link>
          <pubDate>Mon, 16 Aug 2021 02:35:53 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1667</guid>
          <source url="https://forum.rebol.info/t/isotopes-and-divergence-in-function-spec-dialect/1667.rss">Isotopes and Divergence in Function Spec Dialect</source>
        </item>
        <item>
          <title>CLI Dialect</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>A long time ago, earl and I discussed the concept of making it so that a script's header would use something like the function spec dialect to define the command line arguments for a script.  So if you declared a refinement like <strong>/foo [integer!]</strong> that would be translated into something appropriate for your platform, like an argument to your script taken as <strong>--foo=3</strong> on Linux or <strong>/foo 3</strong> on Windows.  Or whatever.</p>
<p>Regular args would be required arguments, you'd get automatic help from the string descriptions in the spec, etc.</p>
<p>Red's Boris has done nearly exactly this...but he isn't putting a spec into the script header.  He has you make a function and then pass that function to a CLI dialect processor:</p>
<p><a href="https://gitlab.com/hiiamboris/red-cli/" class="inline-onebox">hi i am boris / CLI dialect for Red · GitLab</a></p>
<p>I do still like the aesthetics of putting it in the script header; it feels like a good place.  Though that would bake it in somewhat more...and introduces the question of what scope the arguments are in.  Would you have to say <strong>system.processed-args.foo</strong>, or would it be a globally scoped <strong>foo</strong> to the whole script?</p>
<p>And he mentions a good point of making this something you can apply to any function:</p>
<blockquote>
<p><em>"You can turn any Red function into a command line utility with one or two words. Suppose you have a <code>grep</code> function that is to be used from Red. Prefix it with <code>process-into</code>, add <code>print</code> for the output, compile it, and you have a <code>grep</code> utility!"</em></p>
</blockquote>
<p>That is worth thinking about.  You can say <strong>--do "..."</strong> on the command line to run arbitrary code, but what if you could specify a script name and say <strong>--function "func-name"</strong>, and have that function suddenly get its arguments from the command line?</p>
<p>If that sounds dumb compared to <strong>--do "func-name/refine arg1 arg2"</strong> just consider that sometimes you do want to integrate with the shell, and getting arguments spliced via the shell into such a --do string can be a mess.  It also can't be aliased into a single shell command.</p>
<p>Anyway, their experience with this is worth looking at, as it's something I've wanted for a while.  Whether there's a way of offering this in a script's header or not, I think I'm sold on the "you should be able to do it to any function if you want" angle.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/cli-dialect/1651">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/cli-dialect/1651</link>
          <pubDate>Sat, 07 Aug 2021 15:21:23 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1651</guid>
          <source url="https://forum.rebol.info/t/cli-dialect/1651.rss">CLI Dialect</source>
        </item>
        <item>
          <title>Idea: QUOTED! Data Means FOR =&gt; FOR-EACH</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>So I had another flash-o-inspiration.</p>
<pre><code>for x [1 thru 3] [
   print [x]
]
</code></pre>
<p>Gives you:</p>
<pre><code>1
2
3
</code></pre>
<p>But...</p>
<pre><code>for x @[1 thru 3] [
   print [x]
]
</code></pre>
<p>Leads to the second parameter to FOR being <strong>'[1 thru 3]</strong>  And that would give you:</p>
<pre><code>1
thru
3
</code></pre>
<p>And if you don't like how that looks, you could also use:</p>
<pre><code>for x each [1 thru 3] [
   print [x]
]

1
thru
3
</code></pre>
<p>In that case, EACH is making a generator function, so the second argument to FOR is an ACTION! that produces values until it produces a NULL which causes it to stop the FOR.</p>
<p>So I think that resolves that the base level of FOR and MAP is a dialect for generating values.  Anyone have ideas for this dialect and how it works besides me?  :-/  <sub>No, don't worry about it, I'll solve it.</sub></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/idea-quoted-data-means-for-for-each/1601">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/idea-quoted-data-means-for-for-each/1601</link>
          <pubDate>Wed, 12 May 2021 08:24:16 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1601</guid>
          <source url="https://forum.rebol.info/t/idea-quoted-data-means-for-for-each/1601.rss">Idea: QUOTED! Data Means FOR =&gt; FOR-EACH</source>
        </item>
        <item>
          <title>Revisiting The ZIP Dialect</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>Vincent Ecuyer's <a href="http://www.rebol.org/view-script.r?script=rebzip.r">ZIP Dialect</a> is an example of tool in a domain that pretty much everyone knows and uses: zipping and unzipping files.</p>
<p>I'd thought its source code might be a good place to study the power of BINARY! parsing...until I realized how lacking binary parsing actually was in practice.  With UPARSE, I hope to attack those problems.  If so, then ZIP may yet become a showcase of how something like the zip file specification can become easily absorbed as usermode code.</p>
<p><strong>But another opportunity may come from making the ZIP dialect a tool people would actually want to use for its powers.</strong></p>
<p>It's already a little bit dialected.  When you pass it a block, you don't just specify filenames.  You can also give it literal blobs of BINARY! data, or URL!s to fetch.  This means you don't have to do calls to <code>curl</code> to get a temporary file, rename that file, and then pass the filename to a zip tool... the tool itself has smarts.</p>
<p>Here's what the options were in the original script:</p>
<pre><code>you can zip a single file:
    zip %new-zip.zip %my-file

a block of files:
    zip %new-zip.zip [%file-1.txt %file-2.exe]

a block of data (binary!/string!) and files:
    zip %new-zip.zip [%my-file "my data"]

a entire directory:
    zip/deep %new-zip.zip %my-directory/

from an url:
    zip %new-zip.zip ftp://192.168.1.10/my-file.txt

any combination of these:
    zip/deep %new-zip.zip  [
        %readme.txt "An example" 
        ftp://192.168.1.10/my-file.txt
        %my-directory
     ]
</code></pre>
<p>When you think of this being used alongside my demo of <a href="https://forum.rebol.info/t/using-ren-c-as-the-shell-in-github-actions/1547">steps in GitHub Actions</a> we could pack it up.  Here's a sketch of what that might look like:</p>
<pre><code> - uses: hostilefork/zip-github-action@v1
   output: new-zip.zip
   deep: true
   run: |
       %readme.txt "An example" 
       ftp://192.168.1.10/my-file.txt
       %my-directory
</code></pre>
<p>The ideal would be that there be a very easy way to make such a packaging for any given ACTION!.  You want to be able to get the non-dialect arguments and refinements split out from the body (the way the output filename and /DEEP is split out here).</p>
<h2>This Seems Like A Good Example to Try And Hone</h2>
<p>It doesn't really get any simpler than this.  So why don't we ask:</p>
<p><strong>Can we make the ZIP dialect something so compelling that anyone who wanted to make a ZIP file on GitHub Actions would be a fool not to use it, if it had a zero-effort usage pattern like the above?</strong></p>
<p>The dialect could take advantage of new parts in the box.  e.g. SET-BLOCK! if you want to use a different filename than what something has already:</p>
<pre><code>; Make a file in the zip called bar.txt, with contents of foo.txt
zip %output.zip [[%bar.txt]: %foo.txt]

; Make a file in the zip called foo.txt, with contents of foo.txt
zip %output.zip [%foo.txt]
</code></pre>
<p>Talking to <a class="mention" href="/u/blackattr">@BlackATTR</a> about it, I wondered if it's the kind of dialect where plain WORD!, PATH!, and TUPLE! should be interpreted as filenames, just to reduce the level of noise.  So <strong>readme.txt</strong> would be a legal alternative to <strong>%readme.txt</strong> and you would use GROUP!s to run code.  This introduces a lot of questions, <a href="https://forum.rebol.info/t/form-of-group-s-get-word-s/1543">but I've brought up the question elsewhere, e.g. with FORM</a>.</p>
<p>Playing along better with bash would be nice.  Maybe allow <strong>$ (some bash expression)</strong>?  I've got a post about a SHELL dialect I've been thinking about.</p>
<p>Anyway, if we can't do this, we probably can't do anything more complicated.  So it's time to start putting our code where our mouth is and seeing if this can actually make something anyone wanted to use.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/revisiting-the-zip-dialect/1548">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/revisiting-the-zip-dialect/1548</link>
          <pubDate>Wed, 10 Mar 2021 00:55:17 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1548</guid>
          <source url="https://forum.rebol.info/t/revisiting-the-zip-dialect/1548.rss">Revisiting The ZIP Dialect</source>
        </item>
        <item>
          <title>FORM of GROUP!s, GET-WORD!s...</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>Trying to write shell code in Rebol, you notice that bash has a pretty strong advantage of putting together fragments of text with environment variables.</p>
<p>I think we'd have a leg up if there were a behavior in something that didn't reduce strings--like FORM--if it would make an exception for GROUP!s.</p>
<p>Historically you get something pretty useless:</p>
<pre><code>rebol2&gt;&gt; form [--sysroot (first [/foo /bar])]
== "--sysroot first /foo /bar"

red&gt;&gt; form [--sysroot (first [/foo /bar])]
 == "--sysroot first /foo /bar"
</code></pre>
<p>I don't see that helping a whole lot.  Evaluating the group would make more sense.</p>
<pre><code>&gt;&gt; form [--sysroot (first [/foo /bar])]
== "--sysroot /foo"
</code></pre>
<p>As an aside, I've always thought FORM is a weird name for this.  Maybe it needs a better name.</p>
<p>But whatever it is, I think we need something like it for putting together bash-like "sentences", without having to use so many quotes...because every character adds up:</p>
<pre><code>&gt;&gt; spaced [{--sysroot} (first ["/foo" "/bar"])]
== "--sysroot /foo"
</code></pre>
<p>I'll point out that having greater flexibility on what is a legal PATH!, permitting <strong>foo/bar/</strong> and <strong>/foo/</strong> etc. really is already helping a lot for common cases of writing shell-like scripts.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/form-of-group-s-get-word-s/1543">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/form-of-group-s-get-word-s/1543</link>
          <pubDate>Sun, 07 Mar 2021 03:50:08 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1543</guid>
          <source url="https://forum.rebol.info/t/form-of-group-s-get-word-s/1543.rss">FORM of GROUP!s, GET-WORD!s...</source>
        </item>
        <item>
          <title>Dissecting the ASSERT Dialect</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>Another dialect to talk about while discussing the question of <a href="https://forum.rebol.info/t/pivotal-design-question-is-evaluator-state-just-a-block/1496">whether the evaluator can accrue state across evaluation steps</a> is ASSERT.</p>
<p>The idea of ASSERT is to let you put one expression after the other, and have it tested for "truthiness".</p>
<p><strong>ASSERT needs to do stepwise evaluation, test the result, and ideally report the expression that failed.</strong></p>
<h2>Historical Brittleness</h2>
<p>Since assert accepts multiple expressions, clipping it in the error makes sense so that you only see the expression that failed.</p>
<pre><code>&gt;&gt; assert [1 = 1 2 = 3 4 = 4]
** Script error: assertion failed for: [2 = 3]
</code></pre>
<p>So it has to copy the expression out to put in the error.  But for some reason, it only copies an arbitrary three items from the expression:</p>
<pre><code>r3-alpha&gt;&gt; assert [empty? first first [[[a]]]]  
** Script error: assertion failed for: [empty? first first]
</code></pre>
<p>This raises a number of questions about error reporting...as to whether this kind of copying makes sense in the first place, or if there should be some common services to help be more informative when providing the "near" information...to implicate the start of an expression instead of the end.</p>
<p>But as it's referring to the block, what if the block is modified?</p>
<pre><code>r3-alpha&gt;&gt; block: [not empty? clear block]

r3-alpha&gt;&gt; assert block
** Script error: assertion failed for: []
</code></pre>
<p>This is something Ren-C helps with, by locking the array during evaluation:</p>
<pre><code>ren-c &gt;&gt; block: [not empty? clear block]
== [not empty? clear block]

ren-c&gt;&gt; assert block
** Access Error: series has temporary read-only hold for iteration
** Where: clear evaluate while _ assert console
** Near: [*** empty? clear block **]
** Line: 1
</code></pre>
<h2>Invisibility in Ren-C</h2>
<p>A difference with Ren-C is that you can put an assert anywhere and it won't count against the evaluation:</p>
<pre><code> ren-c&gt;&gt; all [1 = 1, assert [2 = 2], 10 + 20]
 == 30

 ren-c&gt;&gt; any [1 = 2, assert [2 = 2], 10 + 20]
 == 30
</code></pre>
<p>R3-Alpha can't have it both ways...the behavior has to fall on the side of making assert return something either truthy or falsey:</p>
<pre><code>r3-alpha&gt;&gt; all [1 = 1 assert [2 = 2] 10 + 20] 
== 30  ; because the assert returned true

r3-alpha&gt;&gt; any [1 = 2 assert [2 = 2] 10 + 20]
== true  ; because the assert returned true
</code></pre>
<h2>Implementation Needs</h2>
<p>This gives an example of an abstraction that wants to be able to:</p>
<ul>
<li>record a position</li>
<li>perform an evaluation step</li>
<li>decide it doesn't like the evaluation result, and implicate the position it previously recorded</li>
</ul>
<p>I started the discussion about "state accumulation" with LET.  But let's talk about something like MACRO, which throws a more obvious wrench into this situation.</p>
<p>For instance, let's imagine:</p>
<pre><code>macroA: enfix macro [] [return [+ 2 =]]
macroB: macro [] [return [3 10 =]]

assert [1 macroA macroB 20]
</code></pre>
<p>The full expression being processed in practice would be <strong>assert [1 + 2 = 3 10 = 20]</strong> which should fail on the 10 = 20.</p>
<p>Here we have not just a desire to take single steps across a virtualized block, but also a desire to produce meaningful error messages.</p>
<p><strong>How to deal with this kind of situation?</strong>  We're in a position where we can probably get the evaluator to make the code work for a plain DO.  But when it comes to giving errors and single stepping, what parts are involved is not clear.  Is this something that should be forbidden, because the evaluator state is not entirely capturable in terms of the input block's positions?  If not forbidden, what sort of interface and mitigation would it need?</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/dissecting-the-assert-dialect/1508">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/dissecting-the-assert-dialect/1508</link>
          <pubDate>Sun, 14 Feb 2021 21:28:32 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1508</guid>
          <source url="https://forum.rebol.info/t/dissecting-the-assert-dialect/1508.rss">Dissecting the ASSERT Dialect</source>
        </item>
        <item>
          <title>JS-EVAL and JS-DO</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p><em>(I knew I'd written this up but couldn't find it...the reason was because it was a git commit message, not a forum post.  Reprinting here.)</em></p>
<p>This is a fun usage of the new @-types, which lets you refer to Rebol values more easily in JS-DO and JS-EVAL expressions. By doing so you not only save on typing, but it finesses what would be hairy escaping situations if your only currency was text:</p>
<pre><code>&gt;&gt; text: { ykcirT" a s'tI}

&gt;&gt; js-eval [{reb.Spell("reverse",} @text {) + "String" + '"'}]
== {It's a "Tricky String"}
</code></pre>
<p>So what's going on there is it's generating a temporary API handle to refer to the value fetched from TEXT. This API handle is then used literally as one of the arguments to the variadic/evaluating<br>
extraction routines in the API (mixed here with some JavaScript <code>+</code> string concatenation). The variadic knows to free this handle after it is done processing it, (so it is like a reb.RELEASING() or reb.R()<br>
handle).</p>
<p>This is more powerful than just treating a block as running JS-EVAL UNSPACED [...]. But if you want that, you can still use a plain GROUP!:</p>
<pre><code>&gt;&gt; text: "gnirob"

&gt;&gt; js-eval [{"} (reverse text) { group"}]
== "boring group"
</code></pre>
<p>You can use <span class="mention">@path</span>/values, @(computed values). Although INTEGER! Rebol values aren't the best example (since you could pass them fine via their string representations), they'll work too <em>(just easier to demo in a PR than Blobs for BINARY! and such...)</em></p>
<pre><code>&gt;&gt; x: 1000
&gt;&gt; y: 20
&gt;&gt; js-eval [{reb.Unbox(} @(x + y) {)}]
== 1020
</code></pre>
<p>And to make things even more succinct, WORD!s in this dialect can be<br>
used to generate the reb.XXX() calls for you:</p>
<pre><code>&gt;&gt; x: 1000
&gt;&gt; js-eval [{20 +} unbox @x]
== 1020
</code></pre>
<p>Currently there's support for UNBOX and SPELL, but this could expand.</p>
<p>(Note: JS-DO and JS-EVAL are similar, except JS-EVAL tries to return a result to Rebol translated from the JavaScript it is given...and cannot declare variables in global scope. See technical notes in the implementation if interested.)</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/js-eval-and-js-do/1504">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/js-eval-and-js-do/1504</link>
          <pubDate>Fri, 12 Feb 2021 14:07:38 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1504</guid>
          <source url="https://forum.rebol.info/t/js-eval-and-js-do/1504.rss">JS-EVAL and JS-DO</source>
        </item>
        <item>
          <title>Dissecting the TLS EMIT Dialect</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>As we question <a href="https://forum.rebol.info/t/pivotal-design-question-is-evaluator-state-just-a-block/1496">what the rules are for evaluator state between steps</a>, it's instructive to look at dialects that make use of stepwise evaluation.</p>
<p>One such dialect that comes to mind is the EMIT dialect I designed to try and make the TLS protocol code leverage the language better.  It's used for constructing BINARY! packets by appending material together, where SET-WORD!s are made into variables holding positions in that binary packet based on where they occur:</p>
<pre><code>emit ctx [
  TLSPlaintext: ; https://tools.ietf.org/html/rfc5246#section-6.2.1
    #{16}                       ; protocol type (22=Handshake)
    min-ver-bytes               ; TLS version for ClientHello (min? max?)
  fragment-length:
    #{00 00}                    ; length of handshake data (updated after)
]
</code></pre>
<p>One thing the labels provide is documentation of what's at each position.  So even if they're not used, they are helpful.</p>
<p>But the positions also can be used for reading and writing the data.  Here we see some information being assembled at the start of the packet, which has a two-byte "fragment length".  We don't yet know what this length is, so it's filled in with zeros and patched later:</p>
<pre><code>change fragment-length enbin [be + 2] (length of Handshake)
</code></pre>
<h2>Note That This Is A Poster Child For Making EMIT "LET-like"</h2>
<p>The position variables are not aggregated in some kind of context or a map.  If they were, you would have to write it as:</p>
<pre><code>labels: emit ctx [
  TLSPlaintext: ; https://tools.ietf.org/html/rfc5246#section-6.2.1
    #{16}                       ; protocol type (22=Handshake)
    min-ver-bytes               ; TLS version for ClientHello (min? max?)
  fragment-length:
    #{00 00}                    ; length of handshake data (updated after)
]
...
change labels/fragment-length enbin [be + 2] (length of Handshake)
</code></pre>
<p><strong>I think that not having to be explicit is somewhat critical to the point.</strong>  So the EMIT abstraction could benefit from being "like LET" in that it wants to generate variable bindings you can use in the stream afterwards.</p>
<p>But at time of writing, it depends on being inside a "FUNCT"-style function which will "gather" the SET-WORD!s.  That means you'd be out of luck if you COMPOSE-d in the values, since FUNCT wouldn't see them.</p>
<p>I've made the case many times that having a 1:1 correspondence between SET-WORD!s and locals often gets you <em>too many</em> spurious locals.  But what about too few, if you miss other notations?  Let's say the designer wanted to call out the sections with BLOCK! instead?</p>
<pre><code>emit ctx [
  [TLSPlaintext] ; https://tools.ietf.org/html/rfc5246#section-6.2.1
    #{16}                       ; protocol type (22=Handshake)
    min-ver-bytes               ; TLS version for ClientHello (min? max?)
  [fragment-length]
    #{00 00}                    ; length of handshake data (updated after)
]
</code></pre>
<p>Or maybe SET-BLOCK! means "label and create variable" while plain SET-WORD! means "just label"?  Anyway, just raising the point that having functions like LET be able to create one or more new variables is powerful.</p>
<p><a href="https://forum.rebol.info/t/giving-functions-the-power-to-create-local-variables/1499">UPDATE: I have made EMIT create its own variables</a>, using a fledgling generic mechanism.</p>
<h2>Dissecting the Implementation</h2>
<p>The current EMIT is very comprehensible.  It does stepwise evaluation of the block:</p>
<ul>
<li>
<p>At the beginning of each step it looks to see if the value right in front of it is a SET-WORD!.  If it is, then it sets the value of that word to the marked position in the binary so far...and skips the SET-WORD! so it's not part of the evaluation.</p>
</li>
<li>
<p>For non-SET-WORD!s a single evaluation step is done, and the BINARY! result of it is added to the buffer.</p>
</li>
</ul>
<p>This is rigged in such a way that even supports comments and invisibles, such as ELIDE, ASSERT, and debug dump routines.</p>
<pre><code>emit: function [
    {Emits binary data, optionally marking positions with SET-WORD!}

    return: &lt;void&gt;
    ctx [object!]
    code [block!]
    &lt;local&gt; result
][
    while [code] [
        if set-word? code/1 [
            set code/1 tail ctx/msg  ; save position
            code: my next
        ]
        else [
            ; Keep evaluating so long as returned code pos is quoted, as
            ; it indicates invisible eval (`emit ctx [comment "X" ...]`)
            ;
            if until .not.quoted? [[code result]: evaluate code] [
                append ctx/msg ensure binary! result
            ]
        ]
    ]
]
</code></pre>
<h2>Observation: Only Sees SET-WORD!s At Start Of Step</h2>
<p>It only recognizes SET-WORD!s at the <em>start</em> of evaluation steps.  Any SET-WORD!s that are part of a function parameter won't count.</p>
<p>So imagine if min-ver-bytes took a parameter, e.g. <strong>min-ver-bytes: func [version]</strong></p>
<pre><code>emit ctx [
  TLSPlaintext:
    #{16}
    min-ver-bytes version: 1.2
  fragment-length:
    #{00 00}
]
</code></pre>
<p>So you wouldn't wind up with VERSION being set to a BINARY! position.  It would just be a normal assignment in the evaluator, and get 1.2</p>
<p>Curiously, LET wouldn't have this problem...because LET is invisible when followed by a SET-WORD!.  The set-word just gets a new binding.  But using LET for this wouldn't give you a definition outside of the block, only inside it:</p>
<pre><code>emit ctx [
  let TLSPlaintext:  ; only defined to end of block
    #{16}
    min-ver-bytes
  let fragment-length:  ; only defined to end of block
    #{00 00}
]
...
change fragment-length enbin [be + 2] (length of Handshake)  ; error
</code></pre>
<p>This is why EMIT has to take over the duty of LET, adding the new bindings to the frame itself.  <em>(It could choose to do so only if you say LET...thus allowing plain SET-WORD! to be just a comment...but it would not be running LET, just recognizing the word to help document that a new declaration was being created.)</em></p>
<h2>Every Step Must Produce A BINARY!...or be invisible</h2>
<p>The concept behind this is that all the steps either produce a BINARY!.  But you have the nice exception of invisible evaluations.</p>
<pre><code>emit ctx [
  let TLSPlaintext:
    #{16}
    elide prep-for-min-ver-bytes arg
    min-ver-bytes
  let fragment-length:
    #{00 00}
]
</code></pre>
<p>Historical Rebol could have let you do what you would do with invisibles with a GROUP!, you'd just have to put the things you wanted to throw away at the beginning of it:</p>
<pre><code>emit ctx [
  TLSPlaintext:
    #{16}
    (prep-for-min-ver-bytes arg, min-ver-bytes)  ; pretend they had comma
  fragment-length:
    #{00 00}
]
</code></pre>
<p>But this forces your dialect to sacrifice potential other uses for GROUP!s.</p>
<p>I think the general case of stepwise evaluation that tries to mix in its own behavior should want to gracefully handle invisibles.</p>
<h2>I Think TLS EMIT is a Very Good Example</h2>
<p>This is a useful thing.  While it would be ridiculous to bet your internet security on this particular TLS codebase, the methodology of this dialect shows promise for how to deal with other real problems.</p>
<p><strong>We do see that this case would work under the feed-based interface protocol of a variadic.</strong> That is to say, that if what EVALUATE did was spin up a FRAME!, and restrict you from going back in time...forcing you to look ahead one unit at a time and either consume or evaluate it, then it would still be fine.</p>
<p>I think that will be a pattern you will notice to be true in most "evaluator-compatible" dialects, that do not isolate their evaluation portions into GROUP!s or BLOCK!s.  If this pattern holds up, it suggests that allowing the evaluator to accrue state that is not purely representable in terms of a block position is reasonable.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/dissecting-the-tls-emit-dialect/1498">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/dissecting-the-tls-emit-dialect/1498</link>
          <pubDate>Wed, 10 Feb 2021 10:56:22 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1498</guid>
          <source url="https://forum.rebol.info/t/dissecting-the-tls-emit-dialect/1498.rss">Dissecting the TLS EMIT Dialect</source>
        </item>
        <item>
          <title>Whitespace Interpreter Revisited</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>I came across what was near-to-one of my first Rebol programs (the first one using PARSE).</p>
<p>It was an interpreter for a language called "Whitespace", where all the instructions are made out of tab, space, and newline characters.  My idea was to use PARSE to actually evaluate the code:</p>
<p><a href="https://github.com/hostilefork/whitespacers/blob/master/rebol/whitespace.reb">https://github.com/hostilefork/whitespacers/blob/master/rebol/whitespace.reb</a></p>
<p>The idea of using parse as the interpreter is an interesting take...<strong>but the code is far too repetitive.</strong>  It was clearly written before I knew much about COMPOSE or really using the generative side of things.</p>
<h2>Ideas on Doing it "Right"?</h2>
<p>Currently there's a split between the specification and the implementation.  That might be desirable in some cases, but I don't think it's desirable here.</p>
<p>The instructions are grouped together, which lets them "inherit" their leading sequence.  For example, putting <strong>push [space Number]</strong> and <strong>duplicate-top [lf space]</strong> in "Stack-Manipulation" container lets them inherit the leading space common to each instruction.  Otherwise they'd have to be spelled out as <strong>[space space Number]</strong> and <strong>[space lf space]</strong>.</p>
<p>But beyond that, being inside a grouping pulls them out of "global scope", which means the instructions aren't overwriting the definitions of things like <strong>add</strong> and <strong>subtract</strong> with the whitespace versions.</p>
<h2>Reducing The Repetition</h2>
<p>The first thing I think of is merging the functions with the whitespace spec, and doing it more dialect-style:</p>
<pre><code>    ; The 2010 JavaScript-Like Way
    ...
push: [
	command: [space Number]
	description: {Push the number onto the stack}
]
duplicate-top: [
	command: [lf space]
	description: {Duplicate the top item on the stack}
]
    ...
push: func [value [integer!]] [
    insert stack value
    return none
]
duplicate-top: func [] [
    insert stack first stack
    return none
]
</code></pre>
<p>Being relatively liberal in syntax here, we can imagine doing this more like:</p>
<pre><code>; A Modern Dialected Way

push: ??? [
    {Push the number onto the stack}
    space (value &lt;number!&gt;)
][
    insert stack value
    return none
]

duplicate-top: ??? [
    {Duplicate the top item on the stack}
    lf space
][
    insert stack first stack
    return none
]
</code></pre>
<p>This is a little push in the right direction.  But we have some issues to think through.</p>
<ul>
<li>
<p>Whatever we're building here as units of the language need to be "registered" in the complete list of operations.  If they were global declarations run by the evaluator, then one of the things the <code>???</code> operator would have to do would be this registration.  If they are not global, then registration could be done by their container that is invoking them.</p>
</li>
<li>
<p>We still have to inherit the leading space that both of these instructions have.  An interesting point in the PARSE branching is that we benefit from having the knowledge that these all start with space, so that the space can lead into these tests as alternates...e.g. <strong><code>[space [lf space | space &lt;Number&gt;]]</code></strong> will be more efficient than <strong><code>[space lf space | space space &lt;Number&gt;]</code></strong>.</p>
</li>
<li>
<p>If we decide that the container is the boss, then giving a name to <code>???</code> is not really necessary.  But what happens if you leave it off?</p>
<pre><code>... Stack-Manipulation ... [
    push: [
        {Push the number onto the stack}
        space (value &lt;number!&gt;)
    ][
        insert stack value
        return none
     ]
     ...
 ]
</code></pre>
<p>This is a counterintuitive mixture of a SET-WORD! with two blocks after it. How do we reconcile the idea of "declaration-like-things" inside of a container like this?  The code needs to be in a block, the other things don't...so other notations are possible...</p>
<pre><code>... Stack-Manipulation ... [
    PUSH
    {Push the number onto the stack}
    space (value &lt;number!&gt;) [
        insert stack value
        return none
     ]
     ...
 ]
</code></pre>
</li>
</ul>
<p>I guess the easiest thing to do is to cave, and just come up with something for ???.  It has the benefit that you can actually run your implementation of Stack-Manipulation through the evaluator and do normal assignments.  So something like <strong>push: instruction [...] [...]</strong></p>
<p>Yet there's something a bit dissatisfying about having to type INSTRUCTION redundantly each time...where you're also kind of claiming that word so it can't be used other ways.</p>
<h2>Lots Of Other Questions...</h2>
<p>I think it would be worthwhile to rework this, but it's worth taking note of how adrift you can get right out of the gate looking at it.  There are lots of big questions that don't really have obvious answers.</p>
            <p><small>18 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/whitespace-interpreter-revisited/1482">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/whitespace-interpreter-revisited/1482</link>
          <pubDate>Sat, 30 Jan 2021 17:09:24 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1482</guid>
          <source url="https://forum.rebol.info/t/whitespace-interpreter-revisited/1482.rss">Whitespace Interpreter Revisited</source>
        </item>
        <item>
          <title>Function Escapable Literal Parameters... :X or &#39;:X ?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <h2>Background with GROUP!s (prior to GET-GROUP! existing)</h2>
<p>Sometimes you don't pass a literal block of code to a conditional, but the callsite runs code that generates the branch--or fetches it out of a variable.</p>
<p>Historical Rebol has this behavior for GROUP!s in conditionals:</p>
<pre><code> rebol2&gt;&gt; branches: [[print "Apple"] [print "Banana"]]

 rebol2&gt;&gt; either false (print "one" take branches) (print "two" take branches)
 one
 two
 Banana
</code></pre>
<p>Doesn't seem ideal.  But having both groups run is the only choice you have if the branches are evaluative parameters.  The GROUP!s are evaluated before EITHER has a chance to say anything about it.</p>
<p>I pointed out that this was inconsistent with things like historical CASE:</p>
<pre><code> rebol2&gt;&gt; branches: [[print "Apple"] [print "Banana"]]

 rebol2&gt;&gt; case [
      false (print "one" take branches)
      true (print "two" take branches)
 ]
 two
 Apple
 == true  ; ignore silly `true` (Ren-C &amp; Red give PRINT's result)
</code></pre>
<h2>Ren-C Takes Branches Literally and Was Able To Sync This Up</h2>
<p>Ren-C had begun requiring branches be single literal values for other reasons, namely to give it access to the quote status of the argument:</p>
<pre><code>ren-c&gt;&gt; if true 'a
== a

ren-c&gt;&gt; if true '[a b c]
== [a b c]
</code></pre>
<p>So to provide code you'd have to put it in a group (unless it's a single variable, where you could use a GET-WORD! or GET-PATH!)  For technically fiddly reasons, it also means that <strong>if (...) else (...)</strong> is fully swappable with <strong>either (...) (...)</strong>  when they would not be quite exact replacements otherwise.</p>
<p><strong>So long as we're going this way, conditionals have the choice to see the GROUP! which would evaluate to produce a branch, yet decide not to run it.</strong>  There were enough <img src="https://forum.rebol.info/images/emoji/twitter/heart.png?v=9" title=":heart:" class="emoji" alt=":heart:"> clicked on the idea to support this, so that's what we have now:</p>
<pre><code> ren-c&gt;&gt; branches: [[print "Apple"] [print "Banana"]]

 ren-c&gt;&gt; either false (print "one" take branches) (print "two" take branches)
 two
 Apple
</code></pre>
<p>This goes further into the rabbit-hole of bending parameter conventions to suit the likely intent of usage.  But I think it's a good example of where it's worth it.  It's better than twisting around to get the reverse consistency...forcing CASE to run its GROUP!s regardless of the condition matching.</p>
<h2>Soft Literal Parameters vs. Hard Literal Parameters</h2>
<p>Rebol2 introduced the variations of "hard literal" as :X and "soft literal" as 'X.  Hard literals would always give you the callsite value literally...</p>
<pre><code>rebol2&gt;&gt; hard: func [:x] [print mold x]

rebol2&gt;&gt; var: 'foo

rebol2&gt;&gt; hard var
== var

rebol2&gt;&gt; hard :var
== :var

rebol2&gt;&gt; hard (first [foo bar])
== (first [foo bar])
</code></pre>
<p>Soft literals would make GET-WORD!, GET-PATH! evaluative...with everything else literally what was at the callsite:</p>
<pre><code>rebol2&gt;&gt; soft: func ['x] [print mold x]

rebol2&gt;&gt; var: 'foo

rebol2&gt;&gt; soft var
== var

rebol2&gt;&gt; soft :var
== foo

rebol2&gt;&gt; soft (first [foo bar])
== (first [foo bar])
</code></pre>
<p>R3-Alpha added a twist: that soft quotes would evaluate GROUP!s vs. taking them literally:</p>
<pre><code>r3-alpha&gt;&gt; soft (first [foo bar])
== foo
</code></pre>
<p>Two big points:</p>
<ul>
<li>
<p><strong>This looks backwards for :x and 'x</strong>.  Shouldn't it be that the thing with GET-WORD! in the parameter name is the one that's "colon-reactive"?</p>
</li>
<li>
<p><strong>The picture gets even more consistent if we use GET-GROUP! for the code escape</strong>.  Then all the quoting subversion is colon'd, and regular GROUP!s can go back to not being "soft" as in Rebol2.</p>
</li>
</ul>
<p>This makes the branch quoting example work with soft branches.  SO you get control if you want to get back to the "run the code whether you take the branch or not" situation:</p>
<pre><code> ren-c&gt;&gt; branches: [[print "Apple"] [print "Banana"]]

 ren-c&gt;&gt; either false :(print "one" take branches) :(print "two" take branches)
 one
 two
 Banana
</code></pre>
<p>I hope all the above makes sense.  <em>Please speak up if it does not make sense.</em></p>
<h2>So... Should Escapable Literals Be <code>:param</code> or <code>':param</code> ?</h2>
<p>One truism is that unless you have a very good reason to need to quote GET-WORD!s, GET-PATH!s, and GET-GROUP!s...your construct should permit escaping to make it easy for callsites to tunnel in what they want without resorting to APPLY.  This likely guided R3-Alpha to make escapability the default behavior for the common <code>'param</code> form.</p>
<p>So if we're asking people to default all literal parameter callsites to the escapable convention, then <strong>:param</strong> is nicer to look at than <strong>':param</strong>, even if the latter is "more communicative".</p>
<p>One factor to weigh would be if there were an interesting meaning for <strong>:param</strong> that didn't involve literalness.  Let's review the new escapable literal concept, and pretend for a moment we say it's a quoted get-word!:</p>
<pre><code> &gt;&gt; soft: func [':param] [print mold param]

 &gt;&gt; var: 'foo

 &gt;&gt; soft var
 == var

 &gt;&gt; soft :var
 == foo

 &gt;&gt; soft (first [foo bar])
 == (first [foo bar])

 &gt;&gt; soft :(first [foo bar])
 == foo
</code></pre>
<p>So is there any meaning for "plain escapable"?</p>
<pre><code> &gt;&gt; huh: func [:param] [print mold param]

 &gt;&gt; huh ... ?
</code></pre>
<p>Presumably this would similarly be an instruction to how :x, :x/y, and :(x y) are handled at the callsite.  But if you're not escaping the quoting, what <em>are</em> you escaping?</p>
<p>It would be silly to say you are "escaping evaluation":</p>
<pre><code> &gt;&gt; huh :(a)
 == a
</code></pre>
<p>That is done more cleanly with quoting, as a generic "escaping evaluation" tool for evaluative parameters...and doesn't raise questions about how to treat <strong>huh :(a b)</strong></p>
<pre><code>&gt;&gt; huh 'a
== a
</code></pre>
<p>There are some other choices for what it might mean, like "optional".  That's something that doesn't apply to literal parameters (because you can't get NULL literally).</p>
<pre><code>func [:arg [any-value!]] [...]  &lt;=&gt; func [arg [&lt;opt&gt; any-value!]]
</code></pre>
<p>I don't know that it makes a whole lot of sense.  And having a way to recognize NULL in-band in the type block is important:</p>
<pre><code> &gt;&gt; match [&lt;opt&gt; integer!] null then [print "This should run"]
 This should run
</code></pre>
<hr>
<h2>Brainstorm On One Aspect of Distinction</h2>
<p>So trying to make the change I tripped up on some edge cases, which suggests that for some functions they are more willing to let soft quoted sites come from the evaluation of more than one cell.</p>
<p>We might imagine for instance that <strong>':x</strong> or <strong>:x</strong> controls how enfix is handled.  Consider the following:</p>
<pre><code>&gt;&gt; integer! = type of 1
== #[true]

&gt;&gt; integer! = :(second [length type]) of 1
== #[true]
</code></pre>
<p>For OF, this is how you want the interaction to shake out when you are midstream in an enfix evaluation... <code>integer! = (type of 1)</code>.  But other constructs might want to consider an in-progress enfix something not to interrupt...and treat it like the left was more-or-less in a GET-GROUP!.</p>
<p>As an example, consider the <a href="https://forum.rebol.info/t/the-most-vexing-evaluation-lambda-meets-then-else/1361">most vexing evaluation</a>:</p>
<pre><code>&gt;&gt; if true [&lt;branch&gt;] then x -&gt; [print ["THEN" x]] else [print "ELSE"]
THEN &lt;branch&gt;

&gt;&gt; if false [&lt;branch&gt;] then x -&gt; [print ["THEN" x]] else [print "ELSE"]
ELSE
</code></pre>
<p>The THEN and ELSE branches want to see their argument literally, e.g. if it's quoted.  But it wants branches to be escapable (so you can use the GET-GROUP! to run the branch regardless), <em>and</em> it wants enfix to be able to overrule it.  That's different from the left argument for OF, which wants escapable literalness but does <em>not</em> want the enfix equality operator to win.</p>
<p>We might then say that <strong>':x</strong> is the strict form of "only one value on the left is inspected".  e.g. it is quoted, and <em>then</em> it is escaped.  Then <strong>:x</strong> could mean "it's accepted if it's already in mid-evaluation, otherwise it is quoted, then escaped".</p>
<p>So <strong>:x</strong> would be saying <em>"I don't out-prioritize enfix"</em> while <strong>':x</strong> says <em>"I beat enfix just as 'x would, but then the escaping is automatic so you don't have to do it inside your function body"</em>.</p>
<p>Continuing the thought experiement...you'd have SOFT</p>
<pre><code>&gt;&gt; soft: func [:x] [print [mold x], 10]

&gt;&gt; soft add 1 2
add
== 2  ; (soft add) 1 2

&gt;&gt; soft 1 + 2
3
== 10  ; soft (1 + 2)

&gt;&gt; soft :(1 + 2)
3
== 10 
</code></pre>
<p>Then MEDIUM</p>
<pre><code>&gt;&gt; medium: func [':x] [print [mold x], 10]

&gt;&gt; medium add 1 2
add
== 2  ; (medium add) 1 2

&gt;&gt; medium 1 + 2
1
== 12  ; (medium 1) + 2

&gt;&gt; medium :(1 + 2)
3
== 10

&gt;&gt; medium (1 + 2)
(1 + 2)
== 10
</code></pre>
<p>And HARD would be as you expect, always exactly the callsite parameter.</p>
<p><em>While I'm admittedly a bit wary of super complex parameter conventions, I also like having full coverage of the potential desires.</em>  What worries me a little is that this feels like the "tight" parameter convention coming up again...though it's backwards and maybe a little more logical, saying the only places you can ask for looseness is in parameters that are "weird" by virtue of quoting.  While it's late and I don't really have a full articulation of why this is more coherent... I think it likely is.</p>
<p>But...mucking with the code and seeing impact across the system in the tests is the way to test that theory.</p>
<hr>
<h2>Bonus Question... what might <strong>:[get blocks]</strong> do with escaping?</h2>
<p>It seems that if GET-WORD!, GET-PATH!, and GET-GROUP! evaluate for <strong>:SOFT</strong> parameters, then there might be some kind of magic for GET-BLOCK!s.</p>
<pre><code>&gt;&gt; soft :[what's this for?]
== ???
</code></pre>
<p>Even if we can't think of anything right now, I'd think they should error to reserve for future use (vs. pass the GET-BLOCK! through as if it were any other type).  Or just to keep from seeming inconsistent.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/function-escapable-literal-parameters-x-or-x/1433">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/function-escapable-literal-parameters-x-or-x/1433</link>
          <pubDate>Sun, 13 Dec 2020 02:08:08 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1433</guid>
          <source url="https://forum.rebol.info/t/function-escapable-literal-parameters-x-or-x/1433.rss">Function Escapable Literal Parameters... :X or &#39;:X ?</source>
        </item>
        <item>
          <title>Notation for (Inputs/)Outputs in Function Spec Dialect</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>The first cut at multiple return values made a multi-return output look like:</p>
<pre><code> func [/foo [&lt;output&gt; integer!]] [...]
</code></pre>
<p>Which was expedient to try it out.  <strong>But dialect-wise, I think a SET-WORD! makes more sense:</strong></p>
<pre><code> func [foo: [integer!]] [...]
</code></pre>
<p>This would take away SET-WORD! as a way of denoting locals in the frame.  This was to make it easier for higher-level generators to stick values in the frame without having to search for a <code>&lt;local&gt;</code> annotation and inject at the right place.  Programmatic code generating frames could stick locals anywhere they wanted in the parameter sequence, which was helpful.</p>
<p>If we're thinking that's still a useful idea, then <strong>func [a b: c] [...]</strong> could be rethought e.g. as <strong>func [a .b c] [...]</strong>.</p>
<blockquote>
<p>I will point out that while this sounds convenient, any higher level generator that just splices words into specs like this can run into problems of name reuse...since locals cannot clash with parameters.</p>
</blockquote>
<h2>But What About The Deviant RETURN: ?</h2>
<p>The only "local" most users noticed in specs was RETURN:.   Strangely enough, yes, it was a frame local variable...that held the definitional RETURN function.</p>
<p>It's a bit confusing to have RETURN: work different than other things specified by SET-WORD!.  This could be avoided by using a different convention, e.g. <strong><code>&lt;return&gt; [integer!]</code></strong> to stress the difference.</p>
<p>Or we could just say that it's "one of those things" and learnable, that the act of naming a return value "RETURN:" implies it's the main return...and gets special conventions and handling.</p>
<h2>Why Aren't Returns Written Directly To Frame Slots?</h2>
<p>Something that may seem confusing about return values is that you don't assign them with SET-WORD!s, you assign them with SET.</p>
<pre><code> foo: func [return: &lt;void&gt;, multi: [integer!]] [
     multi: 10  ; **wrong** (should be an error, assigning read-only cell)
     set multi 10  ; **wrong** (multi is NULL if caller didn't want it)
     if multi [cheat: get multi]  ; **wrong** (variables voided prior to call)
     if multi [set multi 10]  ; CORRECT: detect desire for output
 ]
</code></pre>
<p>(Note that you can't GET a multi-return input variable, because the variables are voided prior to the call. This avoids the possibility of "outputs" acting as inputs.)</p>
<p>I've made the point that this allows us to tie in the request for an output with a difference in semantics for the function... where using <code>#</code> is a way of asking for the semantics without also needing to give a variable to store the result in.</p>
<p>This design makes even more sense when you consider that they are made to be compatible with the passing of words that you can do historically.  <em>Without this, there'd have to be some kind of parallel-universe of interacting with them in things like APPLY.</em></p>
<pre><code>apply :foo [/multi 'var]  ; what would the syntax be otherwise?
</code></pre>
<p>Really...as weird as all this is, it's at the same time familiar.</p>
<p>We could imagine a different setup which tried to let you just do <strong>multi: 10</strong> directly, and then when the operation was over would proxy that value into the target variable.  And it could use some similar rules about how when the frame started, it could be either NULL if it wasn't wanted or <code>#</code> if it was wanted.  But that seems a lot more error-prone.  And the variable exists anyway to make the request...so why not go ahead and set it where it is, instead of going through a middleman anyway?</p>
<h2>What To Do About Input/Output Name Collisions?</h2>
<p>To <strong><a href="https://forum.rebol.info/t/multiple-returns-and-branching-could-it-unseat-voidification/1408/2">bring an end to voidification</a></strong>, I need a channel of communication set up between branching constructs and subsequent enfix operators...so they know if the branch was taken or not.</p>
<p>I've rigged up something very hacky, but good enough to get me to the next big question: <strong>what happens when the subsequent enfix operation is treated as a branching operation itself</strong>.</p>
<p>Could a parameter be converted into an "in-out" form?  <strong>/branched:</strong> perhaps?  <img src="https://forum.rebol.info/images/emoji/twitter/thinking.png?v=9" title=":thinking:" class="emoji" alt=":thinking:"></p>
<pre><code> else: enfixed func [
     return: [&lt;opt&gt; any-value!]
     /branched: [logic!]  ; hypothetical syntax
     value [&lt;opt&gt; any-value!]
 ][
     ...
 ]
</code></pre>
<p>But this is a bit of a can of worms.  You could have a situation where branched wasn't passed as an input -nor- requested as an output...where it was only one of the two...or where it was both.  How are these states conveyed, and how do you react to them?</p>
<p>It's difficult not to think that this kind of parameter would best be handled as being set to the value on input (or NULL if no input), and then whatever value it holds at the end of the frame is its final result.  That's either proxied to an output variable if requested, or not if it isn't.  <em>But now you've lost the ability to tell if the output was requested or not...because that NULL state is taken for no input provided.</em></p>
<p>Could it be that there are two frame variables tied together, with the left giving the canon name for both the input and the output parameter, and the right as an internal alias for the output parameter?</p>
<pre><code> else: enfixed func [
     return: [&lt;opt&gt; any-value!]
     /branched.branched-out: [logic!]  ; hypothetical syntax
     value [&lt;opt&gt; any-value!]
 ][
     ...
 ]
</code></pre>
<p>This overlaps a bit with something I've spoken about, which are cases where you'd rather the name you use on the interface be distinct from the name you use for something inside the frame.  Like if you named a refinement /ALL but you plan on using ALL [...] in your code, it would be nice to havae a notation to say you wanted a different name:</p>
<p><a href="https://forum.rebol.info/t/different-internal-names-for-parameters-in-function-spec/1335">"Different Internal Names For Parameters In Function Spec"</a></p>
<p>So one might think it could be solved in that way; you'd rename one (or both) of the /BRANCHEDs out of the way</p>
<pre><code> else: enfixed func [
     return: [&lt;opt&gt; any-value!]
     branched.branched-out: [logic!]  ; want output renamed
     value [&lt;opt&gt; any-value!]
     /branched [logic!]  ; just use same name for input
 ][
     ...
 ]
</code></pre>
<p>Seems nice, but this problem is fundamentally different.  Because a function like APPLY still has two possibilities for what /BRANCHED is fulfilling.  Our problem isn't just with internal naming, it's at the level of the interface itself not being able to call an input and an output the same thing.</p>
<p>Although... APPLY could have syntax for that.  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=9" title=":frowning:" class="emoji" alt=":frowning:"></p>
<pre><code> apply :foo [
     /branched true  ; input form, no colon
     /branched: 'var  ; output form, colon
 ]
</code></pre>
<p>That feels like it sucks and it's making things feel more painful than they already are.  And while it might work for APPLY, there's no such syntax for calling in a normal path invocation.</p>
<h2>So The Names Have To Be Distinguished On The Interface?</h2>
<p>If the input and output aren't somehow fused into one argument, then yes.  Distinct frame slots would need different names:</p>
<pre><code> else: enfixed func [
     return: [&lt;opt&gt; any-value!]
     branched-out: [logic!]
     value [&lt;opt&gt; any-value!]
     /branched-in [logic!]
 ][
     ...
 ]
</code></pre>
<p>But that just gives the question of what would motivate the evaluator to automatically tie together an input to an output with a distinct name.</p>
<p><strong>Sigh.</strong></p>
<p>Maybe there's a positional thing that could be done with it, the way modal parameters do it.  If you mark a parameter in a certain way, it will assume a relationship to an adjacent declaration</p>
<pre><code> else: enfixed func [
     return: [&lt;opt&gt; any-value!]
     /branched: [logic!]  ; or some syntax marking "output has input too"
     /branched-in [logic!]  ; since it follows a `/x:`, assumed linked
     value [&lt;opt&gt; any-value!]
 ][
     ...
 ]
</code></pre>
<h2>That's About The Best I've Got</h2>
<p>I've satisfied myself that the input and the output should not wind up stuffed into the same frame slot.  The input should be a normal refinement, and have either its value or NULL.  The output should be through a level of a WORD! indirection (or NULL if not requested).</p>
<p>I think I've made a pretty good case that since both slots appear on the public interface, it's not a good idea for them to have the same name.  You wouldn't be able to address them individually.</p>
<p><strong>Most constructs will not have to worry about this.</strong></p>
<p>It's a very rare category of function that would have to use this technique.  Take note that things like FIND and SELECT are designed to work within the framework where NULL is not a "meaningful value"...all they need to do is return NULL and they interoperate with ELSE.</p>
<p>If you write a normal non-enfix control structure, all you need to do is have a normal <code>branched:</code> output that you set in a straightforward way.</p>
<p>It's only enfix tools that are branching structures in their own right that have to pay this complexity tax.  But what we're saying is that it's better for them to pay it, so that we aren't having to contort every IF or CASE or SWITCH statement just to appease them.  It's localizing the concern into the place where the complexity belongs, vs making the whole rest of the system pay for it just so ELSE and THEN can be expressed simply.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/notation-for-inputs-outputs-in-function-spec-dialect/1414">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/notation-for-inputs-outputs-in-function-spec-dialect/1414</link>
          <pubDate>Sun, 22 Nov 2020 19:21:53 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1414</guid>
          <source url="https://forum.rebol.info/t/notation-for-inputs-outputs-in-function-spec-dialect/1414.rss">Notation for (Inputs/)Outputs in Function Spec Dialect</source>
        </item>
        <item>
          <title>APPLY II: The Revenge</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>It's time to bring back APPLY.</p>
<h2>First Big Question: Quote The Function or Not?</h2>
<p>This has been on my mind since the beginning: <em>should you have to use a GET-WORD! to name the function to apply, or does it quote by default...and make you put code fragments that returns a function in a group</em>.</p>
<pre><code> ; Worldview #1
 apply :append [series value]
 apply second reduce [:insert :append] [series value]  ; will APPLY :APPEND

 ; Worldview #2
 apply append [series value]
 apply :append [series value]  ; still legal if you want
 apply (second reduce [:insert :append]) [series value]  ; GROUP! is required
</code></pre>
<p><em>(Note: We have at least some relief at not having to consider Worldview <span class="hashtag">#3</span>, of <code>apply 'append [series value]</code> so APPLY can capture the name "append" for debug stack purposes.  That's not needed because <code>:append</code> gets an ACTION! that carries the label in its cell.  <a href="https://forum.rebol.info/t/more-comprehensible-errors-with-per-cell-labeling/1357">This has been a change that punches above its weight.</a>)</em></p>
<p>In the beginning I would have said it <em>definitely</em> has to go with Worldview <span class="hashtag">#1</span>, because in the second case you don't get a clear signal that APPEND is not being called on [SERIES VALUE] and the result being passed to APPLY.  If you didn't see the apply or were otherwise distracted, your reading comprehension would be thrown off by breaking from convention.</p>
<p>Over time I've become more of a believer that the whole premise of the language is to let you bend constructs to predominate use, so the 99% case is pleasing to use.  The now famous case of OF's left-quote, for instance:</p>
<pre><code>type: 'type of x  ; without OF quoting

type: type of x  ; with OF quoting
</code></pre>
<p>The quote mark makes it clearer, but when OF becomes so common that you "just know" then it's a much more pleasing function to use.  How many times do you use OF with a reflector you pick via code?  When is that code a single-arity function you wouldn't have to put in a GROUP! to use with enfix anyway??!</p>
<p>But does that same philosophy to APPLY, that we come to read <strong>apply append</strong> as one indivisible unit, and feel thankful for not having to reach for the colon key?  It's a little bit different than OF because you read left to right, and you can start reading at the APPEND with no speedbump after it.</p>
<p>I'll stress that you would still have the choice.  If you were the type of person who thought it clearer to use the colon, you could do so.  You just wouldn't be able to invoke a function-to-generate-the-function unless you put that in a GROUP!.</p>
<p><em>I can't make up my mind.</em>  So I think I'm going to make the answer Worldview 1.5:</p>
<pre><code> ; Worldview 1.5
 &gt;&gt; apply second reduce [:insert :append] [series value]
 ** Error: APPLY arguments must be GET-WORD! or GROUP! at the moment
</code></pre>
<p>This leaves the door open to interpreting plain WORD! as naming a function in the future.  And it gives time for people to find a really compelling case for where not being able to generate a function without using a GROUP! would be a deal-breaker.</p>
<h2>Naming Refinements</h2>
<p>Historical APPLY had a nasty positional nature for refinements, which led to things like this, from the R3-Alpha module code:</p>
<pre><code>return map-each [mod ver sum name] source [
    apply :load-module [
        mod true? ver ver true? sum sum no-share no-lib import true? name name delay
    ]
]
</code></pre>
<p>You see the combination of <code>true? ver</code> followed by <code>ver</code> as filling in first the refinement slot for /VERSION, and then the value of the refinement argument.</p>
<p>Then you see "used or not" refinements being supplied to their argument cells by the value alone (<code>no-share</code> signaling not to provide /SHARE, <code>no-lib</code> signaling not to use /LIB)</p>
<p><strong>But we can now put refinement names in the APPLY dialect!</strong></p>
<pre><code>apply :load-module [
    mod /version ver /sum sum
        /share null /lib null  ; avoids need for "clarifying" `no-share: false`
        /import import /name name
        /delay delay
]
</code></pre>
<p>You might ask what was stopping that before.  The issue was that historical Rebol had the problem that if you had an argument that could take on any value...including NONE!...then NONE! could not be used to represent the state of the refinement itself.</p>
<p>(Imagine if you are specifying an initial value to fill a block with (as in ARRAY/INITIAL).  It may be important to distinguish putting a NONE! in vs. not having a default at all.)</p>
<p>This is solved in Ren-C by reserving the non-valued NULL state for "refinement not taken".</p>
<blockquote>
<p>Note: I'd gone back and forth a while over whether a REFINEMENT-like PATH! would be appropriate to use in this dialect, based on the question of whether they would be evaluator-active or not.  Ideas were floated around like <code>foo</code> would fetch a variable but be an error if it was NULL, while <code>/foo</code> would fetch a variable and allow NULL.</p>
<p>In the end, inertness for refinements won out.  BLANK!-headed PATH!s and TUPLE!s simply have more dialecting power if they don't overlap what could be a legitimate user intention to fetch variables.  This APPLY situation shows a good example of why inertness is good.)*</p>
<p>Also, if you want to literally pass a refinement value you can do so.  Just quote it:</p>
<pre><code>   apply :whatever [/refinement '/refinement]
</code></pre>
<p>That will pass /REFINEMENT as the refinement parameter.</p>
</blockquote>
<h2>Providing Normal Arguments By Name</h2>
<p>A neat feature of new APPLY will be not only that you can reorder refinements to put them in any position, but also that you can name normal arguments.</p>
<p>So things like this would be legal:</p>
<pre><code>&gt;&gt; apply :append [/dup 2, /value &lt;d&gt;, [a b c]]
== [a b c &lt;d&gt; &lt;d&gt;]
</code></pre>
<p>Everything is streamlined by the idea that refinements represent one (and only one) argument in the frame.  <em>Which has been a critical and elegance-making change.</em></p>
<p>The concept is that ordered parameters which have not yet been named would be filled in, in the order that they are supplied.  You wouldn't be able to specify something twice, so this would be an error:</p>
<pre><code>&gt;&gt; apply :append [/series [a b c], [d e f], &lt;g&gt;]
** Error: Duplicate argument supplied for SERIES
</code></pre>
<h2>Can LOGIC! Be Used With Parameterless-Refinements?</h2>
<p>I have belabored the point of why we don't want low-level FRAME! mechanics getting involved in <a href="https://forum.rebol.info/t/should-refinement-arguments-be-refinement-if-used/735/4">transforming <code>[#[true] #[false]]</code> into <code>[# null]</code></a> for refinements that are "either used or not".</p>
<p>Those rules don't really "apply" here.  APPLY is its own dialect with its own mechanics, and it can do what's convenient.  It can canonize true and false into # and NULL in the frame.</p>
<pre><code>foo: func [/usable /logicable [logic!]] [...]

apply :foo [/usable 1 &lt; 2, /logicable 1 &lt; 2]
; this would give usable of `#`, and logicable of `#[true]`

apply :foo [/usable 1 &gt; 2, /logicable 1 &gt; 2]
; this would give usable of NULL, and logicable of `#[false]`
</code></pre>
<p>Hopefully it makes sense why I think APPLY should be able to do this, while MAKE FRAME! and friends don't.  MAKE FRAME! is the tool for writing <em>APPLY-like-things</em>, and there's no layer between the frame and the evaluator where it's appropriate to put these transformations.  It should be kept pure.</p>
<h2>Should You Be <em>Able</em> to Provide Refinements By Position?</h2>
<p>I'm not sure if giving refinements by position is a great idea.  But this hits on a philosophical question of whether refinements have an order that is exposed to the user.</p>
<p><em>But specialization can shuffle the order.</em>  For instance, what was once a refinement can become a normal argument.</p>
<pre><code>&gt;&gt; foo: func [x [integer!] /refine1 [integer!] /refine2 [integer!]] [...]

&gt;&gt; parameters of :foo
== [x /refine1 /refine2]  ; one normal argument

&gt;&gt; foo-2: :foo/refine2
== [x refine2 /refine1]  ; two normal arguments (e.g. acts like FOO/REFINE2)
</code></pre>
<p>This makes things a bit wacky.</p>
<p>I feel like the safest decision for right now is to say that once you've filled all the ordered arguments, any more arguments in the APPLY with no label causes an error.  The place where this would cause issues would be if BLOCK!s are used to serialize and deserialize frame state generically.  That's a thorny problem in general, which brings us to...</p>
<h2>Should There Be An APPLY/ONLY</h2>
<p>The idea behind APPLY/ONLY was that you have the values for a function's arguments already processed, and you don't want to evaluate them again.</p>
<p>One thing that breaks APPLY/ONLY in Ren-C's world is that this doesn't give a way to supply NULL arguments.  One option would be to let the BAD-WORD! with label <code>~null~</code> be an escape mechanism for this, which might cover a lot of cases (though obviously not accurately capturing a frame that purposefully wanted to pass the ~null~ BAD-WORD!).</p>
<p><em>Because FRAME!s have come along as a general and pure tool for representing function applications, the pressure is taken off of APPLY to be all things to all people.</em>  I think it should start out as the handy evaluative form, and then wait for motivating scenarios before trying to bend to anything else.  Maybe another operator entirely would be more suitable, or just using FRAME! as it is.</p>
            <p><small>6 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/apply-ii-the-revenge/1406">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/apply-ii-the-revenge/1406</link>
          <pubDate>Thu, 19 Nov 2020 11:11:27 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1406</guid>
          <source url="https://forum.rebol.info/t/apply-ii-the-revenge/1406.rss">APPLY II: The Revenge</source>
        </item>
        <item>
          <title>The Dialecting Power of NewPath /REF/(INE)/[MENT]</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p><em>(Note: I have been calling <strong>/FOO/BAR</strong> a "refinement", so <strong>refinement? '/foo/bar</strong> is true)</em></p>
<hr>
<p>For a long while, I was hesitant to commit <strong><code>/foo</code></strong> to being inert, because I wondered if there was some greater meaning for it in binding.</p>
<p>But now I'm resigned to it.  Which gives a somewhat interesting result: a whole category of bound dialecting parts that you know <em>aren't</em> meant as variable references.</p>
<p>We already see how well this works with TUPLE! and predicates.  If they weren't inert, you'd have to worry that <strong>until .not.even? [...]</strong> should be interpreted as <strong>(until .not.even?), ([...])</strong></p>
<h2>What Cool Role Could Refinements Have?</h2>
<p>The original suggestion for predicates actually used refinements.  But <strong>until /not/even? [...]</strong> didn't seem to be as good, so tuple was used.</p>
<p>But is there a good use at callsites?</p>
<p>Something I observed today was that <strong><code>/(...)</code></strong> and <strong><code>/[...]</code></strong> open up a new GROUP! and BLOCK! type, at the very least.  What might this mean in PARSE, and could it be connected to a meaning for words like <strong>/rule</strong> or <strong>/obj/member</strong> ?</p>
<p>The only connotation refinements have right now is "optionality" and...<em>parameter-ness</em>?  The optionality could be one focus:</p>
<pre><code>&gt;&gt; did parse [a c] ['a /['b] 'c]  ; synonym for `opt ['b]`
== #[true]

rule: ['b]
&gt;&gt; did parse [a c] ['a /rule 'c]  ; synonym for `opt rule`
== #[true]
</code></pre>
<p>That's not compelling, clearly.  But I'm just trying to stimulate thoughts on what it might be used for.</p>
<p>Perhaps it could be the "matches literally, not as a rule" concept?</p>
<pre><code>&gt;&gt; data: [some integer!]

&gt;&gt; parse [[some integer!] [some integer!]] [2 /data]
== [[some integer!] [some integer!]]
</code></pre>
<p>This could build conceptually on the "more inert" form (as opposed to an active rule).  Though I kind of liked the "as-is" connotation of <span class="mention">@data</span>.  But perhaps this would be easier on the eyes.</p>
<p><em>This points out something I hadn't thought about...</em> that refinements could have been used for other signals:</p>
<pre><code>&gt;&gt; append [a b c] [d e]
== [a b c d e]

&gt;&gt; append [a b c] /[d e]
== [a b c [d e]]

&gt;&gt; append [a b c] '/[d e]
== [a b c /[d e]]

&gt;&gt; data: [d e]
&gt;&gt; append [a b c] /data
== [a b c [d e]]
</code></pre>
<p>I had a vague inkling that it might be used in blaming function parameters:</p>
<pre><code>&gt;&gt; foo: func [x] [fail /x "Pointing at problem"]

 &gt;&gt; foo 10
** Error: Pointing at problem
** Where: foo console
** Near: [foo 10 **]  ; note it indicates callsite, not the FAIL site
</code></pre>
<p>That sort of makes sense, because /FOO is likely to be used in the apply dialect to name parameters.  So this could be seen as better than <strong><code>fail @foo</code></strong>.  What makes me a little uncomfortable with it is that paths and URLs will be legal as the error ID, so having a "slashed thing" might seem repetitive in a way that the @ would not.</p>
<p><em>This is just a brainstorm pointing out the existence of an available new-old-type.</em>  I'd be interested to hear any ideas or feelings on what PARSE might do with it...</p>
<h2>Then...What About GET and SET Forms?</h2>
<p>There's four assignment forms to deal with:</p>
<ul>
<li><strong><code>.foo.bar:</code></strong></li>
<li><strong><code>:.foo.bar</code></strong></li>
<li><strong><code>/foo/bar:</code></strong></li>
<li><strong><code>:/foo/bar</code></strong></li>
</ul>
<p>What would these be for?</p>
<p>I've proposed terminal slash and dot be a commentary on whether the thing being gotten or assigned is allowed to be an action or not.  Though that seems to make <strong>:foo.bar.</strong> and <strong>foo.bar.</strong> synonymous, as the GET only has impact on actions...and you're assuring it's not one.</p>
<p>Just more stuff to think about.  My suggestion for anything that doesn't have an interesting novel answer yet is to just make it error...to save it for meaning something in the future.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/the-dialecting-power-of-newpath-ref-ine-ment/1401">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-dialecting-power-of-newpath-ref-ine-ment/1401</link>
          <pubDate>Fri, 13 Nov 2020 11:35:11 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1401</guid>
          <source url="https://forum.rebol.info/t/the-dialecting-power-of-newpath-ref-ine-ment/1401.rss">The Dialecting Power of NewPath /REF/(INE)/[MENT]</source>
        </item>
        <item>
          <title>MAKE-FILE and %% Unleashed: Time To Use It</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>There's a lot that isn't known about how NewPath files are going to work.  But I'm at the point where I think enough is known that it's time to start using it and get to pushing on its development.</p>
<p>This is the basic gist of the idea, showing the prototype MAKE-FILE and the <a href="https://forum.rebol.info/t/the-newpath-finesse-make-file-lit/1386">quoting shorthand <strong>%%</strong></a></p>
<pre><code>&gt;&gt; extension: "txt"
&gt;&gt; dir: %/home/test/

&gt;&gt; make-file '(dir)/subdir/foo.(extension)
== %/home/test/subdir/foo.txt

&gt;&gt; %% (dir)/subdir/foo.(extension)
== %/home/test/subdir/foo.txt
</code></pre>
<p>It completely replaces the <em>extremely sketchy</em> historical "pathing" of a FILE! to produce a new FILE!:</p>
<pre><code>&gt;&gt; dir: %/home/test

&gt;&gt; dir/subdir/foo  ; cases like this give no hint that it's a file
== %/home/test/subdir/foo
</code></pre>
<p>It's bad for all sorts of reasons--like that you don't really know what <strong>dir/2</strong> should do (does it give the <code>#h</code> character, or <code>%/home/test/2</code> ?).  The slash handling mechanics were ad hoc, adding more variability to the process instead of more certainty.</p>
<p>Now it will be an error, and good riddance.</p>
<h2>Structure Means More Checks Possible</h2>
<p>The hope of MAKE-FILE is not just to provide a representation that's nice to look at, but also one that can help you avoid mistakes that aren't caught by normal string operations.</p>
<p>For example:</p>
<pre><code>&gt;&gt; extension: "txt/bad"

&gt;&gt; %% a/b.(extension)
** Error: Embedded / encountered inside filename component: "txt/bad"
</code></pre>
<p>There is no mechanism for silent tolerance of doubled slashes.  Instead, situations that generate doubled slashes are called out:</p>
<pre><code>&gt;&gt; base: %/home/test/

&gt;&gt; %% [(base) /subdir]
** Error: Doubled / encountered while generating filename: /subdir
</code></pre>
<p>The code is a very rough prototype, <strong>and the reason I want to push forward on it is that I want other people involved in designing it</strong>.  Or at least throwing more situations at it so that we can figure out what protections offer good value propositions vs. just getting in the way.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/make-file-and-unleashed-time-to-use-it/1398">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/make-file-and-unleashed-time-to-use-it/1398</link>
          <pubDate>Thu, 12 Nov 2020 09:23:27 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1398</guid>
          <source url="https://forum.rebol.info/t/make-file-and-unleashed-time-to-use-it/1398.rss">MAKE-FILE and %% Unleashed: Time To Use It</source>
        </item>
        <item>
          <title>Should PARSE Rules Always Be BLOCK!s ?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>At the top level, PARSE allows only a BLOCK! rule.</p>
<pre><code>&gt;&gt; parse ["abc"] "abc" 
** Script Error: parse does not allow #[datatype! text!] for its rules argument
</code></pre>
<p>But when a rule is being invoked by reference, you get the option of that reference not having to be a BLOCK!:</p>
<pre><code>&gt;&gt; rule: "abc"

&gt;&gt; parse ["abc"] [rule]
== ["abc"]
</code></pre>
<p>Being able to break down your parse rules into named subexpressions is one of the huge advantages PARSE has over things like RegEx.  But there are questions raised about whether certain fetched contents from names should be <em>matched as value</em>, <em>matched as rule</em>, or considered errors.</p>
<p>As an example: What do you think this should do?</p>
<pre><code>word: 'reject
parse [reject reject] [2 word]
</code></pre>
<p>There seem to be 3 possibilities for what [2 word] does in this context:</p>
<ol>
<li>act like <strong>[2 reject]</strong>
</li>
<li>act like <strong>[2 'reject]</strong>
</li>
<li>raise an error</li>
</ol>
<p><em><strong>I think <span class="hashtag">#2</span> should be out of the question.</strong></em>  It's just too inconsistent with the rule-interpretation if it had been a BLOCK!.</p>
<p>What I have proposed to get <span class="hashtag">#2</span> would be:</p>
<pre><code>word: 'reject
parse [reject reject] [2 @word]
</code></pre>
<p>This lets you fetch a value and match it literally.  So BLOCK! would not be matched as a rule either.</p>
<p><em><span class="hashtag">#1</span> has the appeal of generality and the substitution principle.</em>  It implies any term that could occur in the rules as source could be put behind a WORD!.</p>
<pre><code> &gt;&gt; sub: '(print "Hi!")
 &gt;&gt; parse "aa" [some ["a" sub]]
 Hi!
 Hi!
 == "aa"
</code></pre>
<p>That seems kind of interesting.  Though if we're truly allowing anything, it means QUOTED!s would match things at one level of quote below themselves.</p>
<pre><code> &gt;&gt; sub: ''reject
 &gt;&gt; parse [reject reject] [2 sub]
 == [reject reject]
</code></pre>
<p>Though having to decorate the value you're matching to say "I'm meant as a match" is awkward.  This is why I like the <strong><span class="mention">@word</span></strong> concept... it lets you put the "match literally" annotation on the reference, while leaving the thing you are matching at the right quote level.</p>
<p>I really think the above is clearer as:</p>
<pre><code> &gt;&gt; sub: ['reject]
 &gt;&gt; parse [reject reject] [2 sub]
 == [reject reject]
</code></pre>
<p>It's enough clearer that I feel a twinge of prescriptivism in saying that you either use the <span class="mention">@xxx</span> syntax at your reference sites or you form your subrules as proper blocks.  Which is why I'm bringing up option <span class="hashtag">#3</span>.</p>
<p><strong>But the flexibility of the substitution principle is kind of hard to deny.</strong>  You might want to define:</p>
<pre><code> match-op: either condition ['any] ['some]
 parse "aaaa" [some "a", match-op "b"]
</code></pre>
<p>If all rules are forced into blocks, you wouldn't get that parameterization.  Because this wouldn't work:</p>
<pre><code> match-op: either condition [[any]] [[some]]
 parse "aaaa" [some "a", match-op "b"]  ; some "a", [any] "b"
</code></pre>
<p>With a block-rule-only when fetching WORD! we <em>could</em> say that you can get such weird behavior only if you use <strong>:match-op</strong> as GET-WORD!.</p>
<h2>I Guess <span class="hashtag">#1</span> Should Win</h2>
<p>What I've mostly done here is explain why <span class="hashtag">#2</span> is not going to happen, and why you should be happy for the new @(...) matching.</p>
<p><em>(Note: <span class="mention">@foo</span> will not allow voids, but if you do <strong>@(get/any 'foo)</strong> and it's void it will match that void symbol...because inside the GROUP! you had to do whatever the rigamarole to get at a void was.  This protects against typos so that <span class="mention">@some-undef</span> doesn't try and match <code>~undefined~</code> and silently fail.)</em></p>
<h2>Note About Interoperability With The @[datatype] Proposal</h2>
<p>Despite this new meaning for <code>@a</code>, <code>@a.b</code>, <code>@a/b</code>, and <code>@(a b)</code>... there'd not be any reason for <strong>@[a b]</strong> to mean the same thing as <strong>'[a b]</strong> as a parse rule.</p>
<p>This outlier status was the original premise guiding why @[integer] and friends were "relatively useless" enough to take for datatypes.</p>
<p>But the outlier status is also kind of confusing.  Plus now that <code>@[...]</code> is a common branch type, and wanting <strong><code>append [a b c] @[d e]</code></strong> to give <strong><code>[a b c [d e]]</code></strong> it complicates the picture.</p>
<p>With VOID! representation having undergone a eureka moment, it would be nice if datatypes have such a moment soonish.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/should-parse-rules-always-be-block-s/1390">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-parse-rules-always-be-block-s/1390</link>
          <pubDate>Sat, 07 Nov 2020 05:26:24 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1390</guid>
          <source url="https://forum.rebol.info/t/should-parse-rules-always-be-block-s/1390.rss">Should PARSE Rules Always Be BLOCK!s ?</source>
        </item>
        <item>
          <title>Should There Be A &quot;Keyword Bypass&quot; Keyword?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>A unique and sometimes uncomfortable design point of Rebol dialects--best exemplified by PARSE--is that there is no decoration to distinguish keywords from non.</p>
<p>For instance, imagine the unlucky author of this routine:</p>
<pre><code>filter: func [
    data [block!] "data to search"
    reject [any-value!] "item to filter out"
][
    parse data [any [remove reject | skip]]
]
</code></pre>
<p>They thought it seemed fine, but didn't know that REJECT was a keyword.  SKIP is also frequently used to hold an integer skip count.</p>
<p>When this kind of problem has come up in the past, I've thought that the right answer would be to take something like GET-WORD! to mean "use the real variable, not a keyword":</p>
<pre><code>parse data [any [remove :reject | skip]]
</code></pre>
<p>But in PARSE's overloaded world, of course GET-WORD! is taken for "get parse position".  Though I never particularly liked it, so I proposed <strong>mark pos</strong> instead of <strong>:pos</strong>.</p>
<p>Of course, this then meant anyone who had used a variable called MARK now ran afoul of the keywords.  :-/</p>
<h2>Should This Be Covered With A Single WORD! Operator?</h2>
<p>If we consider keyword collisions to be an edge case, then taking a whole datatype for it might be excessive.</p>
<p>What if there were an operator which was a kind of escaping mechanism, that meant <em>"don't treat this as a keyword?"</em></p>
<p>What comes to mind for me is a symbol, and it's one I've used for a connected purpose.  It's the <strong><code>&gt;-</code></strong></p>
<pre><code>parse data [any [remove &gt;- reject | skip]]
</code></pre>
<p>By being symbolic and light, it doesn't disrupt too badly.  It points at what it's talking about.</p>
<p>The concept would be that the default definition would just be a kind of pass-thru of its right hand side.<br>
So sort of like <strong>func [x] [:x]</strong> but it would be like REEVAL, and be able to be invisible if its right hand were invisible:</p>
<pre><code>&gt;&gt; (&gt;- add 10 20)
== 30

&gt;&gt; (&gt;- 304)
== 304

&gt;&gt; 1020 (&gt;- comment "hi")
== 1020
</code></pre>
<p>Then the enfix form of this (SHOVE) could be <strong><code>-&gt;-</code></strong>, which is not useless because it allows the right-hand side to be a PATH!.</p>
<p>With these in hand, dialects could promise that what's on the right of them wouldn't act as a keyword.  That promise would be easy to keep if they were doing literal inspections of an evaluative feed and only running things they didn't recognize.  Just don't do special handling for it, and the regular evaluation will happen.</p>
<h2>PARSE Actually Has Another Avenue</h2>
<p>I've become convinced that PARSE probably needs to use the <code>@foo</code> forms to mean "match this literally".  Because the workarounds needed to get that today are too obtuse.</p>
<p>Notice that this won't work:</p>
<pre><code> block: [some "a"]
 parse [1 [some "a"] 3] [integer! block integer!]
</code></pre>
<p>This isn't helped by <code>&gt;-</code> described above.  The problem is a conflict in semantics, not a conflict in keywords.</p>
<p>But imagine if this did the intended thing:</p>
<pre><code> block: [some "a"]
 parse [1 [some "a"] 3] [integer! @block integer!]
</code></pre>
<p>That seems important to me, and it is connected systemically to the "as-is" notion this type is coming to be associated with.</p>
<p><em>While this is different, it would limit the cases you'd need to use <code>&gt;-</code> with to those where you wanted a variable to act as a rule.</em></p>
<h2>How Does This Compare with GET-WORD! for Subvert Keyword?</h2>
<p>I still sort of feel like GET-WORD! makes more sense for PARSE to subvert keywords, and that MARK and SEEK are good enough for setting and getting the parse position (and much clearer).</p>
<pre><code>parse data [any [remove :reject | skip]]
</code></pre>
<p>This sort of lines up with today's usage of GET-GROUP! for "splice this thing here so the parse feed sees it as if it had been written literally here".</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/should-there-be-a-keyword-bypass-keyword/1389">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-there-be-a-keyword-bypass-keyword/1389</link>
          <pubDate>Fri, 06 Nov 2020 19:24:24 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1389</guid>
          <source url="https://forum.rebol.info/t/should-there-be-a-keyword-bypass-keyword/1389.rss">Should There Be A &quot;Keyword Bypass&quot; Keyword?</source>
        </item>
        <item>
          <title>Reclaiming BAR! ... Could It Mean &quot;newline&quot; in PRINT?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>With <a href="https://forum.rebol.info/t/the-language-worlds-weirdest-comma-mechanic/1387">the arrival of COMMA!</a>, the heavier vertical bar goes back to its sole entrenched purpose as an alternate in PARSE rules.</p>
<p>But this makes one wonder what it might be used for.  A long time ago when it was still a separate BAR! datatype, the barrier was tried out as a newline in PRINT.</p>
<pre><code> &gt;&gt; print ["sum one:" 10 + 20 | "sum two:" 3 + 4]
 sum one: 30
 sum two: 7
</code></pre>
<p>The reason this was panned was that separating expressions was a distinct intention.  What if the strings were coming from an expression:</p>
<pre><code> &gt;&gt; sum-label: func [n] [either n = 1 ["one"] ["two"]]

&gt;&gt; print [sum-label 1 10 + 20 | sum-label 2 3 + 4]
sum one: 30
sum two: 7
</code></pre>
<p>It could be interesting to people to separate <code>sum-label 1 | 10 + 20</code> to make the expression boundary clearer.  But if they got a newline in the process, that would not be good.</p>
<p>But now with COMMA!, we can reconsider:</p>
<pre><code>&gt;&gt; print [sum-label 1, 10 + 20 | sum-label 2, 3 + 4]
sum one: 30
sum two: 7
</code></pre>
<p>You have your expression separations, and you have your newline.</p>
<h2>Contentious With Other Definitions of |</h2>
<p>I wouldn't propose accomplishing this by defining | to be the newline character in general.</p>
<p>It would be a keyword in DELIMIT (hence the SPACED that PRINT is based on).</p>
<p>This has the potential for causing confusion for anyone who redefines | and thinks they can use it freely.  We run into questions of how to subvert PRINT's meaning it has chosen and invoke the operator.</p>
<p>But those tools are starting to emerge.  <strong><code>reeval :|</code></strong> can trigger identical behavior to using a function in <strong>|</strong>... now even allowing it to be invisible.  That doesn't cover enfix, but you get that with <strong><code>-&gt;-</code></strong></p>
<blockquote>
<p>Note: I'm wondering now if <strong><code>&gt;-</code></strong> should be a "SHOVE" that doesn't give any argument to the right hand side, while <strong><code>-&gt;-</code></strong> pulls something from the left.  That means you could say <strong><code>&gt;- keyword</code></strong> to get generalized dialect subversion when something like PRINT has taken a keyword.  As long as it doesn't take <strong><code>&gt;-</code></strong>, that is!</p>
</blockquote>
<h2>I Think These Questions Are <em>THE POINT</em>
</h2>
<p>If we don't approach the mechanisms and understandings that allow things like PRINT to work this way, the whole exercise of building this framework is probably wasted work.</p>
<p>We need to know how to make dialect keywords, how to easily write dialects, and have patterns for mixing code that may collide with the dialect's choices.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/reclaiming-bar-could-it-mean-newline-in-print/1388">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/reclaiming-bar-could-it-mean-newline-in-print/1388</link>
          <pubDate>Fri, 06 Nov 2020 18:33:26 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1388</guid>
          <source url="https://forum.rebol.info/t/reclaiming-bar-could-it-mean-newline-in-print/1388.rss">Reclaiming BAR! ... Could It Mean &quot;newline&quot; in PRINT?</source>
        </item>
        <item>
          <title>FUNCTION-MU: Rebmu&#39;s Function Generator Dialect</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>Rebmu is a laboratory for cool dialecting tricks... <em>one of those tricks I imagined was to see just how much mileage we could get for defining functions with a single character primitive that has no holds barred...</em></p>
<h2>F</h2>
<p>The idea is to make F use tricks with quoting and variadics in order to eliminate the need for certain boilerplates.  For example, it can quote its first argument, allowing a WORD! without a block around it to use as a spec for an arity-1 function:</p>
<pre><code>f x [...]  ;  Would act the same as f [x] [...]
</code></pre>
<blockquote>
<p>Bear in mind that in when "mushed" in Rebmu, that would be <strong><code>fX[...]</code></strong> acting as <strong>f x [...]</strong> because the case transition signals when a new token begins.</p>
<p>And a quick reminder of the game for anyone who has forgotten: if a run of transitions starts with a capital letter instead of a lowercase one, the first acts as a SET-WORD!.   So <strong><code>Fx[...]</code></strong> would act as <strong>f: x [...]</strong></p>
</blockquote>
<p>Being able to avoid the brackets of a spec block and quoting a WORD! is trick number one.  But that's old hat, and even lambda uses that.  <strong><code>x -&gt; [...]</code></strong></p>
<p>So let's get crazier.  <img src="https://forum.rebol.info/images/emoji/twitter/crazy_face.png?v=9" title=":crazy_face:" class="emoji" alt=":crazy_face:"></p>
<h2>Automatic Naming Of Multiple Arguments</h2>
<p>The first generation of Rebmu introduced things like B-FUNCTIONS or C-FUNCTIONS.  The concept was that if you asked for such a function, you'd actually get arguments for a series of letters.</p>
<pre><code> fc [...]  ; acts like `f [a b c] [...]`
 fd [...]  ; acts like `f [a b c d] [...]
</code></pre>
<p>This idea for taking letters at the start of the alphabet was complemented by functions that counted letters <em>backwards</em>.  This way when you were declaring functions inside functions, the names would be less likely to collide:</p>
<pre><code> fx [...]  ; acts like `f [z y x] [...]`
 fw [...]  ; acts like `f [z y x w] [...]`
</code></pre>
<p>Sacrificing two letter names starting with F for this is probably too much, so you might imagine this coming from ISSUE! usage:</p>
<pre><code> f #c [...]  ; giving `f [a b c] [...]`
</code></pre>
<p>But at best that would mush as <strong><code>f#c[...]</code></strong>, at which point you're using up two characters.  So if the word-named feature were variadic you'd break even on two characters:</p>
<pre><code> f a b [...]  ; if this meant `f [a b] [...]` you could write as `fAb[...]`
 f m x [...]  ; and you could pick any characters you wanted, `fMx[...]`
</code></pre>
<p>So the idea would only make sense if there was another meaning for things like <code>fMx</code>, which leads us to...</p>
<h2>Removing The Need For Blocks In The Body</h2>
<p>If we look aside from the spec for a moment, we can ask how quoting might be used in the body.  For instance, what if instead of writing:</p>
<pre><code> f [args] [case [...]]
</code></pre>
<p>You could just write:</p>
<pre><code> f [args] case [...]
</code></pre>
<p>That points to an alternate potential meaning for something like <strong>fMx[...]</strong> as <strong>f [m] [x [...]]</strong> instead of <strong>f [m x] [...]</strong>, and is probably a more potent idea.</p>
<p>This behavior when the body isn't a block would essentially flip F into a mode of being a spin on <a href="https://forum.rebol.info/t/looking-into-a-usermode-pointfree/1236">POINTFREE</a>...which would try to consume "one whole expression's worth" of body code based on what it could figure out from the material it variadically quoted.</p>
<p><em>Such a feature assumes that generated bodies are the unusual case you would use GROUP!s to escape.</em>  So while in plain Ren-C it would run the reverse once on function creation and make a function that prints:</p>
<pre><code> func [] reverse ["Hello" print]  ; e.g. `func [] [print "Hello"]`
</code></pre>
<p>We'd see a different effect, making a function that returned a BLOCK!, calling reverse each time:</p>
<pre><code> f [] reverse ["Hello" print]  ; e.g. `func [] [reverse ["Hello" print]]`
</code></pre>
<p>You'd thus need some kind of escaping mechanism like a GROUP! to get the "use code to generate a body" behavior:</p>
<pre><code> f [] (reverse ["Hello" print])
</code></pre>
<p><strong>I think it probably makes sense to have the generator that gets the single letter <em>NOT</em> be tailored to generating body blocks from code.</strong>  The F would not be an alias for FUNCTION (obviously) but for FUNCTION-MU.  So FN would be just one letter away for anyone who wanted the more conventional version.</p>
<h2>The LET and Auto-Gathering Distinction for Locals</h2>
<p>When you make an assignment to a SET-WORD! inside the body of a function to something that isn't a parameter, how is this interpreted?  How do you designate a local variable vs. reaching outside into the enclosing binding environment?</p>
<p><a href="https://forum.rebol.info/t/in-the-interest-of-shipping-something-rebol2-style-local-s-only/1309">We still don't have answers to this in the language proper.</a>  Which is frustrating.  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=9" title=":frowning:" class="emoji" alt=":frowning:"></p>
<p>But if there's anywhere that auto-gathering of SET-WORD!s as locals is useful as a feature, it's in Rebmu.  So:</p>
<ul>
<li>Is it the default behavior for <strong>F</strong>?</li>
<li>How do you turn it on or off?</li>
</ul>
<blockquote>
<p>I'll point out here that how characters are counted in code golf varies...but if all of unicode is allowed where unicode characters "cost" the same as ASCII, there are choices like dotted-F (<strong>ḟ</strong>) on the table.  Some golfing languages go crazy with this.  But as a general baseline, I think ASCII should be used and then have Unicode definitions as an extension.)</p>
</blockquote>
<p>For now, I think the default should be to assume arguments are not local.  It may be that defining locals is done with a separator like BAR!:</p>
<pre><code> f[aB|cDe][...]  ; acts as `f [a b &lt;local&gt; c d e] [...]`
</code></pre>
<h2>[Your Brainstorm Here]</h2>
<p>Feel free to throw out ideas for any combination.</p>
<p>For instance, what if the body of a function is a text:</p>
<pre><code> foo: f [] "Some String"
</code></pre>
<p>It doesn't make a lot of sense for that to mean "evaluate to the string", because you could have just assigned the string to the variable directly:</p>
<pre><code> foo: "Some String"  ; shorter for same effect
</code></pre>
<p>This would suggest that maybe the body being a string means it should print that string.  But if that's all it does, then why would it need a spec?  So if F gets a string in the spec position it could consider that the end of the variadic definition, and make a function that prints that string.</p>
<pre><code> &gt;&gt; h: f "Hello World"

 &gt;&gt; h
 Hello World
</code></pre>
<p>ISSUE! can print strings without spaces with one less delimiter, so there's that.  But I kind of liked my idea above about auto-generating multiple parameter names.  Then again, there's FILE! for an alternative: <strong>f %c [...]</strong></p>
<p>So what if the spec is a TUPLE!, or a PATH!, or if the body is a SET-GROUP!??  What kinds of practical shortcuts can these take to get the maximum leverage out of <strong>F</strong>?  Maybe if an INTEGER! is in the body position it assumes that means to loop that many times.</p>
<pre><code> &gt;&gt; x: f y 3 [p y]   ; let's say P is PRINT
 &gt;&gt; x "test"
 test
 test
 test
</code></pre>
<p>The concept of "pulling out the block" mentioned above could even cascade there, letting you write <strong>x: f y 3 p y</strong> which can mush as <strong>XfY 3 pY</strong></p>
<p>There's a lot to explore here, and <a class="mention" href="/u/razetime">@razetime</a> please let me know if this is making any sense or not....I've started on bringing Rebmu back to life and hopefully will have it in usable shape this week.</p>
            <p><small>5 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/function-mu-rebmus-function-generator-dialect/1379">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/function-mu-rebmus-function-generator-dialect/1379</link>
          <pubDate>Sun, 01 Nov 2020 13:56:24 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1379</guid>
          <source url="https://forum.rebol.info/t/function-mu-rebmus-function-generator-dialect/1379.rss">FUNCTION-MU: Rebmu&#39;s Function Generator Dialect</source>
        </item>
        <item>
          <title>Reviving the Rebmu Dialect</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>Rebmu was conceived as something of a puzzle, but not entirely a joke.  My futurist mindset is that code golf will be a growing recreational domain with time...played by humans and AI alike.  And <strong>I've identified code golf as one of the key target domains for the Ren-C project, in its <a href="https://forum.rebol.info/t/mission-statement/667/22">"Minecraft of Programming"</a> objectives.</strong></p>
<p>My intuition is that a truly <em>good</em> code golf language would wind up being useful in other ways; as some sort of compressed bytecode platform.</p>
<p>But I wouldn't be all that bothered if it didn't have great utility...and it was just truly <em>fun</em>, generating a corpus of work comparable to the circuitry that people have been putting together on the <a href="https://www.conwaylife.com/wiki/Main_Page">Game of Life Wiki</a>.</p>
<div class="onebox lazyYT lazyYT-container" data-youtube-id="iDKaz1iB9wQ" data-youtube-title="Rebmu Language Overview (@ Recode 2013)" data-parameters="feature=oembed&amp;wmode=opaque">
  <a href="https://www.youtube.com/watch?v=iDKaz1iB9wQ" target="_blank" rel="noopener">
    <img class="ytp-thumbnail-image" src="https://i.ytimg.com/vi/iDKaz1iB9wQ/maxresdefault.jpg" title="Rebmu Language Overview (@ Recode 2013)" width="480" height="360">
  </a>
</div>

<h2>Rebmu Needs To Be Brought Up To Date</h2>
<p>I haven't run any of the samples in quite a long time.  So they're in a broken state.  I've said that if Rebmu and its puzzles were added as Travis CI tests, they would probably provide particularly good checks of pathological codebases.  (As much of a headache as it is to debug such things, it's worth it in the end.)</p>
<ul>
<li>
<p>I'm looking forward to taking better advantage of the <a href="https://github.com/metaeducation/ren-c/tree/master/src/core/functionals">function deriving mechanisms</a> to make the definition of Rebmu itself easier.  <strong>apd: :append/dup</strong> to specialize append is a lot easier than what had to happen before.</p>
</li>
<li>
<p>Need to take advantage of <a href="https://forum.rebol.info/t/issuechar-token-is-hitting-it-out-of-the-park/1364"><strong>ISSUE! replacing CHAR!</strong></a>...not only do character literals shorten from <strong>#"a"</strong> to <strong><span class="hashtag">#a</span></strong> for those not needing delimiters, but the non-spacing character of <strong><span class="hashtag">#abc</span></strong> in print gives a way to tighten up formatted output.</p>
</li>
<li>
<p>The landscape of names needs a rethink, as things like E could mean ELSE now, which is generic and powerful.</p>
</li>
<li>
<p>Mushing has to be rethought for new constructs like predicates, as things like <strong>until .not [...]</strong> will be very useful.</p>
</li>
<li>
<p>IO always presented a problem, simply because we didn't know how functions like PRINT should <em>actually</em> work.  (I've lamented that we're still trying to figure out how to write "Hello World").  These things are better understood now, and we're a tiny bit farther on things like the <a href="https://forum.rebol.info/t/improving-the-ask-dialect-and-replacing-input/1124">ASK dialect</a></p>
</li>
</ul>
<p>What has historically happened when I've gone and tried to poke at Rebmu is that it just draws my attention to some issue or feature in the interpreter, so I wander off and lose momentum.  But it's probably time to bite the bullet and get it knocked into enough shape...and then add puzzles to it on Travis gradually.</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/reviving-the-rebmu-dialect/1377">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/reviving-the-rebmu-dialect/1377</link>
          <pubDate>Sat, 31 Oct 2020 06:06:18 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1377</guid>
          <source url="https://forum.rebol.info/t/reviving-the-rebmu-dialect/1377.rss">Reviving the Rebmu Dialect</source>
        </item>
        <item>
          <title>Plain GROUP! &amp; Branching: Only Run If Branch Taken?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>Something that came up early on was the question of parity in how CASE dealt with GROUP! branches and how IF dealt with GROUP! branches.</p>
<p>Because IF evaluated its arguments, the GROUP! would always run...even if the condition ruled out the BLOCK! that was evaluated to running:</p>
<pre><code> rebol2&gt;&gt; if true (print "in group" [print "in block"])
 in group
 in block

 rebol2&gt;&gt; if false (print "in group" [print "in block"])
 in group  ; ...still printed...just no "in block"
</code></pre>
<p>But with CASE, the branches lived inside a block passed in...making them effectively quoted.  Which meant not only <em>could</em> they be skipped, but they <em>were</em> skipped:</p>
<pre><code>rebol2&gt;&gt; case [true (print "in group" [print "in block"])]
in group
in block

rebol2&gt;&gt; case [false (print "in group" [print "in block"])]
== none  ; didn't say "in group" this time
</code></pre>
<p>Sensing something was amiss, Ren-C brought these two situations into sync...but biased to the IF behavior.  When a CASE saw a GROUP! in a branch slot it would run it, just as an IF would...regardless of whether that branch would run.</p>
<pre><code>ren-c&gt;&gt; case [false (print "in group" [print "in block"])]
in group
; null
</code></pre>
<p>It wasn't really a question of which was the more -useful- behavior.  <em>Choosing it this way was because it was perceived as the only option.</em>  There was no way to stop the GROUP!s from running in IF, so long as the branches were evaluative, this was the only way to get parity...</p>
<h2>Suppressing Evaluation Considered for @(gr o up)</h2>
<p>When trying to figure out what it was that @(...) did, one potential feature was to remedy this unwanted execution.  It would be like (...) but only run if the branch executed.</p>
<pre><code> &gt;&gt; branchy: func [flag] [either flag '[&lt;a&gt;] '[&lt;b&gt;]]

 &gt;&gt; either true (print "a" branchy true) (print "b" branchy false)
 a
 b
 == &lt;a&gt;

&gt;&gt; either true @(print "a" branchy true) @(print "b" branchy false)
a
== &lt;a&gt;
</code></pre>
<p>Useful.  But then @(...) became desired for other purposes...namely to request the result of the branch <em>as-is</em>.  e.g. no voidification.</p>
<h2>Should Plain GROUP!s Only Run If The Branch Is Taken?</h2>
<p>What if the branching constructs quoted the GROUP!s too, and ran them to generate branches only if the condition matched?</p>
<pre><code> &gt;&gt; branchy: func [flag] [either flag '[&lt;a&gt;] '[&lt;b&gt;]]

 &gt;&gt; either true (print "a" branchy true) (print "b" branchy false)
 a
 == &lt;a&gt;

&gt;&gt; case [false (print "in group" [print "in block"])]
; null
</code></pre>
<p>I imagine if you conducted a poll, you'd find a fair number of people who'd say they'd prefer that behavior...and would prefer this to using @(...) to get it.</p>
<p>Other people might say it rocks the boat to have a GROUP! at a callsite that doesn't execute unconditionally.  But branch slots are already rocking the boat...they're not evaluative, so they can see quotes:</p>
<pre><code> &gt;&gt; if true '&lt;foo&gt;
 == &lt;foo&gt;
</code></pre>
<p><em>(You can read all about it with <a href="https://forum.rebol.info/t/soft-quoted-branching-light-elegant-fast/1020">Soft-Quoted Branching</a>...if you've forgotten)</em></p>
<h2>What Would This Inhibit?</h2>
<p>For most cases, not running the group unless the branch runs is better.  Even if your branch-making code has no side-effects, it's better for performance not to run it unless you have to.  Lambdas are a good example...if you wanted to say <strong>switch x [...] then (x -&gt; [...])</strong> you could avoid an entire function generation just by having it in a GROUP! like this.</p>
<p>But if you imagine something like a "branch generator" that generates branches in a certain order, and you wanted to position them using that order...you'd need to use a COMPOSE:</p>
<pre><code> do compose [either (branch-gen) (branch-gen)]
</code></pre>
<p>I don't think that's too much of a tax to pay for that intent.  It looks fine and conveys exactly what it is...clearly running both branch generations for the COMPOSE step prior to the EITHER.</p>
<p>What I'm more hesitant about is that hard-quoting behavior for branches to not run GROUP!s at the callsites is a fairly early curveball.</p>
<p>But maybe it's just an example of the language being fluid.</p>
<h2>Drat!  A Mechanical Foil</h2>
<p><em>(I'm not sure if the practice of writing out the reasoning before trying experiments is a good one, because I usually find some issue pretty quickly when I try them...but...)</em></p>
<p>So the feature of <a href="https://forum.rebol.info/t/the-most-vexing-evaluation-lambda-meets-then-else/1361">Lambdas for Branches</a> relies on something that is tied to non-hard-quoting semantics.</p>
<p>Rightly or wrongly... the decision was that in an "escapable" quoting slot (e.g. one that would accept a GROUP! and evaluate code)...that escapable slot was also willing to accept something produced by a left-quoting construct on the right hand side.</p>
<p>I'm not too keen on coming up with another parameter convention that is "hard quoted unless a lambda decides it wants to evaluate and put something there".  So that sort of kills this idea...so long as it's plain GROUP! that is considered to be what defeats quoting.</p>
<p><strong>But there are still avenues of attack...</strong></p>
<p>One might be that GET-GROUP! is the "sneaky quoting defeater" instead of plain GROUP!.  When you think about it, if <strong>X</strong> and <strong>X/Y</strong> are quoted by soft quotes but <strong>:X</strong> and <strong>:X/Y</strong> aren't... why wouldn't it be <strong>:(FOO BAR)</strong> instead of <strong>(FOO BAR)</strong> to undermine a quoting site...with ordinary GROUP!s quoted normally?</p>
<p>So like this:</p>
<pre><code>&gt;&gt; either true (print "a" [&lt;a&gt;]) (print "b" [&lt;b&gt;])
a
== &lt;a&gt;

&gt;&gt; either true :(print "a" [&lt;a&gt;]) :(print "b" [&lt;b&gt;])
a
b
== &lt;a&gt;
</code></pre>
<p>To me, that feels more natural...that the colon is asking for subversion of the quote.</p>
<p>Interestingly, you could mix and match...here, seen getting it out of order:</p>
<pre><code>&gt;&gt; either true (print "a" [&lt;a&gt;]) :(print "b" [&lt;b&gt;])
b
a
== &lt;a&gt;
</code></pre>
<p>If it were done this way, then it suggests that GROUP! is acceptable as a parameter from direct quoting...but what if you got a GROUP! produced by the subverted quoting?</p>
<pre><code>&gt;&gt; if true :(print "a" '(print "b" [&lt;c&gt;]))
a
b
== &lt;c&gt;
</code></pre>
<p>That's just what would naturally happen.  Seems all right to me, but it's not clear how you would stop it if you wanted to (as in today's situation, you wouldn't know as the recipient of an escaped quote if what you got was generated by an escape or not.)  So if this bothered you, you couldn't use escaping and would have to hard quote it.</p>
<p><a href="https://forum.rebol.info/t/get-word-for-loop-vars-function-args-mean-allow-action-s/1303/2"><strong>This idea feels rather appealing, but it suggests a different semiotics for arguments.</strong>  e.g. an escapable quoted parameter would be <strong>:x</strong> or <strong><code>':x</code></strong>... not <strong><code>'(x)</code></strong></a></p>
<p>Anyway, what this really does is raise some questions about how people feel about the quoting of groups and branching.</p>
<p>I am finding myself leaning pretty heavily on the side of saying that it is most convenient if a plain GROUP! in a branch slot does not run its branch generation behavior unless the branch is taken.<br>
Which is a bit of a shift for me...as I'd favored "normal" evaluation semantics more often.  But it's just seeming that practically speaking it's cleaner to leverage the quoting.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/plain-group-branching-only-run-if-branch-taken/1373">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/plain-group-branching-only-run-if-branch-taken/1373</link>
          <pubDate>Mon, 26 Oct 2020 07:15:00 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1373</guid>
          <source url="https://forum.rebol.info/t/plain-group-branching-only-run-if-branch-taken/1373.rss">Plain GROUP! &amp; Branching: Only Run If Branch Taken?</source>
        </item>
        <item>
          <title>Can MAKE FILE! Dialect Solve the Madness</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>With Generic Tuple, the dawn of NewPath is upon us.</p>
<pre><code>&gt;&gt; filelike-path: 'base/{sub dir}/name.ext
== base/{sub dir}/name.ext   ; path!

&gt;&gt; first filelike-path
== base  ; word!

&gt;&gt; second filelike-path
== "sub dir"  ; text!

&gt;&gt; third filelike-path
== name.ext  ; tuple!

&gt;&gt; last third filelike-path
== ext  ; word!
</code></pre>
<p>At some point you'll need transformations that get you actual FILE! strings out of PATH!s you were using as a convenient structural substitute.  I'm trying to think about good sanity-checking features that will pay dividends, like this one:</p>
<pre><code>&gt;&gt; extension: "txt"

&gt;&gt; file: make file! 'base/{sub dir}/name.(extension)
== %"base/sub dir/name.txt"

&gt;&gt; extension: "not/legal"

&gt;&gt; file: make file! 'base/{sub dir}/name.(extension)
 ** Error: Can't use slash in filename sub-component "not/legal"
</code></pre>
<p><strong>With this new direction, I want to kill off the old behavior of FILE!s that get path-picked IMPLICITLY doing appending of path segments to file names.</strong>  That means no more of this:</p>
<pre><code>&gt;&gt; src-dir: %foo/bar

&gt;&gt; src-dir/main
== %foo/bar/main
</code></pre>
<h2>A Compelling Example Of Why Implicit FILE! Pathing Must Die</h2>
<p>Here is a bit of code I'd like you to look at, <a href="https://github.com/metaeducation/ren-c/blob/37cd566d3ab4729faae710e82741c0183a97e269/make.r#L1278">from rebmake.r</a>:</p>
<pre><code>depends: reduce [
    either user-config/main
    [gen-obj/main user-config/main]
    [gen-obj/dir file-base/main src-dir/main]
]
</code></pre>
<p>I thought this was attempting to generate a BLOCK! of FILE!s.  My attention was drawn to <code>src-dir/main</code>, which I figured was using the "evil" implicit pathing feature.</p>
<p>This made me imagine the others were doing that too.  So the first case would make a block of two files, and the second a block of three.</p>
<p><strong>Looking closer, nope</strong>.  GEN-OBJ is a function which takes a varying number of directories as arguments, depending on whether it has refinements.  So these are two potential calls to that function which generate only one result.  <code>user-config</code> and <code>file-base</code> are OBJECT!s from which an element is being picked, while only src-dir is a FILE!.  /DIR and /MAIN are refinements to GEN-OBJ, where /DIR takes a FILE! argument.</p>
<p><em>How can anybody expect to be able to read this?</em></p>
<h2>Let's Try And Make Sense of It</h2>
<p>First, let's kill off the implicit pathing, and use MAKE FILE!</p>
<pre><code>depends: reduce [
    either user-config/main
        [gen-obj/main user-config/main]
        [gen-obj/dir file-base/main make file! '(src-dir)/main/]
]
</code></pre>
<p>It's...slightly better.  Now let's go with the idea of inert-based picking of members with dots, to make it more obvious where the function calls are:</p>
<pre><code>depends: reduce [
    either user-config.main
        [gen-obj/main user-config.main]
        [gen-obj/dir file-base.main make file! '(src-dir)/main/]
]
</code></pre>
<p>Now we can discern that /MAIN is (probably) a <em>refinement</em> to GEN-OBJ, while MAIN is a <em>field</em> in both user-config and file-base.</p>
<p>Breaking this apart and adding some comments might help (despite the fact some people seem allergic to writing comments).  :-/</p>
<pre><code> main-obj-spec: either user-config.main [
     ;
     ; Config specified a main .c filename, tell GEN-OBJ via /MAIN
     ; to put it in a derived location relative to that filename's path.
     ;
     gen-obj/main user-config.main
 ][
     ; If there's no explicit config main override, then use the main file
     ; from %file-base.r.  Assume its /DIR location is in the %/main/
     ; subdirectory of wherever the rest of the source code is.
     ;
     main-c-file-dir: make file! '(src-dir)/main/
     gen-obj/dir file-base.main main-c-file-dir
 ]

 depends: reduce [ensure object! main-obj-spec]
</code></pre>
<p>It actually turns out that it's not returning an obj FILE!, but a Rebmake OBJ file descriptor object.  I really think ENSURE helps in cases like this.</p>
<h2>Really This Was About MAKE FILE!...</h2>
<p><a class="mention" href="/u/giuliolunati">@giuliolunati</a> will back me up when I say Rebmake is a beast.  But makefile systems always are.  The good news is that since it's written in Ren-C, there's weapons for attacking it... so we can see just how much dialecting can be brought to bear upon it.  It needs rethinking from the most basic premises, but that will take time.</p>
<p>In any case, I just wanted to show some arguments for why no one should mourn the loss of implicit pathing for filenames.  It's cool to be able to pun on PATH! to make file paths--it's made for that.  But when that is tied in implicitly to evaluation we see what kind of a mess it makes.</p>
<p>This also gives a pretty good argument for why the dotted access pattern helps you see what's going on, by knowing they're not refinements.</p>
<h2>Please Help with MAKE FILE!  (!!!)</h2>
<p>Ideas and testing are going to be important.  I'll commit the source to the beginnings soon.</p>
            <p><small>5 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/can-make-file-dialect-solve-the-madness/1356">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/can-make-file-dialect-solve-the-madness/1356</link>
          <pubDate>Sun, 04 Oct 2020 16:49:11 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1356</guid>
          <source url="https://forum.rebol.info/t/can-make-file-dialect-solve-the-madness/1356.rss">Can MAKE FILE! Dialect Solve the Madness</source>
        </item>
        <item>
          <title>Treat BLANK!s from Variables or Evaluation Like NULL</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>BLANK! has a very tempting nature to make you want to use it to <em>mean something</em>.  For instance, I've consistently wanted it to mean <code>space</code> in DELIMIT's "dialect" :</p>
<pre><code>write port unspaced [
    "HTTP/1.0" _ code _ code-map/:code CR LF
    "Content-type:" _ type CR LF
    "Content-length:" _ (length of body) CR LF
    CR LF
]
</code></pre>
<p><strong>That is awesome.</strong>  It lets you see what's going on very clearly.  I'm always annoyed when people include spacing in the edges of the things being spaced, like <code>"HTTP/1.0 "</code> ... because it makes it harder to factor.  It also makes it hard to see what's a string and what's not:</p>
<pre><code> print [" At a " glance " how " do " you tell " whats " a string "]
</code></pre>
<p><strong>But as awesome as BLANK!-spacing is, it has a downside.</strong>  It sucks if a variable holds BLANK! with the intent to mean <em>nothing</em> if that <em>nothing</em> becomes a space character.</p>
<p>As a simple example to demonstrate, let's say you've got a situation like this where the second item is supposed to be "not there":</p>
<pre><code>values: ["one" _ &lt;three&gt;]

print "And here the values are!"
for-each item values [
    print [item]
]
</code></pre>
<p>Clever mechanics in PRINT and SPACED won't print lines that fully vaporize.  So if that values/2 were an actual NULL, you'd get just the two lines printing...with no newline between them.</p>
<p>But BLANK! acts as a space.  So instead, you get something that's actually worse than it looks:</p>
<pre><code>And here the values are!
one

&lt;three&gt;
</code></pre>
<p>I say it's worse because that empty line isn't actually empty.  <em>It actually wrote a space and a newline.</em></p>
<p>You physically cannot put NULLs in BLOCK!s.  And branches have become more involved with turning NULLs into voids to signal when a branch ran (some creative tools to deal with that coming soon).  So it becomes a juggling act to switch back and forth between null and blank when you might consider it easier for your purposes to stick with blank for some things.</p>
<h2>Why Not Try Differentiating Evaluated BLANK! vs. Literal?</h2>
<pre><code>&gt;&gt; print ["a" _ "b"]
a b

&gt;&gt; var: _
&gt;&gt; print ["a" var "b"]
ab
</code></pre>
<p>Well... <em>OF COURSE that was tried.</em>  Multiple forms of PRINT and DELIMIT over time have experimented with subtly different rules to try and find a sweet spot.</p>
<p>But you should be careful in dialects where replacing a literal with a variable gives a different effect.  In particular, this was noticed with BLOCK!s...where the behavior felt very unpredictable when an in-place block did something different from one accessed through a variable:</p>
<pre><code>&gt;&gt; print [["doesn't" "space"] "does" "space"]
doesn'tspace does space

&gt;&gt; block: ["doesn't" "space"]
&gt;&gt; print [block "does" "space"]
doesn't space does space
</code></pre>
<p>Some historical examples in this vein were tried and discarded.  It seemed to run against the idea of being able to abstract what you were writing.</p>
<p>You can think of other examples like this.  What if PARSE decided that an in-place integer meant a count, but one through a word! matched the number?</p>
<pre><code>&gt;&gt; did parse "aa" [2 "a"]
== #[true]

&gt;&gt; count: 2
&gt;&gt; did parse "aa" [count "a"]
== #[false]

&gt;&gt; did parse [2] [count]
== #[true]
</code></pre>
<p>It doesn't do "double execution" of WORD!s that contain WORD!s.  But static data is substituted as-is, including BLOCK!.  So what is BLANK! more like...?</p>
<h2>I Think BLANK! is Special, and We Have QUOTED! Tools Now</h2>
<p>The subject of this post sums up how I think the competing demands on BLANK! should be resolved:</p>
<p><strong>You should treat BLANK! the same way you would treat a NULL if you fetch it from a variable or an evaluation.  But if it's at "source-level" you can give it another meaning, to take advantage of its unique visual properties.  If it has no meaning at source level, a literal BLANK! should raise an error.</strong></p>
<p><em>(Here I'm going so far as to say that you nearly <em>shouldn't</em> let a source-level blank mean the same thing as a fetched null in your dialect.   Maybe that's not necessarily a good rule...but there's something giving me an inkling that it might be.)</em></p>
<p>You might point out that the definition of "source-level" is slippery, as people can be COMPOSE-ing code together.  But when you compose, you'll have issues with WORD! as well:</p>
<pre><code>&gt;&gt; foo: void
&gt;&gt; var: 'foo
&gt;&gt; print ["a" var "b]
a foo b

&gt;&gt; print compose ["a" (var) "b"]
** Script Error: foo is VOID! (Note: use GET/ANY to GET voids)
</code></pre>
<p>But the same quoting tool that can help with this can help with BLANK!, because quoted blanks are evaluated (all the evaluation does is drop the quote, but it's still evaluation)</p>
<pre><code>&gt;&gt; foo: void
&gt;&gt; var: 'foo
&gt;&gt; print compose ["a" '(var) "b"]
a foo b

&gt;&gt; print ["a" _ "b"]
a b

&gt;&gt; print ["a" '_ "b"]
ab

&gt;&gt; var: _
&gt;&gt; print ["a" '(var) "b"]
ab
</code></pre>
<h2>This Feels Like Solid Guidance</h2>
<p>I think this is pretty much as good as it gets.  Like I say, it pays to be cautious when making substitutions of values behave differently than if they appeared literally...but this seems to work.</p>
<p>It does have some kind of strange implications for PARSE and BLANK!.  We know that QUOTED! means match directly:</p>
<pre><code>&gt;&gt; did parse [1 _ 'x] ['1 '_ ''x]
== #[true]
</code></pre>
<p>And if you fetch out of a variable you're supposed to treat it as if it's not there:</p>
<pre><code>&gt;&gt; rule: _
&gt;&gt; did parse "abcd" ["ab" rule "cd"]
== #[true]
</code></pre>
<p>So would it be acceptable to let the literal form mean "skip"?</p>
<pre><code>&gt;&gt; did parse [1 &lt;foo&gt; "hi"] [integer! _ text!]
== #[true]
</code></pre>
<p>I think that's within the rules, and can be a design choice.  The key is just that when it comes from a variable, it has to act the same as null.  What you do in your dialect with quoted forms that are literal is as much up to you as what you do with the plain forms.</p>
<p>Hopefully this resolves a couple of years-old questions:</p>
<pre><code>&gt;&gt; rule: _
== _

&gt;&gt; parse [a b _ _ _] ['a 'b 3 rule]
== [_ _ _]  ; residual

&gt;&gt; rule: quote _
== '_

&gt;&gt; parse [a b _ _ _] ['a 'b 3 rule]
== []  ; all parsed
</code></pre>
<p>What's nice is that QUOTE gives you a generic way to turn a value you want to match into a value you know will work in the parse.  Without generic quoting you wouldn't have it!  It's a little bit easier to look at than:</p>
<pre><code>&gt;&gt; rule: ''_
== '_</code></pre>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/treat-blank-s-from-variables-or-evaluation-like-null/1348">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/treat-blank-s-from-variables-or-evaluation-like-null/1348</link>
          <pubDate>Sun, 27 Sep 2020 05:47:05 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1348</guid>
          <source url="https://forum.rebol.info/t/treat-blank-s-from-variables-or-evaluation-like-null/1348.rss">Treat BLANK!s from Variables or Evaluation Like NULL</source>
        </item>
  </channel>
</rss>
