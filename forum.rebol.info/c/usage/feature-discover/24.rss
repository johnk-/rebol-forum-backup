<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Feature Discover - AltRebol</title>
    <link>https://forum.rebol.info/c/usage/feature-discover/24</link>
    <description>Topics in the &#39;Feature Discover&#39; category Rebol and Red have quite a few cool features - this is PR for them.</description>
    
      <lastBuildDate>Sun, 19 Sep 2021 17:05:11 +0000</lastBuildDate>
      <atom:link href="https://forum.rebol.info/c/usage/feature-discover/24.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>There Came an ECHO</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>I just fixed a bug in Sea of Words...which hopefully means it's a little more trustworthy.</p>
<p>It seemed like a good time to add the ECHO feature I've talked about.</p>
<pre><code>&gt;&gt; echo It's this feature, which I've described in the past.
It's this feature, which I've described in the past.
</code></pre>
<p>ECHO is a variadic function which processes what you pass it to the end of line.  If you prefer, you can also use a BLOCK!.</p>
<pre><code>&gt;&gt; echo [A block allows
    you to put an arbitrary number
    of newlines]
A block allows you to put an arbitrary number of newlines

&gt;&gt; echo [Or two echos] echo [on the same line]
Or two echos
on the same line
</code></pre>
<p>There is a variable substitution mechanism so you can use @ to point out variables or expressions.</p>
<pre><code>&gt;&gt; x: 10
&gt;&gt; echo The value is @x
The value is 10

&gt;&gt; echo The doubled value is @(x * 2)
The doubled value is 20
</code></pre>
<h2>It's Shorter!</h2>
<p>Can't argue against that.</p>
<pre><code>print ["You have written" num-lines "lines of code."]

echo [You have written @num-lines lines of code.]

echo You have written @num-lines of code.
</code></pre>
<h2>The API Benefits</h2>
<p>Not needing quotes helps API calls:</p>
<pre><code>rebElide("print [{You have written}", num_lines, "{lines of code.}]");

rebElide("echo [You have written", num_lines, "lines of code.]");

rebElide("echo You have written", num_lines, "lines of code.");
</code></pre>
<p>It's the kind of change that opens up the choose-your-own-adventure of syntax to let you build a system more like bash, or less like bash.  It's an important decoupling of the use of words from the creation of variables.  So, onward.</p>
            <p><small>8 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/there-came-an-echo/1722">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/there-came-an-echo/1722</link>
          <pubDate>Sun, 19 Sep 2021 17:05:11 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1722</guid>
          <source url="https://forum.rebol.info/t/there-came-an-echo/1722.rss">There Came an ECHO</source>
        </item>
        <item>
          <title>Circling Multi-Returns: Choose Which Is Expression Result</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>I'm still evaluating how well the idea behind multiple-returns works...but by and large, they seem to be working pretty well.</p>
<p>So I've gone ahead and moved them from the "usermode prototype" to natively implementing them as part of the evaluator, which speeds them up by a factor of... a lot.</p>
<p>While doing so, I added a new feature of being able to "circle" which result will be the value of the overall expression.  Previously this was always the "main" return value, but now you can pick another via a SYM-WORD!.</p>
<p>Here's a function with a secondary return value to demonstrate with:</p>
<pre><code>multi: func [
    return: "Main return value"
        [integer!]
    secondary: "Secondary return value"
        [integer!]
][
    if secondary [  ; NULL if not asked for via multi-return (or refinement)
        set secondary 20  ; reminder: `set # ...` is a no-op
    ]
    return 10
]
</code></pre>
<p>Traditionally you could ask for both results, and the overall result would be the first return:</p>
<pre><code>&gt;&gt; [a b]: multi
== 10  ; defaults to same value as first result, e.g. a

&gt;&gt; a
== 10

&gt;&gt; b
== 20
</code></pre>
<p>But now you can use a SYM-WORD! instead to ask for a different result, e.g. the second:</p>
<pre><code>&gt;&gt; [a @b]: multi
== 20  ; same value as b

&gt;&gt; a
== 10

&gt;&gt; b
== 20
</code></pre>
<p>You can combine this with things like GROUP!s to calculate the variable name, or even omit the variable name and use <code>#</code>:</p>
<pre><code>&gt;&gt; [a @(#)]: multi
== 20  

&gt;&gt; a
== 10
</code></pre>
<p>There are some places where this comes in handy, although you generally want to pick the main return to be the thing people are most interested in responding to (e.g. determining success or failure of an operation).</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/circling-multi-returns-choose-which-is-expression-result/1587">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/circling-multi-returns-choose-which-is-expression-result/1587</link>
          <pubDate>Sat, 17 Apr 2021 06:06:59 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1587</guid>
          <source url="https://forum.rebol.info/t/circling-multi-returns-choose-which-is-expression-result/1587.rss">Circling Multi-Returns: Choose Which Is Expression Result</source>
        </item>
        <item>
          <title>Case Study of Case Behavior: The AN Function</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>In thinking about weird applications of case, I was reminded of the little trick of the AN function:</p>
<pre><code>&gt;&gt; an "integer"
== "an integer"

&gt;&gt; an "text"
== "a text"
</code></pre>
<p>It simply checks the letters of the start of the rendering of what comes after it, and resolves to either "a" or "an".  I came up with it during the automatic generation of help strings for typecheckers, something along the lines of:</p>
<pre><code>for-each type data-types [
    help-string: spaced ["Checks to see if value is" an mold type]
    ...
]
</code></pre>
<p>But what if the A or An is at the start of a sentence?  Wouldn't the case of the operator matter?</p>
<pre><code>&gt;&gt; An "integer"
== "An integer"
</code></pre>
<p>Or how about all-caps?</p>
<pre><code>&gt;&gt; AN "INTEGER"
== "AN INTEGER"
</code></pre>
<p>In a case-insensitive world, all of these calls are to the same function.  So what it had to do was consult the stack to see what the label was it was invoked with, and go by the case of that.</p>
<p>But in a case-sensitive world, these would be three different functions (most likely, specializations of a core <code>AN*</code> that took what casing you wanted).</p>
<p>I'm not sure where this fits in the <a class="mention" href="/u/mark-hi">@Mark-hi</a> taxonomy of rightness or wrongness.  But it does point to an axis of flexibility where someone can use stack reflection to force case-sensitive behavior in a case-insensitive system.</p>
            <p><small>4 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/case-study-of-case-behavior-the-an-function/1469">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/case-study-of-case-behavior-the-an-function/1469</link>
          <pubDate>Mon, 18 Jan 2021 21:37:34 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1469</guid>
          <source url="https://forum.rebol.info/t/case-study-of-case-behavior-the-an-function/1469.rss">Case Study of Case Behavior: The AN Function</source>
        </item>
        <item>
          <title>Can Functions You ➤ Now REORDER</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>As things have slowly nudged along in the function composition space, I've kept a generic reordering facility in mind.</p>
<p>And today... less than a week into 2021... we have a first version of it, tentatively named REORDER.</p>
<pre><code>&gt;&gt; append-value-first: reorder :append [value series]

&gt;&gt; append-value-first &lt;item&gt; [a b c]
== [a b c &lt;item&gt;]
</code></pre>
<p>As with other function derivations, there's a lot of benefit over writing <strong>func [value series] [append series value]</strong> !</p>
<p>First of all, it's nearly as fast as the original function. It adds a little overhead to do the rearrangement, but it places values in the same underlying frame slots...and introduces no new frame of its own.</p>
<p>You keep the HELP, parameter names, and descriptions...as well as keep the refinements:</p>
<pre><code>&gt;&gt; append-value-first/dup &lt;item&gt; [a b c] 3
== [a b c &lt;item&gt; &lt;item&gt; &lt;item&gt;]
</code></pre>
<h2>Usage Notes</h2>
<p><em>You need to provide all the required arguments</em>.  It won't guess where you want parameters to go.</p>
<pre><code>&gt;&gt; reorder :append [value]
** Script Error: append is missing its series argument
</code></pre>
<p>However... <strong>you can position optional arguments in the ordering if you like!</strong></p>
<pre><code>&gt;&gt; append-val-dup-ser: reorder :append [value dup series]

&gt;&gt; append-val-dup-ser &lt;item&gt; 3 [a b c]
== [a b c &lt;item&gt; &lt;item&gt; &lt;item&gt;]
</code></pre>
<p>As usual, I will plead for the submission of more tests:</p>
<p><strong><a href="https://github.com/metaeducation/ren-c/blob/master/tests/functions/reorder.test.reb">%tests/functions/reorder.test.reb</a></strong></p>
<p>I point out that this is based on a more foundational ability, to specify non-refinement arguments in paths...which pushes them to the end of the pending arguments:</p>
<pre><code>&gt;&gt; append/series &lt;item&gt; [a b c]
== [a b c &lt;item&gt;]
</code></pre>
<p>REORDER gives you a more intuitive interface to it, but you can also do it that way if you feel like it!</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/can-functions-you-now-reorder/1458">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/can-functions-you-now-reorder/1458</link>
          <pubDate>Wed, 06 Jan 2021 02:46:42 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1458</guid>
          <source url="https://forum.rebol.info/t/can-functions-you-now-reorder/1458.rss">Can Functions You ➤ Now REORDER</source>
        </item>
        <item>
          <title>For Better or Worse: MACRO</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>So it's long been theorized that there could exist a form of function that would splice its result into the feed of execution.  And now we have it:</p>
<pre><code> appender: macro [x /ref] [
      if ref [
          return [append x second]  ; return block of "incomplete" code
      ] else [
          return [append x first]
      ]
 ]

 &gt;&gt; appender [a b c] [1 2 3]
 == [a b c 1]  ; acts as spliced `&lt;&lt;append x first&gt;&gt; [a b c] [1 2 3]`

 &gt;&gt; appender/ref [a b c] [1 2 3]
 == [a b c 2]  ; acts as spliced `&lt;&lt;append x second&gt;&gt; [a b c] [1 2 3]`
</code></pre>
<p>So you return a BLOCK! of what you want spliced in at the callsite.  The bindings in that block won't be changed, however...so the <strong>x</strong> will still refer to the parameter value, not some x at the callsite.</p>
<p>The reason this exists now is to expose and test a core ability that is used by predicates to make them faster and more reliable.  Predicates do a similar array splice...using the array underlying the PATH! that you pass it.  This means it doesn't have to generate a function (that would need to be GC'd) or run a function application, so <strong>any .not.even? [2, 3]</strong> is aiming to have performance parity with <strong>any [not even? 2, not even? 3]</strong></p>
<p><strong>But as with most language features called "macro", there are downsides.</strong>  The function interface for this macro looks like it only takes one argument, but it winds up implicitly picking up two.  So macros are variadic.  My plan for POINTFREE is to be smarter and actually generate an ACTION! that figures out how many parameters it needs to take, but that's more expensive to do and it was making predicates not as good as it should be.</p>
<p>Note that if you put an enfix operator at the beginning of a macro splice, it will not be able to see its left.  So if you want a macro to see the left hand side parameter, <em>the macro itself has to be enfix</em>.  It will see the enfix parameter, but won't "consume" it:</p>
<pre><code> add1020: enfix macro [discarded] [
     return [+ 1020]
 ]

 &gt;&gt; 304 add1020
 == 1324
</code></pre>
<blockquote>
<p>As a general reminder of why you can't decide enfix "after the fact"... the concept of a single instruction "step" is one that has a finishing point.  If all functions reserved the right to be enfix, then that would mean a DO of a BLOCK! couldn't be separated into individual evaluation steps...each function would run glued to the last.  It would be possible to avoid this if COMMA!s between expressions were enforced so you called out where every expression ended, but we obviously do not want that!</p>
</blockquote>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/for-better-or-worse-macro/1410">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/for-better-or-worse-macro/1410</link>
          <pubDate>Fri, 20 Nov 2020 11:46:54 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1410</guid>
          <source url="https://forum.rebol.info/t/for-better-or-worse-macro/1410.rss">For Better or Worse: MACRO</source>
        </item>
        <item>
          <title>Introducing REFRAMER: Close Cousin to ENCLOSE</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>This is a very cool tool that might help concretize some of the <a href="https://forum.rebol.info/t/seeing-all-action-s-as-variadic-frame-makers/1002/2">abstract-sounding arguments I was making about frames</a>...</p>
<p><strong>Reframers build a frame from whatever follows them at a callsite, and can operate on it before running it (<em>if</em> it runs it).</strong></p>
<p>Defining a reframer involves giving it a function that will act as the "shim".  Here is a reframer using a very simple shim, that just takes in the frame and returns it.</p>
<pre><code>get-frame-of: reframer (func [f [frame!]] [f])
</code></pre>
<p>Here is what happens if the thing that followed that reframer's execution was a call to APPEND:</p>
<pre><code>&gt;&gt; get-frame-of append [a b c] &lt;d&gt;
== make frame! [
    series: [a b c]
    value: &lt;d&gt;
    part: '
    only: '
    dup: '
    line: '
]
</code></pre>
<p>As we can see, it gathered the arguments for the APPEND and put together a FRAME! to represent the call.</p>
<p><strong>The reframing process did not automatically execute the frame.  But the "shim" function can!</strong></p>
<p>Let's try something that runs the function twice.</p>
<pre><code>&gt;&gt; two-times: reframer func [f [frame!]] [do copy f, do f]

&gt;&gt; two-times append [a b c] &lt;d&gt;
== [a b c &lt;d&gt; &lt;d&gt;]
</code></pre>
<h2>Whoa.</h2>
<p><strong>But wait, there's more.</strong>  Besides not automatically executing the FRAME!, <em>it also doesn't typecheck it (yet)</em>.</p>
<pre><code>&gt;&gt; get-frame-of append 1 &lt;d&gt;
== make frame! [
    series: 1        ; !!! this wouldn't be legal to run as-is 
    value: &lt;d&gt;
    part: '
    only: '
    dup: '
    line: '
]
</code></pre>
<p>With our "shim" function in the driver's seat, it can manipulate the inputs and the results.</p>
<p>Consider how right now, functions like APPEND won't take QUOTED!</p>
<pre><code>&gt;&gt; item: first ['''[a b c]]
== '''[a b c]

&gt;&gt; append item &lt;d&gt;
** Script Error: append does not allow QUOTED! for its series argument
</code></pre>
<p>But what if we made a REQUOTE that:</p>
<ul>
<li>would build a frame for whatever follows it</li>
<li>counted how many quoting levels were on the first argument in that frame</li>
<li>took the quoting levels off that first argument</li>
<li>ran the function</li>
<li>added the quoting levels back to the result</li>
</ul>
<p>It should be an easier function to write than it is, but even so it's not that hard:</p>
<pre><code>requote: reframer func [
     {Remove Quoting Levels From First Argument and Re-Apply to Result}
     f [frame!]
     &lt;local&gt; p num-quotes result
][
    p: first words of f
    num-quotes: quotes of f/(p)
    f/(p): dequote f/(p)

    if null? result: do f [return null]  ; exempt NULL from requoting

    return quote/depth get/any 'result num-quotes
]
</code></pre>
<p>And behold:</p>
<pre><code>&gt;&gt; item: first ['''[a b c]]
== '''[a b c]

&gt;&gt; requote append item &lt;d&gt;
== '''[a b c &lt;d&gt;]
</code></pre>
<h2>The Shim Can Take Arguments</h2>
<p>The last argument of the shim needs to be a frame, but it could also have its own arguments.</p>
<p>Just to demonstrate this point without any frame-fiddling to obscure the point, how about a message that prints before and after just executing the frame:</p>
<pre><code>&gt;&gt; bracketer: reframer func [msg [text!] f [frame!]] [
       print msg
       do f
       print msg
   ]

&gt;&gt; bracketer "Aloha!" print "I'm being framed!"
Aloha!
I'm being framed!
Aloha!
== ~void~
</code></pre>
<h2>Things To Think About</h2>
<p>This is very cool, and it pins down a number of questions about evaluation.</p>
<p>Hopefully now you can see why type errors shouldn't happen during argument fulfillment, but only once the function actually gets to the point of running.  e.g. a reframer that just does the function after it shouldn't act any different than that function would running normally.</p>
<p>One tough problem is what to do when you get multiple reframer functions in a row.  I give the example of:</p>
<pre><code>&gt;&gt; item: first ['''[a b c]]
== '''[a b c]

&gt;&gt; item: my requote append &lt;d&gt;
 ; ... how can this work?
</code></pre>
<p>MY is also a reframer.  But if it gets a FRAME! for REQUOTE, that will not be what it expects.  Because REQUOTE has a single argument in its frame...which is a frame, not a callsite argument.  :-/</p>
<p>What MY really wants is a FRAME! for the aggregate function of "REQUOTE APPEND".  Such aggregate frames aren't impossible to conceive of, but are beyond what we have today.</p>
<p>That's probably the biggest issue I can see right now with this.  But it's a step ahead of having to reinvent the technique on every function that wants to do something like it.  And it means that when an answer for one such functions is made, all of them will get it.</p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/introducing-reframer-close-cousin-to-enclose/1395">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/introducing-reframer-close-cousin-to-enclose/1395</link>
          <pubDate>Mon, 09 Nov 2020 03:15:57 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1395</guid>
          <source url="https://forum.rebol.info/t/introducing-reframer-close-cousin-to-enclose/1395.rss">Introducing REFRAMER: Close Cousin to ENCLOSE</source>
        </item>
        <item>
          <title>DEFAULT with Predicates: The Must-Match Constraint</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>With some sadness, <a href="https://forum.rebol.info/t/default-now-usable-in-case-switch/739/6">the experiment for DEFAULT inside of CASE/SWITCH is having to get the axe</a>.  I explain the reason there due to the coming influence of predicates.</p>
<blockquote>
<p>Note: I will emphasize that these experiments--even if they get backed out--are frequently major contributors in the sense of the facilities they test and keep working.  In this case, skippable left enfix quoting.</p>
<p>(The same is true of why COMMA! could be implemented in a day.  Its BAR!-based predecessors had stretched over years of sifting out the interactions of invisible expression barriers with all the other constructs.)</p>
</blockquote>
<h2>The Predicates Taketh Away, But They Also Giveth!</h2>
<p>So to bring in a fun new feature, I've added a predicate to DEFAULT itself.</p>
<p>What the predicate means is that you can have an additional test (beyond "being not NULL or VOID!") for <em>when a value shouldn't be overwritten</em>.</p>
<pre><code>&gt;&gt; value: "not an integer"

&gt;&gt; value: default .integer? [10 + 20]
&gt;&gt; value  ; wasn't an integer, changed
== 30

&gt;&gt; value: default .integer? [1000 + 2000]
&gt;&gt; value
== 30  ; was already an integer, no change.
</code></pre>
<p>So the behavior is <em>similar</em> to:</p>
<pre><code>if not integer? value [value: 1000 + 2000]
</code></pre>
<p>But you're getting more than avoiding the repeat of a variable name.  You're actually getting:</p>
<pre><code>all [
     not void? get/any 'value   ; or `defined? 'value`
     not null? :value           ; or `set? 'value`
     not integer? :value
 ] then [
     value: 1000 + 2000
 ]
</code></pre>
<h2>Question: Should The Predicate Be Backwards?</h2>
<p>This depends on how you read it <strong>x: default .xxx? [...]</strong></p>
<pre><code>X Should DEFAULT IF .XXX? is TRUE

X Should DEFAULT UNLESS .XXX? is TRUE
</code></pre>
<p>Neither the word "IF" nor "UNLESS" appear in DEFAULT, so it's not like there's an obvious answer.</p>
<p>I picked it the UNLESS way because it seems like you'd end up writing shorter code in general if you talk about what you <em>want</em> instead of what you <em>don't want</em>.  Almost every condition would need a NOT in it, otherwise.  So you save some typing.</p>
<p>But if people find it confusing this way, and really believe changing it would help, I'd be fine with it.</p>
<h2>Predicates Are Game-Changers</h2>
<p>There was a lot of agony before about whether BLANK! should count as a "set" variable or not.  if that's something people might want to control, you have to think of a refinement name for it (DEFAULT/ONLY ?) and it can get very hard to reason about.</p>
<p>This cuts through all the fog.  If you don't supply a predicate, the default is <code>.not.blank?</code>   e.g. any non-blank value counts as being already set, and isn't defaulted.  But blank values are defaulted.</p>
<p>Providing a custom predicate overrides it.  This is infinitely more useful.</p>
<p><strong>I think you're going to like where predicates are going, as the haphazard internal non-configurable decision making of constructs is formalized and overridable.</strong></p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/default-with-predicates-the-must-match-constraint/1393">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/default-with-predicates-the-must-match-constraint/1393</link>
          <pubDate>Sat, 07 Nov 2020 15:09:15 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1393</guid>
          <source url="https://forum.rebol.info/t/default-with-predicates-the-must-match-constraint/1393.rss">DEFAULT with Predicates: The Must-Match Constraint</source>
        </item>
        <item>
          <title>Sending Values into a BLACKHOLE!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>Multiple return values have an interesting angle to them: <strong>the more values you request... the functionality you ask for might wind up being different</strong>.</p>
<p>Consider TRANSCODE.  If you don't use multi-returns...or just ask for one return...you get the whole thing transcoded as a block:</p>
<pre><code>&gt;&gt; transcode "&lt;abc&gt; &lt;def&gt;"  ; plain behavior
== [&lt;abc&gt; &lt;def&gt;]

&gt;&gt; block: transcode "&lt;abc&gt; &lt;def&gt;"  ; set-word! (follows usual rules)
== [&lt;abc&gt; &lt;def&gt;]

&gt;&gt; [block]: transcode "&lt;abc&gt; &lt;def&gt;"  ; same behavior as `block:`, enforced
== [&lt;abc&gt; &lt;def&gt;]
</code></pre>
<p>But if you supply it with a parameter in the second slot, it assumes you want /NEXT and will set that argument to the next position.</p>
<pre><code>&gt;&gt; [value pos]: transcode "&lt;abc&gt; &lt;def&gt;"
== &lt;abc&gt;

&gt;&gt; pos
== " &lt;def&gt;"

&gt;&gt; value
== &lt;abc&gt;
</code></pre>
<p>BLANK! gives you the ability to opt out of slots in the multiple return values that you don't want.  But opting out doesn't just keep you from having to name a variable, it also <em>un-requests the behavior</em>...</p>
<pre><code>&gt;&gt; [value _]: transcode "&lt;abc&gt; &lt;def&gt;"
== [&lt;abc&gt; &lt;def&gt;]  ; not a /NEXT, it was "revoked"
</code></pre>
<p>What if you want to request the behavior, but not have to bother with creating a variable to store it in?  Well now that we are thinking <strong>#</strong> will be a shorthand for the immutable and not-appendable-to-strings "codepoint 0", it's a perfect choice:</p>
<pre><code>&gt;&gt; [value #]: transcode "&lt;abc&gt; &lt;def&gt;"
== &lt;abc&gt;  ; only the /NEXT item
</code></pre>
<p>The value was requested but disappeared...into a black hole.  In fact, BLACKHOLE! is now a datatype you can put in a spec to mean "empty issue that is precisely <code>#</code>.  It's not validated yet (it's a synonym for ISSUE!...we'll need type constraints before it can work).  But it can help keep track of places that use this idea.  For instance, SET:</p>
<pre><code>&gt;&gt; set # 10
== 10
</code></pre>
<p>The truthiness of # helps write code that distinguishes the wish to opt-out of a behavior from the wish to opt-out of getting its result.  Having SET error on blank helps you avoid calculations that may be unnecessary...so it works out perfectly:</p>
<pre><code> do-something: func [
     in
     /out [blank! word! path! blackhole!]
     &lt;local&gt; result
 ][
     process foo
      if bar [  ; unlike BLANK!, empty issue is truthy so branch runs
         result: process/more foo
         set bar result  ; blackhole SET is no-op (BLANK! would error)
      ]
 ]
</code></pre>
<p><em>Elegante.</em></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/sending-values-into-a-blackhole/1347">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/sending-values-into-a-blackhole/1347</link>
          <pubDate>Sat, 26 Sep 2020 20:19:21 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1347</guid>
          <source url="https://forum.rebol.info/t/sending-values-into-a-blackhole/1347.rss">Sending Values into a BLACKHOLE!</source>
        </item>
        <item>
          <title>AUGMENT: Add Parameters and Refinements After-The-Fact</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p><img src="https://forum.rebol.info/images/emoji/twitter/boxing_glove.png?v=9" title=":boxing_glove:" class="emoji" alt=":boxing_glove:"> <a href="https://www.youtube.com/watch?v=VWuVEhTJPdw">Don't call it a comeback...</a> <img src="https://forum.rebol.info/images/emoji/twitter/boxing_glove.png?v=9" title=":boxing_glove:" class="emoji" alt=":boxing_glove:"></p>
<p><strong>AUGMENT</strong> is a new addition to the function composition toolbox.  It serves a single purpose: to create a variation of a function that has more parameters and refinements, but <em>acts exactly the same</em>.</p>
<pre><code>&gt;&gt; foo-x: func [x [integer!]] [
       print ["x is" x]
   ]

&gt;&gt; foo-xy: augment :foo-x [y [integer!]]

&gt;&gt; foo-x 10
x is 10

&gt;&gt; foo-xy 10
** Error: foo-xy is missing its y argument

&gt;&gt; foo-xy 10 20
x is 10
</code></pre>
<p>You might ask: "What good is that, since the original function has no idea the parameter is there?"  This is where our friends like ADAPT and ENCLOSE come in.</p>
<p>Let's try that again.  First, with an ADAPT:</p>
<pre><code>&gt;&gt; foo-xy: adapt (augment :foo-x [y [integer!]]) [
       print ["y is" y]
   ]

&gt;&gt; foo-xy 10 20
y is 20
x is 10
</code></pre>
<p>And here's an ENCLOSE example:</p>
<pre><code>&gt;&gt; foo-xy2: enclose (augment :foo-x [y [integer!]]) func [f [frame!]] [
       let y: f.y
       print ["y is" y]
       do f
       print ["y is still" y]
   ]

&gt;&gt; foo-xy2 10 20
y is 20
x is 10
y is still 20
</code></pre>
<h2>This didn't drop out of the sky...</h2>
<p>It is the result of long-term-thinking, and design choices with an eye toward doing this <em>someday</em>.  One of the recent strategic moves that really made it feasible was <a href="https://forum.rebol.info/t/pure-and-refined-simplifying-refinements-to-one-or-zero-args/1120">changing refinements to be their own arguments</a>.  If it weren't for that, if your function was <strong>foo: func [x /y] [...]</strong> and you tried <strong>bar: augment 'foo [z]</strong>, the parameter list would look like you had written <strong>bar: func [x /y z] [...]</strong>.  As soon as a function got a refinement, you'd have no way to add a normal parameter...because everything would become an argument to the last refinement.</p>
<p>The very first motivating scenario which got me thinking about this was when I was lobbying for removing the /DEFAULT refinement from SWITCH.  I felt strongly about needing a generalized solution based on NULL results from branching constructs.  But I wanted it to be easy to make a compatibility version.</p>
<p>And now, it <strong>is</strong> easy:</p>
<pre><code> switch-d: enclose (augment :switch [
     /default "Default case if no others are found"
        [block!]
 ]) func [f [frame!]] [
     let def: f.default  ; see NOTE on why it's not `do f else (f/default)`
     do f else (def)
 ]
</code></pre>
<p>It works the way you'd expect:</p>
<pre><code>&gt;&gt; switch-d 1 [1 [print "one" 1020]]
one
== 1020

&gt;&gt; switch-d/default 1 [1 [print "one" 1020]] [print "defaulting!" 304]
one
== 1020

&gt;&gt; switch-d/default 2 [1 [print "one" 1020]] [print "defaulting!" 304]
defaulting!
304
</code></pre>
<p>I'm not totally thrilled with the way the meta information for HELP is being inherited.  But the somewhat hackish way it is done is working well enough to get us started.  Note how the description for /DEFAULT was incorporated:</p>
<pre><code>&gt;&gt; help switch-d
USAGE:
    SWITCH-D value :predicate cases /all /default

DESCRIPTION:
    Selects a choice and evaluates the block that follows it.
    SWITCH-D is an ACTION!

RETURNS: [&lt;opt&gt; any-value!]
    Last case evaluation, or null if no cases matched

ARGUMENTS:
    value [&lt;opt&gt; any-value!]
        Target value
    :predicate [refinement! action! &lt;skip&gt;]
        Binary switch-processing action (default is /EQUAL?)
    cases [block!]
        Block of cases (comparison lists followed by block branches)

REFINEMENTS:
    /all
        Evaluate all matches (not just first one)
    /default [block!]
        Default case if no others are found
</code></pre>
<p>This is a very new mechanism that is going to need testing.  But it's going to make many things easier--not just in implementing things like Redbol, but also in being able to create skins with warnings about deprecated refinements (and what to do instead)...while removing those refinements from the natives themselves.</p>
<p>Try it out!</p>
<hr>
<p><em>NOTE: Although I'm now of the belief that <a href="https://forum.rebol.info/t/what-happens-to-function-arguments-and-locals-when-the-call-ends/234">function arguments must outlive their calls</a>, I don't believe this implies that <strong>do f</strong> should not invalidate the caller's handle on that <strong>f</strong> frame.  It is an effective transfer of ownership of that frame to the function; and you need the feedback that you cannot expect another DO to work again.  Hence the default must be cached.</em></p>
            <p><small>4 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/augment-add-parameters-and-refinements-after-the-fact/1216">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/augment-add-parameters-and-refinements-after-the-fact/1216</link>
          <pubDate>Fri, 27 Sep 2019 18:46:50 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1216</guid>
          <source url="https://forum.rebol.info/t/augment-add-parameters-and-refinements-after-the-fact/1216.rss">AUGMENT: Add Parameters and Refinements After-The-Fact</source>
        </item>
        <item>
          <title>AS BINARY! view of strings is back...with UTF-8! (that&#39;s only /PART!)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <h2>Mutate strings aliased as BINARY!, and vice-versa, as in Rebol2!</h2>
<p>Rebol2's AS-BINARY and AS-STRING provided a convenient aliasing between binary and string as Latin1 single-byte characters:</p>
<pre><code>rebol2&gt;&gt; b: as-binary s: "hello"
== #{68656C6C6F}

rebol2&gt;&gt; append b #{68}
== #{68656C6C6F68}

rebol2&gt;&gt; s
== "helloh"  ; binary mutation reflected in original string

rebol2&gt;&gt; append s "ello"
== "hellohello"

rebol2&gt;&gt; b
== #{68656C6C6F68656C6C6F}
</code></pre>
<p>That was lost when R3-Alpha's internal string format became too unpredictable (swinging between Latin1 and UCS2) and was only canonized as UTF-8 for I/O.  Red suffered a similar fate.</p>
<p>But with <a href="https://forum.rebol.info/t/realistically-migrating-rebol-to-utf8-everywhere/374">UTF-8 Everywhere</a> as the fixed internal format of strings, Ren-C has done some voodoo to bring it back.</p>
<p>It offers a more generic AS operation, along with higher-than-UCS2 codepoint support:</p>
<pre><code>&gt;&gt; b: as binary! s: "hello"
== #{68656C6C6F}

&gt;&gt; to binary! "🐱"
== #{F09F90B1}

&gt;&gt; append b #{F09F90B1}  ; add that high-codepoint cat!
== #{68656C6C6FF09F90B1}

&gt;&gt; s
== "hello🐱"

&gt;&gt; append s "hello🐱"
== "hello🐱hello🐱"

&gt;&gt; b
== #{68656C6C6FF09F90B168656C6C6FF09F90B1}
</code></pre>
<p>But a binary alias of a string is constrained to staying as valid UTF-8:</p>
<pre><code>&gt;&gt; append b #{FEFEFEFE}
** Internal Error: invalid UTF-8 byte sequence found during decoding
</code></pre>
<p>You can actually alias WORD! as BINARY! also, without doing a separate allocation.  But it will be  read-only view, so all you're doing is saving on memory and GC load:</p>
<pre><code>&gt;&gt; b: as binary! 'immutable-word
== #{696D6D757461626C652D776F7264}

&gt;&gt; append b #{1020}
** Access Error: series is source or permanently locked, can't modify
</code></pre>
<p>Similarly, you can alias words as strings...again without making a new allocation, but with the same read-only constraint:</p>
<pre><code>&gt;&gt; t: as tag! 'append
== &lt;append&gt;

&gt;&gt; append t "nope"
** Access Error: series is source or permanently locked, can't modify
</code></pre>
<h2>The /PART refinement has just been implemented for UTF-8</h2>
<p><a href="https://github.com/rebol/rebol-issues/issues/2096" rel="nofollow noopener">The controversial behavior can be discussed on issue #2096</a> (which you can discuss on that ticket).  But what R3-Alpha and Red choose to (<a href="https://github.com/rebol/rebol-issues/issues/2383" rel="nofollow noopener">buggily</a>) implement is that it applies to the target series only...and is thus measured in the units of <em>that</em> series:</p>
<pre><code>&gt;&gt; append/part "abc" [100 "de" "fg"] 2
== "abc10"  ; 2 string units, not "abc100de" from 2 block units
</code></pre>
<p>The argument is that COPY/PART on the source series gives you that form /PART if you need it, so this is "strictly more powerful".  Rightly or wrongly... Ren-C is now doing it hopefully less buggily (though almost certainly with its own bugs), but with UTF-8 Everywhere support.</p>
<p>If you like, you can limit how much of a binary you extract from UTF-8, counted in bytes:</p>
<pre><code>&gt;&gt; to binary! "🐱"
== #{F09F90B1}

&gt;&gt; append/part #{} "🐱" 2  ; e.g. 2 bytes (half a cat)
== #{F09F}
</code></pre>
<p>Extracting bytes from UTF-8 will always work.  Going the other way, not all binary strings are valid UTF-8.  But as long as the number of characters you ask for in that section of the binary are valid, having other invalid bytes isn't a problem...only when you ask for part out of the unchecked region:</p>
<pre><code>&gt;&gt; append/part "" #{F09F90B1F09F90B1FEFEFEFE} 2  ; e.g. 2 characters
== "🐱🐱" 

&gt;&gt; append/part "" #{F09F90B1F09F90B1FEFEFEFE} 3
** Internal Error: invalid UTF-8 byte sequence found during decoding
</code></pre>
<p>If a binary is actually an alias of a UTF-8 string, this can be more efficient by not rescanning... <em>(though the code is still in its early life yet, so it has a number of areas for improvement)</em>.</p>
<p><strong>Pretty cool, eh?</strong></p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/as-binary-view-of-strings-is-back-with-utf-8-thats-only-part/1186">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/as-binary-view-of-strings-is-back-with-utf-8-thats-only-part/1186</link>
          <pubDate>Tue, 23 Jul 2019 21:33:25 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1186</guid>
          <source url="https://forum.rebol.info/t/as-binary-view-of-strings-is-back-with-utf-8-thats-only-part/1186.rss">AS BINARY! view of strings is back...with UTF-8! (that&#39;s only /PART!)</source>
        </item>
        <item>
          <title>The Even More Powerful COMPOSE</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>COMPOSE got a pretty cool super power <a href="https://forum.rebol.info/t/tag-compose-is-it-tag-specific-composition/979/7">with labeling</a>, so that a "skippable" TAG! or FILE! could be used to point out just the slots you wanted the compose to apply to:</p>
<pre><code>&gt;&gt; compose [(1 + 2) (1 + 2)]
== [3 3]

&gt;&gt; compose &lt;*&gt; [(1 + 2) (&lt;*&gt; 1 + 2)]
== [(1 + 2) 3]

&gt;&gt; compose % [(1 + 2) (% 1 + 2)]  ; even empty file is legal, which is succinct
== [(1 + 2) 3]
</code></pre>
<p>Then there's the new ability to use quoted groups, SET-GROUP!s, and GET-GROUP!s:</p>
<pre><code>&gt;&gt; stuff: [word some/path [will be a triple quoted get-block!]]

&gt;&gt; compose ['(first stuff) (second stuff): ''':(third stuff)]
== ['word some/path: ''':[will be a triple quoted get-block!]]
</code></pre>
<p>Whoa.  But wait, there's more!  <img src="//forum.rebol.info/images/emoji/twitter/slight_smile.png?v=7" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
<p>We now have the ability to run functions on the slots before you splice them.  These functions are specified <a href="https://forum.rebol.info/t/brave-switch-new-world-skippable-predicates/1045">via the "predicate" convention</a> (for the moment it's a "refinement-style" PATH!, but will be a TUPLE! when generalized tuples are implemented)</p>
<pre><code>&gt;&gt; addone: function [x] [x + 1]

&gt;&gt; compose /addone [(10 + 20) (30 + 40)]
== [31 71]
</code></pre>
<p>Putting things in doubled-up groups asks to not apply the post-processing function on that particular slot.<br>
It still composes it, but just doesn't run the function:</p>
<pre><code>&gt;&gt; compose /addone [(10 + 20) ((30 + 40))]
== [31 70]
</code></pre>
<p>Something very interesting is that if you use a function that puts its argument into a block (e.g. the ENBLOCK function), then that would be the same as doing historical Rebol's COMPOSE/ONLY...because the block would be spliced and leave its single element behind, even if that block was itself a block.  Then, the (( )) would be a way of opting out and saying you wanted to splice blocks normally.</p>
<pre><code>&gt;&gt; compose /enblock [([a b c]) (([d e f]))]
== [[a b c] d e f]
</code></pre>
<p>So that first [a b c] was transformed to [[a b c]], and then spliced in to lose the outer block.  The doubled group was a request not to run enblock, so that block just got spliced.</p>
<p>Now here's the fun bit: <strong>enblock is the default predicate</strong>.  This means that if you don't override it, you can mentally model the (( )) as an instruction to splice if it's a block!</p>
<pre><code>&gt;&gt; compose [([a b c]) (([d e f]))]
== [[a b c] d e f]
</code></pre>
<p>This is a point of incompatibility with historical Rebol, because COMPOSE is effectively what was COMPOSE/ONLY unless you splice with (( )).  But you can still write code that will work in either Ren-C or historical Rebol by putting things in doubled groups when you want them to splice...the (( )) will just be ignored in the older Rebol and it will consider all slots spliceable.</p>
<p>If you want the old behavior, just ask to use the identity function.  Then it makes no difference whether the function is applied or not:</p>
<pre><code>&gt;&gt; compose /identity [([a b c]) (([d e f]))]
== [a b c d e f]
</code></pre>
<p>This only scratches the surface of what's possible!  I'm very interested to see how people use the features.  (Don't get too attached to the PATH! notation, though...that's temporary, like I said.)</p>
            <p><small>6 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/the-even-more-powerful-compose/1101">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-even-more-powerful-compose/1101</link>
          <pubDate>Wed, 06 Mar 2019 02:00:38 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1101</guid>
          <source url="https://forum.rebol.info/t/the-even-more-powerful-compose/1101.rss">The Even More Powerful COMPOSE</source>
        </item>
        <item>
          <title>Persistence of Memory: The Enfix Console Trick</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>Access to the last expression's result is pretty important.  So I was wondering what sort of syntax we could use to splice it in.  We could commandeer some existing Rebol token:</p>
<pre><code>&gt;&gt; second [&lt;alpha&gt; &lt;beta&gt;]
== &lt;beta&gt;

&gt;&gt; print #1   ; e.g. #1 for last console result, #2 for the one before that...
&lt;beta&gt;
</code></pre>
<p>But by definition, <em>anything</em> you pick could be meant literally.  We have quite a few more possibilities to make the escaping ever more esoteric, like <strong><code>&lt;console&gt;/#1</code></strong>.  But if the point is to keep you from re-entering or retyping a result, having to type in a long thing to get uniqueness defeats the purpose...you're usually trying to save time.</p>
<p>Maybe the best idea would be to find a way to get the result <em>without mentioning it at all</em>.  And that gave me the idea of combining enfix and generalized quoting, to make the <code>system/console/dialect-hook</code> (which runs after all the code has been LOADed) do something extremely cool...</p>
<h2>Kicking it old-school, calculator-style</h2>
<p>The idea is that we <em>inject the last result, quoted, at the start of the code we're running</em>!  If the next operation isn't enfix, it will just be scrapped.  If it is enfix, it will get picked up as if it had been on the left.</p>
<pre><code>&gt;&gt; 1 + 2
== 3

&gt;&gt; * 10   ; it actually runs `('3 * 10)`
== 30
</code></pre>
<p>And with a small tweak to the SHOVE (<strong><code>-&gt;</code></strong>) operation, you can now shove the left hand side into a SET-WORD! (or SET-PATH!, SET-GROUP!, SET-BLOCK!....)</p>
<pre><code>&gt;&gt; 1 + 2
== 3

&gt;&gt; -&gt; foo:
== 3

&gt;&gt; foo
== 3
</code></pre>
<p>Why is the quoting important?  Well, if the last thing you evaluated was an ACTION!, you don't want that action to run, if it was a SET-WORD! you don't want it to assign, etc. etc.  But you do want to be able to capture it!</p>
<pre><code>&gt;&gt; func [x] [x + 1]

&gt;&gt; -&gt; addone:

&gt;&gt; addone 10
== 11
</code></pre>
<p>Nothing is injected for a VOID! result.  So if you ever want to clear out the memory and not get this behavior, just cycle the prompt by hitting enter.</p>
<pre><code>&gt;&gt; 1 + 2
== 3

&gt;&gt;  ; hit enter

&gt;&gt; * 5
** Script Error: * is missing its value1 argument
</code></pre>
<p>Are we having fun, yet?  <img src="//forum.rebol.info/images/emoji/twitter/partying_face.png?v=7" title=":partying_face:" class="emoji" alt=":partying_face:"></p>
<p>Notable is <a href="https://github.com/metaeducation/ren-c/commit/73da0961c6f0b37bbbc3fb0675c6c430bdb6d2ff" rel="nofollow noopener">just how little code this took to implement</a>, mostly comments and adding the SET-XXX! feature to SHOVE.  Imagine how easy it would be to start adding your own console customizations!</p>
<blockquote>
<p>Not too distant plans might allow things like:</p>
<pre><code>&gt;&gt; data: [&lt;a&gt; &lt;b&gt;]

&gt;&gt; 1 + 2
== 3

&gt;&gt; -&gt; (=&gt; append data)
== [&lt;a&gt; &lt;b&gt; 3]
</code></pre>
<p>That would be a shorthand for:</p>
<pre><code>-&gt; specialize 'append [series: data]
</code></pre>
<p>I haven't really figured out what these "by example" specializations will look like.  At first, I thought it could be a behavior of GET-GROUP!:</p>
<pre><code>-&gt; :(append data)
</code></pre>
<p>But if it's not the <em>only</em> behavior of GET-GROUP!, I fear it might be too confusing.  Having the behavior of an unfinished call in a group producing a specialization could be unpredictable-seeming, when the user would have liked to get an error.  (That is if they could use GET-GROUP! for other things besides specialization, e.g. <code>:(x)</code> as <code>get x</code>)</p>
<p>The average person would probably find that too convoluted and just use a variable.  <img src="//forum.rebol.info/images/emoji/twitter/slight_smile.png?v=7" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
</blockquote>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/persistence-of-memory-the-enfix-console-trick/1071">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/persistence-of-memory-the-enfix-console-trick/1071</link>
          <pubDate>Fri, 15 Feb 2019 09:48:47 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1071</guid>
          <source url="https://forum.rebol.info/t/persistence-of-memory-the-enfix-console-trick/1071.rss">Persistence of Memory: The Enfix Console Trick</source>
        </item>
        <item>
          <title>Postfix Assertions: SO, WAS, MATCHED</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>Assertions are important, but some people want to write short code and feel the assertions can clutter it up.</p>
<p>But what if the assertion was as brief and to the point as a comment was?  That inspired these postfix assert operators...</p>
<h2>SO</h2>
<p>Takes a condition on the left and treats that as a thing to assert on.  It's variadic on the right and won't run the right to get the expression until the left has been shown as true.</p>
<pre><code>&gt;&gt; x: 0

&gt;&gt; 1 = 2 so x: &lt;changed&gt;
** Script Error: assertion failure: [false so]
** Where: so console
** Near: [... = 2 so ~~ x: &lt;changed&gt;]

&gt;&gt; x
== 0  ; didn't change, the assignment didn't get a chance to run

&gt;&gt; 1 = 1 so x: &lt;changed&gt;
== &lt;changed&gt;

&gt;&gt; x
== &lt;changed&gt;  ; the right hand side once the left was shown true
</code></pre>
<h2>WAS</h2>
<p>The WAS word has been reclaimed from a previous purpose, now to assert "lax equality" (or IS-ness) of the left hand side to the right.  But it passes on the value.</p>
<pre><code>&gt;&gt; 10 + 10 was 5 + 15
== 20

&gt;&gt; 10 + 10 was 50 + 1000
** Script Error: assertion failure: [20 is 1050]
** Where: was console
** Near: [... 10 was 30 ~~]
</code></pre>
<h2>MATCHED</h2>
<p>Very similar to WAS, but a variant which uses the logic of <a href="https://forum.rebol.info/t/time-to-meet-your-match-dialect/1009">the MATCH dialect</a>, e.g. to test the datatype.</p>
<pre><code>&gt;&gt; 10 + 10 matched integer!
== 20

&gt;&gt; 10 + 10 matched text!    
** Script Error: assertion failure: [20 matches text!]
** Where: matched console
** Near: [... 10 matched text! ~~]
</code></pre>
<h2>Added Bonus: ASSERT is now invisible</h2>
<p>Cool as these are, you still might want to use the plain old assert for something.  If you do, know that it is now...invisible!  So you can put it anywhere.</p>
<pre><code>&gt;&gt; all [
    x: 1 + 1 
    assert [x &gt; 1]
 ]
 == 2

&gt;&gt; all [
    x: 1 + 1 
    assert [x &lt; 1]
 ]
** Script Error: assertion failure: [
    x &lt; 1 ** false
]
** Where: _ assert all console
** Near: [[x &lt; 1] ~~]</code></pre>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/postfix-assertions-so-was-matched/1046">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/postfix-assertions-so-was-matched/1046</link>
          <pubDate>Thu, 31 Jan 2019 17:55:50 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1046</guid>
          <source url="https://forum.rebol.info/t/postfix-assertions-so-was-matched/1046.rss">Postfix Assertions: SO, WAS, MATCHED</source>
        </item>
        <item>
          <title>Show the Love for SHOVE (&gt;-)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <h2><code>&gt;-</code></h2>
<p>Despite having a bit tricky to implement, it's very easy to understand.  <strong>It just pushes the argument on its left to be the first argument of the operation on its right:</strong></p>
<pre><code>&gt;&gt; 1 &gt;- add 2 * 3
== 7  ; as if you'd written `add 1 2 * 3`
</code></pre>
<p>Simple, right?  You might think it's not something you would use... <em>but you'd be thinking wrong!</em></p>
<h2>Invoke enfix functions in modules or libraries</h2>
<p>Enfix execution cannot work with paths (<a href="https://forum.rebol.info/t/letting-go-of-enfix-path-dreams-but-fixing-it-with-magic/794">this isn't a bug, it <em>shouldn't</em> work</a>):</p>
<pre><code>r3-alpha&gt;&gt; 1 lib/+ 2 * 3
** Script error: op! type is not allowed here
</code></pre>
<p>But shove has your back:</p>
<pre><code>&gt;&gt; 1 &gt;- lib/+ 2 * 3
== 9  ; as if you'd written `1 + 2 * 3`
</code></pre>
<p><em>(Note the result is different from what you get with add, since + is enfix.)</em></p>
<p><strong>This is only going to get more critical as modules and namespacing move forward.</strong> And anyone who's redefined an operator--but wants to temporarily reach for another implementation--will want this.</p>
<h2>Invoke refinements on enfix executions</h2>
<p>Historically there aren't really refinements on infix functions, because you'd never be able to use them.  Now you can:</p>
<pre><code>&gt;&gt; ++: enfixed func [a b /double] [a + either double [2 * b] [b]]

&gt;&gt; 10 ++ 20
== 30

&gt;&gt; 10 &gt;- ++/double 20
== 50
</code></pre>
<p>In the common case, you hope that your operator doesn't need refinements.  But when a special case comes up, it's nice to not have to define a prefix form just for that one instance. (which means coming up with a new name that people need to know also).  Now you can take for granted that shove is there when you need it.</p>
<h2>Symbol-y, but not symbol soup: it communicates!</h2>
<p>Being an "arrow word" is crucial to showing its disruption of the evaluation order.  That's not going to be conveyed by a short alphabetic name:</p>
<pre><code>&gt;&gt; 1 shove lib/+ 2 * 3   ; lame and wordy
== 9
</code></pre>
<p>Invoking enfix functions from modules/namespaces and using refinements with them is <em>fundamental behavior</em>.  So it needs to be very short and light.  You want people to take this thing for granted!</p>
<h2>Extra credit: tweak the argument precedence</h2>
<p>Rebol is well known for having a difference in interpretation when you use an infix operator vs. not:</p>
<pre><code>&gt;&gt; add 1 2 * 3
== 7

&gt;&gt; 1 + 2 * 3
== 9
</code></pre>
<p><em>(If you don't know why that is--and wonder why such a "quirk" hasn't been changed despite a lot of thought--<a href="https://forum.rebol.info/t/the-beta-one-enfix-covenant/1023">you can read more than you ever wanted to about it</a>)</em>.</p>
<p>Above I showed that shove takes its cue on how to act based on the enfixedness of what you're shoving into:</p>
<pre><code>&gt;&gt; 1 &gt;- lib/add 2 * 3
== 7  ; as if you'd said `add 1 2 * 3`

&gt;&gt; 1 &gt;- lib/+ 2 * 3
== 9  ; as if you'd said `1 + 2 * 3`
</code></pre>
<p><strong>But it might be argued that since <code>&gt;-</code> is enfix, the overall operation is always enfix, which intuitively would suggest both of the above should be 9.</strong></p>
<p>It's tough to say.  But I liked the simple definition of <em>"shove uses the value on the left as the first argument"</em>.  Imagine what the "as if you'd said" would have to be if the shove into ADD above gave 9, if you couldn't take for granted another known another name for the operation (like <code>+</code>):</p>
<pre><code>&gt;&gt; 1 &gt;- lib/add 2 * 3  ; let's say it's the hypothetical enfix-always version
== 9  ; as if you'd said `temp: enfixed :add | 1 temp 2 * 3`
</code></pre>
<p>But for sake of completeness...I introduced "force enfix behavior (<strong>-&gt;-</strong>)" and  "force prefix behavior (<strong>&gt;--</strong>)" forms:</p>
<pre><code>&gt;&gt; 1 -&gt;- lib/add 2 * 3
== 9  ; as if you'd said `1 + 2 * 3`

&gt;&gt; 1 &gt;-- lib/+ 2 * 3
== 7  ; as if you'd said `add 1 2 * 3`
</code></pre>
<p>I think it's cute that <strong><code>-&gt;-</code></strong> looks like a picture of args on the left and right of an operator, suggesting infix... while <strong><code>&gt;--</code></strong> looks like no args on the left with two args on the right!</p>
<p>But you could also just use parentheses:</p>
<pre><code>&gt;&gt; (1 &gt;- lib/add 2) * 3
== 9

&gt;&gt; 1 &gt;- lib/+ (2 * 3)
== 7
</code></pre>
<p>So whether <code>-&gt;-</code> and <code>&gt;--</code> survive or not is an open question.  If anyone actually uses them, I'd be interested to know.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/show-the-love-for-shove/1039">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/show-the-love-for-shove/1039</link>
          <pubDate>Mon, 28 Jan 2019 01:32:43 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1039</guid>
          <source url="https://forum.rebol.info/t/show-the-love-for-shove/1039.rss">Show the Love for SHOVE (&gt;-)</source>
        </item>
        <item>
          <title>Easier Generalized Quoting: &lt;dequote&gt; and &lt;requote&gt;</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>There are primitives for generalized quoting:</p>
<ul>
<li>
<strong>quoted?</strong> is the test, which is actually a datatype test (the type is QUOTED!)</li>
<li>
<strong>quotes of x</strong> counts the number of quote levels</li>
<li>
<strong>unquote x</strong> removes one quote level, <strong>unquote/depth x count</strong> removes more</li>
<li>
<strong>quote x</strong> will eventually add quote levels, along with <strong>quote/depth</strong>
</li>
</ul>
<p><em>(For today, QUOTE is called UNEVAL.  This makes it easier to find places where you've forgotten to switch over to LITERAL or LIT for the old meaning of QUOTE.  The weird name actually is what was around to do something similar before generalized quoting... it made a GROUP! with a quote in it, so each step of eval of that group would just remove one level of evaluation.)</em></p>
<p>So you've got everything you need to work with them.  But there are some common scenarios of dealing with them that we can help with.</p>
<p>For instance, sometimes you want to basically see past the quoting level of something and operate on its basic type, then return that thing quoted back to the level you had it.  Imagine this:</p>
<pre><code>increment: function [
    return: [&lt;opt&gt; integer!]
    x [quoted! integer!]
][
    num-quotes: quotes of x
    x: dequote x
    if not integer? x [
        fail "Invalid type"
    ]
    if x &gt; 304 [return null]
    return quote/depth (x + 1) num-quotes
]
</code></pre>
<p>So this way you get:</p>
<pre><code> &gt;&gt; increment lit '''303
 '''304

 &gt;&gt; increment lit '''1020
 ; null
</code></pre>
<p>It's cool that you <em>can</em> do that, but it's a bit irritating to write. And it's a pattern that happens often.</p>
<p>So here's a tool for helping with that:</p>
<pre><code>foo: function [
    return: [&lt;opt&gt; &lt;requote&gt; integer!]
    x [&lt;dequote&gt; integer!]
][
    if x &gt; 304 [return null]
    return x + 1
]
</code></pre>
<p>It has the same behavior, but everything is handled for you automatically, including the type checking.  As you can see it doesn't put quote levels back on a null...it assumes null doesn't have the requote rule apply.  The exception would be if your input was a quoted null, in which case it would think you meant to support that.</p>
<p>You don't have to use <code>&lt;requote&gt;</code>, you can just dequote a parameter and not add it back in to the result.  If you have <code>&lt;dequote&gt;</code> on more than one argument, then the requote will have the sum of the quotes taken off for all arguments.  That's a weird heuristic that probably won't come in useful too often, but if it's not what you want you'll have to take a QUOTED! and do your own magic.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/easier-generalized-quoting-dequote-and-requote/1035">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/easier-generalized-quoting-dequote-and-requote/1035</link>
          <pubDate>Sat, 26 Jan 2019 00:25:15 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1035</guid>
          <source url="https://forum.rebol.info/t/easier-generalized-quoting-dequote-and-requote/1035.rss">Easier Generalized Quoting: &lt;dequote&gt; and &lt;requote&gt;</source>
        </item>
        <item>
          <title>You can has GET-BLOCK! (SET-BLOCK!, GET-GROUP!, SET-GROUP!)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p><a href="https://github.com/metaeducation/ren-c/commit/f25087c0bbfbcef7fc6f71cb53fe69b16527b1d7" rel="nofollow noopener"><strong>Yep, they're implemented!!!</strong></a>  Go try them out!!!</p>
<hr>
<p>Years ago, discussions circled around what was so special about WORD! and PATH! that they should be the only ones with LIT-XXX! forms.  It seemed this was a bit that could equally apply to anything, e.g. <strong><code>group: '(1 + 2)</code></strong>.</p>
<p>It took a while, but eventually a <a href="https://forum.rebol.info/t/quoted-arrives-formerly-known-as-lit-bit/995/2">general and clever solution was discovered</a>.  There's no LIT-XXX!, just QUOTED! as a container for any type...with any level of quoting.  It's done with neat tricks!</p>
<h2>...but what about SET-XXX and GET-XXX?</h2>
<p>In that same vein, we might ask why PATH! and WORD! are the only types with SET-XXX! and GET-XXX! forms.  Aren't those just bits too?</p>
<p>GET-BLOCK! seems very useful if it would do a REDUCE in the evaluator.  Instead of <strong>return reduce [x y]</strong> you could just say <strong>return :[x y]</strong>.  SET-GROUP seems like it might be a little tidier too...</p>
<pre><code>word: 'x
set word 1020

word: 'x
(word): 1020
</code></pre>
<p>It's only one less <em>character</em>.  But whether you have a preference for one or the other visually, the second can be done faster; the evaluator doesn't have to look up SET to find the function, nor go through the trouble of filling function frames and dispatching.  It's much lighter-weight.</p>
<h2>Yet it seems a slippery slope...</h2>
<p>GET-BLOCK! and SET-GROUP! sure seem useful, but if we look at this as more cases of the "lit bit", where does it stop?</p>
<p>If every type has a "get bit" and a "set bit", can you have both of them?  How does this mix with the LIT-XXX forms?  Is there a difference between a LIT-SET-PATH! and a SET-LIT-PATH?</p>
<p>What would a SET-URL! look like?  How are the colons mixing up with literals that have colons in them?  <em>(:15 is a TIME! in the current world..., that would become a GET-INTEGER!, so what does a GET-TIME! look like?)</em></p>
<p>This foiled ideas of the past, like trying to get rid of SET-PATH! and GET-PATH! and just say, e.g. "a SET-PATH! is one with a SET-WORD! in its last slot".  Because then to get <strong>x/1:</strong> you would need SET-INTEGER!, to get <strong>x/(y + z):</strong> you'd need SET-GROUP!, and it just seemed to go to chaos.</p>
<p>In the absence of a clear plan, we plodded along with the status quo, awaiting some moment of clarity.</p>
<h2>Moment of clarity arrived: Just add BLOCK! and GROUP!</h2>
<p>If we only allow SET and GET forms on containers, it's a clean model (no worries about intersecting with lexical rules of the contained types).  And you get your dialected parts.  Need a SET-INTEGER! ?  Well, you <a href="https://knowyourmeme.com/memes/sites/cheezburger" rel="nofollow noopener">no can has</a>.  But with containers, you get it all:</p>
<pre><code> my-dialect [
     [1]: "It's just as good, as `1:`, really!"

     :(:15) "Even better, as if you want GET-FIFTEEN-MINUTES!, you can have it..."

     [http://example.com/colons-legal-in-url:]: "Yup, colons are legal in URL!s"

     (your multi-value expression here): "goes great with expressions!"
 ]
</code></pre>
<p><em>Then we stop.</em>  We get 4 new parts that are genuinely useful, that make the evaluator more expressive and run common functionality faster.  If you find uses in your dialects--and you almost certainly will--so much the better.</p>
<h2>The commit for them fixes flaws in the scanner</h2>
<p>There were some things you couldn't make.  In Rebol2/R3-Alpha/Red:</p>
<pre><code>rebol2&gt;&gt; first [:a/(b + c)]                       
== a/(b + c):

rebol2&gt;&gt; first [:(a + b)/c]
** Syntax error: invalid "word-get" -- ":"
</code></pre>
<p>It might seem like it wouldn't be that hard to fix, but fixing it is a lot easier if you can just pass through a moment where the head of that block is a GET-GROUP! and then twiddle it into a regular GROUP! later.  (That's how GET-PATH! works when it has a GET-WORD!-looking thing at the head).  The scanner is already rather fiddly and throwing in more fiddly-bits is not forward-looking.</p>
<p>This lets that work basically for free, just a minor tweak on the previous method:</p>
<pre><code>&gt;&gt; first [:(a + b)/c]
== :(a + b)/c

&gt;&gt; type of p: first [:(a + b)/c]
== get-path!

type of first p
== group!  ;-- regular GROUP! as first element of GET-PATH!, perfect
</code></pre>
<h2>They're awesome, you'll love 'em</h2>
<p>Try them out and let me know what you think, and if you find cool new dialect applications!  Some demos:</p>
<pre><code>; GET-BLOCK!, doing a fast REDUCE
&gt;&gt; a: 10
&gt;&gt; b: 20
&gt;&gt; :[a b]
== [10 20]

; GET-GROUP!, getting a PATH!
&gt;&gt; o: make object! [f: 304]
&gt;&gt; path: 'o/f
&gt;&gt; :(path)
== 304

; SET-GROUP!, setting a BLOCK!
&gt;&gt; m: &lt;before&gt;
&gt;&gt; o: make object! [f: &lt;before&gt;]
&gt;&gt; block: [m o/f]
&gt;&gt; (block): [1020 304]
&gt;&gt; block
== [m o/f]
&gt;&gt; m
== 1020
&gt;&gt; o/f
== 304

; SET-BLOCK!, with a block on the right
&gt;&gt; a: _ b: _
&gt;&gt; [a b]: [10 20]
&gt;&gt; a
== 10
&gt;&gt; b
== 20

; SET-BLOCK! with a non-block on the right
&gt;&gt; a: _
&gt;&gt; b: _
&gt;&gt; [a b]: &lt;thing&gt;
&gt;&gt; a
== &lt;thing&gt;
&gt;&gt; b
== &lt;thing&gt;
</code></pre>
<p>I'm sure people will think of improvements, but that's for starters.</p>
<p>And note they'll get even better with <a href="https://forum.rebol.info/t/mirrored-type-bytes-explained/1008">mirror bytes</a>, where <strong>(x):</strong> won't cost any more than <strong>x:</strong> !!!  I'm relatively confident I can make that happen, some groundwork is done already.</p>
            <p><small>7 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/you-can-has-get-block-set-block-get-group-set-group/1032">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/you-can-has-get-block-set-block-get-group-set-group/1032</link>
          <pubDate>Thu, 24 Jan 2019 03:36:41 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1032</guid>
          <source url="https://forum.rebol.info/t/you-can-has-get-block-set-block-get-group-set-group/1032.rss">You can has GET-BLOCK! (SET-BLOCK!, GET-GROUP!, SET-GROUP!)</source>
        </item>
        <item>
          <title>Soft Quoted Branching: Light, Elegant, Fast</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>It's uncommon to use expressions that evaluate to branches passed to conditionals.  And when you do use one, you probably don't mind putting it in a GROUP! (especially considering that 99% of the time in the <em>far</em> more common cases you were willing to put it in a BLOCK!).</p>
<p>So Ren-C now uses that fact--plus generalized quoting--to allow for a briefer and faster way to evaluate to literals in your conditionals:</p>
<pre><code>&gt;&gt; if true '[block as data]
== [block as data]
</code></pre>
<p>Simply pass in a QUOTED! item of any kind, and that item will be what a branch evaluates to.  It will be one less level of quoting than what you pass in:</p>
<pre><code>&gt;&gt; if true '&lt;tag&gt;
== &lt;tag&gt;
</code></pre>
<p>Previous attempts to get something like this used an /ONLY refinement.  But this lets you mix and match in the same operator, as opposed to switching the operator into a "mode":</p>
<pre><code>&gt;&gt; either true '[1 + 2] [1 + 2]
== [1 + 2]

&gt;&gt; either false '[1 + 2] [1 + 2]
== 3
</code></pre>
<h2>It Solves Some Problems for CASE</h2>
<p>Historically, CASE was more lax in accepting types than the corresponding IFs would be:</p>
<pre><code>&gt;&gt; case [1 = 1 &lt;foo&gt;]
== &lt;foo&gt;
</code></pre>
<p>It would allow the by-products of arbitrary evaluation to be used:</p>
<pre><code>&gt;&gt; word: &lt;foo&gt;
&gt;&gt; case [1 = 1 word]
== &lt;foo&gt;
</code></pre>
<p>Sometimes this resulted in double-evaluation:</p>
<pre><code>&gt;&gt; word: [print "surprise"]
&gt;&gt; case [1 = 1 word]
surprise
== true
</code></pre>
<p>The dodgy nature of this "may be a double evaluation, may be not" with no way to tell at source level raised some concerns, which are laid out in the <a href="https://forum.rebol.info/t/backpedaling-on-non-block-branches/476">"backpedaling on non-block branches"</a> post.</p>
<p>The combination of soft quoting and generalized quoting lets the same patterns that work for IF work in CASE.  It lowers the risks in a legible way:</p>
<pre><code>&gt;&gt; case [1 = 1 '&lt;foo&gt;]
== &lt;foo&gt;
</code></pre>
<h2>It's Faster and More Efficient</h2>
<p>Quoting of up to three levels can be done a cell in place.  So <strong>'[x]</strong> costs less storage (and has better locality with the surrounding cells) than <strong>[[x]]</strong>.</p>
<p>Outside of the reduced storage, it's also lighter on the evaluator.</p>
<h2>The consequences</h2>
<p>There were very few pieces of code in the Ren-C repo that were affected.  One was a help test.  It wanted to generate a real-world block to run, and didn't want to call DO for some reason:</p>
<pre><code>for-each w words of lib [
    dump w
    if not set? w [continue]
    if action? get w
        compose [help (w)]   ; errors now...IF thinks the COMPOSE word! is branch
    else [
        help (get w)
    ]
]
</code></pre>
<p>It's easy enough to change that to <code>(compose [help (w)])</code>...this kind of usage is very rare.</p>
<p>The one common case of passing code to a conditional originated from Ren-C...the use of lambdas that could take the argument of what drove the conditional:</p>
<pre><code> trap [1 / 0] then error =&gt; [print [error]]
</code></pre>
<p>So you have to put it in a GROUP!:</p>
<pre><code> trap [1 / 0] then (error =&gt; [print [error]])
</code></pre>
<p>I'm pretty sure this can be rethought to work as before, given the strategy of "right quoting always wins".  But the evaluator has some kind of strict horse-blinder rules that guide its design, so not all things are possible.  We'll see.</p>
<blockquote>
<p><strong>UPDATE 2020</strong>: The required rules have been implemented, and hard quoted left parameters on the right win in this instance, so the group is not necessary.  <img src="https://forum.rebol.info/images/emoji/twitter/sushi.png?v=9" title=":sushi:" class="emoji" alt=":sushi:"></p>
</blockquote>
<p>Even if it couldn't get fixed, in the scheme of things it's worth it.  And it isn't like people aren't used to putting branches in delimiters for blocks anyway!</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/soft-quoted-branching-light-elegant-fast/1020">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/soft-quoted-branching-light-elegant-fast/1020</link>
          <pubDate>Fri, 18 Jan 2019 12:56:02 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1020</guid>
          <source url="https://forum.rebol.info/t/soft-quoted-branching-light-elegant-fast/1020.rss">Soft Quoted Branching: Light, Elegant, Fast</source>
        </item>
        <item>
          <title>&lt;skip&gt;-able Arguments</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>A <strong><code>&lt;skip&gt;</code></strong> parameter is one where instead of getting a type error on a mismatch, it will set the parameter to null:</p>
<pre><code> foo: function [a :b [&lt;skip&gt; tag!] c] [
     dump [a b c]
 ]

 &gt;&gt; foo 1 2
 a: 1
 b: ; null
 c: 2

 &gt;&gt; foo 1 &lt;hello&gt; 2
 a: 1
 b: &lt;hello&gt;
 c: 2
</code></pre>
<p>You can only skip a "hard quoted" parameter.  To understand why, imagine a having an evaluative skippable parameter followed by a quoted argument.  If you evaluate the first argument--see it doesn't match the type--you can't really rewind time to then switch into a quoting mode for the second argument on the thing you already evaluated.  It would be incoherent.</p>
<p>Beyond the technical reason you don't want <code>&lt;skip&gt;</code> on evaluated parameters, it also makes it clearer to the user.  For instance, consider <a href="https://forum.rebol.info/t/tag-compose-is-it-tag-specific-composition/979/7">tagged compose</a>:</p>
<pre><code>&gt;&gt; compose &lt;*&gt; [(1 + 2) (&lt;*&gt; 1 + 2) (1 + 2)]
== [(1 + 2) 3 (1 + 2)]
</code></pre>
<p>You can tell at the source level that's tagged.  But what if it said:</p>
<pre><code>&gt;&gt; compose foo [(1 + 2) (&lt;*&gt; 1 + 2) (1 + 2)]
== ???
</code></pre>
<p>Does this mean that sometimes the block is taken by the compose and sometimes it's not?  What if FOO is a block?  The "shape" of the code changes, and that seems bad.</p>
<p>So it's for quoted arguments only...and that's probably for the best.</p>
<h2>It's used by DEFAULT</h2>
<p>The use in tagged compose is pretty obvious.  But a trickier usage is DEFAULT, which quotes a SET-WORD! or SET-PATH! on its left to assign to it:</p>
<pre><code> &gt;&gt; x: null

 &gt;&gt; x: default [print "running" 1 + 2]
 running
 == 3  ; didn't have a value, so ran the body and assigned

 &gt;&gt; x: default [print "not run!" 10 + 20]
 == 3  ; already had a value, don't run the block and leave alone
</code></pre>
<p>The trick skippability brings to the table is that if there is no SET-WORD! or SET-PATH!, then it just runs the block.  This makes it a nice tool in evaluative switch/case:</p>
<pre><code> &gt;&gt; case [
     1 &gt; 2 [print "nope" 10]
     default [print "yep!" 20]
 ]
 yep
 == 20
</code></pre>
<p>CASE and SWITCH are written to just let the last value fall out of them.</p>
<pre><code> &gt;&gt; switch "not a number" [
      1 + 2 [...]
      3 + 4 [...]
      5 + 6
 ]
 == 11
</code></pre>
<p>So all DEFAULT does is fall back to acting like DO when it can't find a SET-WORD! or SET-PATH! to its left.</p>
<pre><code> &gt;&gt; switch "not a number" [
      1 + 2 [...]
      3 + 4 [...]
      default [5 + 6]
 ]
 == 11
</code></pre>
<p>It comes off as quite readable.  <em>(Though if you are lazy, or code golfing, you can just omit it...maybe some people will like that better.)</em></p>
<h2>The implementation is now solid, so this feature is sticking around</h2>
<p>The initial implementation was a bit creaky, especially when it came to skipping left hand side arguments.  I was worried it might not be able to work efficiently--or maybe it wasn't able to work in a general way at all!</p>
<p>But things have firmed up very well.  Impressively enough, this works:</p>
<pre><code>&gt;&gt; foo: function [/a :/b [&lt;skip&gt; integer!]] [
    reduce [(a else [&lt;null&gt;]) (b else [&lt;null&gt;])]
]

&gt;&gt; foob: enfix :foo/b

&gt;&gt; parameters of :foob
== [:b /a]

&gt;&gt; 10 foob
== [&lt;null&gt; 10]

&gt;&gt; "not an integer!" foob
== [&lt;null&gt; &lt;null&gt;]

&gt;&gt; 10 -&gt; foob/a 20
== [20 10]  ; (note: broken at last check, looking into it)
</code></pre>
<p>And we can discuss what <code>("not an integer!" -&gt; foob/a 20)</code> should do, <a href="https://github.com/metaeducation/ren-c/issues/909" rel="nofollow noopener">if that should be an error or not</a>.</p>
<p>Anyway, FYI, that's a pretty wild case.  If it can do that, it can probably work for whatever you want it to do.  So start thinking of creative uses of <code>&lt;skip&gt;</code> in your own code...and if you do, post it in the thread here!</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/skip-able-arguments/1013">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/skip-able-arguments/1013</link>
          <pubDate>Mon, 14 Jan 2019 05:34:06 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1013</guid>
          <source url="https://forum.rebol.info/t/skip-able-arguments/1013.rss">&lt;skip&gt;-able Arguments</source>
        </item>
        <item>
          <title>Time to Meet Your MATCH... (...dialect)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p><strong>MATCH</strong> is a handy tool for testing a value against some basic rules, and passing it through if they match...or evaluating to null if they don't.  The rules can be combined in some interesting ways that make them rather powerful!</p>
<p>It uses the <em>"match dialect"</em>.  This looks pretty simple on the surface, like what you put in a function spec block for the legal types:</p>
<pre><code>&gt;&gt; match [integer! tag!] 1020
== 1020

&gt;&gt; match [integer! tag!] "this text value won't match"
;-- null

&gt;&gt; match [integer! tag!] &lt;matches!&gt;
== &lt;matches!&gt;
</code></pre>
<p>But with the new features of generalized quoting, now you can test for quotedness.</p>
<pre><code>&gt;&gt; match ['word!] first [foo]
;-- null

&gt;&gt; match ['word!] first ['foo]
== 'foo
</code></pre>
<p>It actually dereferences what you give it and sums up the quote levels.  So you can do things like:</p>
<pre><code> &gt;&gt; quoted-word!: quote word! ;-- Note: during transition, QUOTE is called UNEVAL

 &gt;&gt; match 'quoted-word! first [''foo]
 == ''foo
</code></pre>
<p>So since there is a quote level in the QUOTED-WORD! value, that gets added in with the quote on the match, so it looks for a doubly quoted value.</p>
<p>The premise is that each MATCH rule component is one item, and even types like INTEGER! are used...to test a length:</p>
<pre><code> &gt;&gt; match 2 [a b]
 == [a b]

 &gt;&gt; match 2 [a b c]
 ;-- null
</code></pre>
<p>You can use single arity ACTION!s as well, if you use a GET-WORD! or GET-PATH! to indicate them:</p>
<pre><code> &gt;&gt; match :odd? 304
 ;-- null

 &gt;&gt; match :lib/even? 1020
 == 1020
</code></pre>
<h2>BLOCK! will OR rules together, PATH! will AND them</h2>
<p>So this is a cool little trick:</p>
<pre><code>&gt;&gt; match block!/2 [a b]
== [a b]

&gt;&gt; match text!/2 [a b]
;-- null

&gt;&gt; match text!/2 "ab"
== "ab"

&gt;&gt; match [block! text!]/2 "ab"
== "ab"

&gt;&gt; match '''[block! text!]/2 lit '''[a b]
== '''[a b]

&gt;&gt; match [integer!/[:even?] block!/[:empty?]] []
== []

&gt;&gt; match [integer!/[:even?] block!/[:empty?]] 1020
== 1020
</code></pre>
<p>Pretty cool huh?  And as I mentioned, you can factor these rules out like in PARSE... note also that instead of :empty? you can just use 0.</p>
<pre><code> &gt;&gt; even-int!: lit integer!/[:even?]
 &gt;&gt; empty-block!: lit block!/0

 &gt;&gt; match [even-int! empty-block!] []
 == []

 &gt;&gt; match [even-int! empty-block!] [a b]
 ;-- null 
</code></pre>
<h2>MATCH has an automatic erroring form, called ENSURE</h2>
<p>If you want a quick and dirty way to typecheck something and pass it through, but error otherwise, use ENSURE.</p>
<pre><code>&gt;&gt; ensure [even-int! empty-block!] [a b]
** Script Error: ...

&gt;&gt; ensure [even-int! empty-block!] 1020
== 1020
</code></pre>
<h2>MATCH is now built in as a PARSE keyword...</h2>
<p>The quoting features of MATCH were important for PARSE to help pick up the slack after LIT-WORD!.</p>
<pre><code>&gt;&gt; did parse ['a b 'c d] [some [match [word! 'word!]] end]
== #[true]
</code></pre>
<p>There was a little bit of a incongruity previously, which is that MATCH did not want to quote its first argument.  So you couldn't say <strong>match 'word! lit ['foo]</strong> and have it match, because the evaluator would strip off the quote.  When all things were considered, it seemed to make more sense to have MATCH soft-quote its first argument, so it doesn't throw away the quote marks...but uses them in the rule.</p>
<p>PARSE then has a compatible expression, without a block! needed:</p>
<pre><code>&gt;&gt; did parse ['a 'b 'c 'd] [some [match 'word!] end]
== #[true]
</code></pre>
<h2>
<code>&lt;opt&gt;</code>, falsey values, and /ELSE</h2>
<p>You might imagine a lot of code wants to say <strong>if match [...] whatever [...]</strong>.  This could lead to unsatisfactory results if the thing you're matching is a null, blank, or logic false -- even though you matched, the falsey nature of the thing you were testing would foil your intent.</p>
<p>To help catch those errors, any falsey input that matches will be voidified.  So at least you'll get a clear error if you used the result.  But since voids are values, you'll be okay if you use THEN or ELSE</p>
<pre><code>&gt;&gt; match [&lt;opt&gt; integer!] null then [print "matched, and void cued then!"]
matched, and void cued then!
</code></pre>
<p>There's also an /ELSE refinement, so you can provide a branch of code to run if there's no match...and it won't mutate the result at all:</p>
<pre><code>&gt;&gt; match/else [&lt;opt&gt; integer!] null [print "didn't match" 100]
;-- null

&gt;&gt; match/else [&lt;opt&gt; integer!] #foo [print "didn't match" 100]
didn't match
== 100
</code></pre>
<h2>Useful Dialect, Good Testbed for PATH!s</h2>
<p>You can see a detail above of how I want to use things like <strong>:even?</strong> as a test, and then use PATH! for AND-ing tests together generically.  But then, <strong>:even?/integer!</strong> is a GET-PATH!, while <strong>integer!/:even?</strong> would be an ordinary path.  The meaning gets confuzzled... how would you specify a function with refinements, or otherwise get something out of a path?</p>
<pre><code>obj: make object! [even-int: lit integer!/[:even?]]
match :obj/even-int 4
</code></pre>
<p>To get this distinction, we have to treat <strong>:[:obj]/even-int</strong> differently from <strong>:obj/even-int</strong>.  And this really does suggest to me that the notion of allowing GET-WORD!s, SET-WORD!s, and LIT-WORD!s in PATH! is a mistake...it doesn't generalize and will fall down at the head and tail.  Even when it works, it's ugly.</p>
<p>I think this is going in the direction of making PATH! a stronger dialecting part.  And hopefully, with more good examples we can keep pushing on some of the other things (like "does Rebol need a date format with slashes in it, and if so can it be accomplished naturally as a PATH!")...</p>
            <p><small>5 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/time-to-meet-your-match-dialect/1009">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/time-to-meet-your-match-dialect/1009</link>
          <pubDate>Fri, 11 Jan 2019 08:59:23 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1009</guid>
          <source url="https://forum.rebol.info/t/time-to-meet-your-match-dialect/1009.rss">Time to Meet Your MATCH... (...dialect)</source>
        </item>
        <item>
          <title>QUOTED! arrives (formerly known as &quot;lit bit&quot;)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>I'm pleased to say that the day has come that you can use apostrophe to escape any value...not just WORD! and PATH!.  And since I said <em>any</em> value, that means you can also quote <em>quoted values</em>...as deeply as you like!</p>
<pre><code>&gt;&gt; '(1 + 2)
== (1 + 2)

&gt;&gt; ''(1 + 2)
== '(1 + 2)

&gt;&gt; quoted? first [''{double quoted text!}]
== #[true]

&gt;&gt; quotes of first ['''''''''''''''''&lt;whoa!&gt;]
== 17
</code></pre>
<p>It opens up a whole new box of parts for dialecting, and makes your every day code shorter and clearer (when used properly).  <em>But don't be fooled by the fact that you can use a stupid number of quotes if you need:</em> <strong>This isn't a frivolous thing, and being able to truly escape any value--hence including any quoted value--is integral to the feature.</strong></p>
<p>If you are a heavy user of COMPOSE-ing code and then DO-ing it, you would be more likely to appreciate the efficiency and literacy of:</p>
<pre><code> do compose [... some-var: '(foo) ...]
</code></pre>
<p>But what you realize if you program at the API level (like C or JavaScript) is that <em>every execution acts like "a do of a COMPOSE".</em>  Since API representations of values spliced in from non-Rebol code are not fetched through a WORD!, libRebol users wind up putting "QUOTE" (now LIT) calls <em>everywhere</em>--slowing things down, junking it up, and fundamentally changing the types and shape of what you're working with.  If you write sophisticated enough Rebol routines you've almost certainly run up against this problem too--but it's an issue on nearly <em>every</em> call into the API.</p>
<p>The quoting implementation is optimized to the point of being nearly free for depths less than 4, using something I call <em>"in-situ escaping"</em>.  Because of how I've made the C++ build check it at compile time, it significantly reduces the risks of such a tricky performance hack.  Another very neat design point allows these new "QUOTED!s" to efficiently participate in binding...if their "contained" item is bindable.</p>
<h2>Be warned, this is a radical change!</h2>
<p>I'm sure you'll love it when all is said and done.  But it changes the typeclass membership of LIT-WORD! and LIT-PATH!.  They are no longer ANY-WORD! or ANY-PATH!, but instances of a new fully generalized quoted type.  This will cause some speedbumps.</p>
<p>Long term, you wouldn't expect to see the terms "LIT-WORD!" and "LIT-PATH!".  Instead you would use <strong><code>'word!</code></strong> or <strong><code>'path!</code></strong>, or something that fits into a more general scheme.  <strong>But I've tried a good faith effort to get a smattering of compatible behaviors</strong>, which were able to wedge things in to keep them about as compatible as could be expected.  More will be needed, so let me know.</p>
<p>For one thing, LIT-WORD! and LIT-PATH! are temporarily PARSE keywords.  If you have a parse rule that previously worked with ANY-WORD! or ANY-PATH! or something of the sort, and you need to keep it working, PARSE recognizes these two explicitly.  So put them in an alternates list:</p>
<pre><code> parse ['foo 'foo/bar] [[any-word! | lit-word!] [any-path! | lit-path!]]
</code></pre>
<p>In addition to being defined as parse keywords for that purpose, they are variables whose values hold the quoted datatypes that you'd get answers from TYPE OF for:</p>
<pre><code> &gt;&gt; lit-word! = type of first ['x]
 == #[true]
</code></pre>
<p>LIT-WORD? and LIT-PATH? are defined as well, along with TO-LIT-WORD and TO-LIT-PATH.  Hopefully time and experience will give us ideas for how to do all these things better.</p>
<p>Generic type testing in action specs for quoted types isn't implemented.  R3-Alpha only had 64 bits for datatypes, and there's an infinity of potential quotes you might be interested in.  So there's just the one type for now--QUOTED!.  You have to check what's in the quoted container after the call.  (It's kind of how you can't ask to get "just a block of INTEGER!" today, only say BLOCK! and then check it.)</p>
<p>But for compatibility there is a trick.  If you put <strong>'word!</strong> or <strong>'path!</strong> in your type spec (or LIT-WORD! or LIT-PATH! which evaluate to that), <em>just those two</em> can still be type checked by the system.  For all other types, you have to just take a QUOTED! value, and examine yourself in the function body.  This will be improved eventually, as type checking would have to grow up someday from the 64-bit limit...so quoting will be one of the things that factors into that design.</p>
<p>Since you could do things like GET on a LIT-WORD!, or APPEND to a LIT-PATH!, I've tried to set up some mechanisms for the cases I thought of.  I even threw in some new weirder ones, like letting you add directly to a quoted integer and get a quoted integer at the same level back:</p>
<pre><code> &gt;&gt; add lit '''''1 2
 == '''''3
</code></pre>
<p>I didn't see a good general rule for this.  It seems FIND on a quoted BLOCK! should return a position in the quoted block that is still quoted.  But SELECTing or PICKing a value out of the block should ignore the container's quoting.  It just seems like it has to be done on a case-by-case basis, for the semantics that make sense for the operation.</p>
<h2>Basic Mechanics</h2>
<p>When you ask the value for its <em>type</em>, the base type will itself be quoted with the level of depth of the value:</p>
<pre><code>&gt;&gt; type of first [''(1 + 2)]
== ''integer!
</code></pre>
<p>To get the number of quote levels, use QUOTES OF.  To get rid of any quoting present on any value, use DEQUOTE.</p>
<pre><code>&gt;&gt; quotes of first ['''{triply quoted string}]
== 3

&gt;&gt; dequote first ['''&lt;some-tag&gt;]
== &lt;some-tag&gt;
</code></pre>
<p>All that happens with multiply quoted types is that each time the evaluator sees it, it will peel off one quote level:</p>
<pre><code> &gt;&gt; ''(1 + 2)
 == '(1 + 2)

 &gt;&gt; '(1 + 2)
 == (1 + 2)

 &gt;&gt; (1 + 2)
 == 3
</code></pre>
<p>This means inert types which are singly quoted get evaluated and lose the distinction from the plain inert type.  So if you have a function that takes an evaluated argument (e.g. foo: func [x] [...]) you can't provide special behavior for <strong><code>foo '[block]</code></strong> that is different from <strong><code>foo [block]</code></strong>.  The only way a called function will see the bit is if it quotes the argument, or if it's inside a dialect block (like a PARSE rule).</p>
<p>You can, however, get special behavior for <strong><code>foo ''[block]</code></strong>, as it will receive a singly quoted block as an argument.  And of course, it's now more practical to escape GROUP!s, so it might be worth it to start defining distinct behavior when groups are used since they'll be so easy to pass!  (I have some ideas about this.)</p>
<h3>Name Switcheroo: LIT &lt;=&gt; QUOTE</h3>
<p>I explained in another post that <strong><code>1</code></strong> is a <em>literal</em> integer, while <strong><code>'1</code></strong> is a <em>quoted</em> integer.  So who knew: we've been using the terms LIT-WORD! and LIT-PATH! wrong all this time!</p>
<p>So in the new world, when you write something like <strong>literal x</strong> that should give you back <strong>x</strong>... a "literal word".</p>
<p>In the transitional period, I haven't redefined QUOTE yet.  This should help you find existing places where you used it, and either change to LIT or just use apostrophe, as you can now do it for any type.</p>
<p>When QUOTE does make a comeback, it will add a quoting level to whatever it gets as an argument, with that argument being evaluated normally:</p>
<pre><code> &gt;&gt; x: 1
 == 1

 &gt;&gt; quote x
 == '1

 &gt;&gt; lit x
 == x
</code></pre>
<p>But until it comes back, this functionality is given by a function called UNEVAL.  Don't get attached to that name...it'll just be renamed when the time comes.</p>
<p>Having a shorter way of getting literals without generalized quoting makes me feel better about apostrophe. <strong><code>if word = 'isn't [...]</code></strong> was an example of that made me unhappy, and <strong><code>if word = lit isn't [...]</code></strong> is tighter than <strong><code>if word = quote isn't [...]</code></strong>.  So in addition to being more terminologically correct, it looks better.</p>
<h2>QUOTE in PARSE is a synonym for LIT for the time being</h2>
<p>Due to some annoying bootstrap issues, we can't update QUOTE in parse right away.  But start migrating to LIT.  (The full word LITERAL is also a keyword synonym...but is this necessary?)</p>
<p>You can use the rule <strong>((uneval x))</strong> for what will ultimately be expressible as <strong>quote x</strong> when that time comes.</p>
<h2>MATCH added to PARSE for quoted types.</h2>
<p>There's some troubles that we'll have to work out related to whenever something wanted to use DATAYPE! behavior to mean "match value of <em>instance</em> of datatype" vs. "match datatype itself".  Using quoted datatypes to represent quoted instances runs afoul of the fact that you might want to do either thing.</p>
<p>My gut tells me we don't want to investing in a DATATYPE!-specific field which encodes its quotedness, that's distinct from quoting itself.  That just seems too complex for its own good.</p>
<p>As an example of a simpler way of thinking about it, I've expanded MATCH to work with quoted types:</p>
<pre><code>&gt;&gt; match [''integer!] (first [''2])
== ''2
</code></pre>
<p>Then, MATCH is also available as a PARSE keyword.</p>
<pre><code>&gt;&gt; did parse [1 '2 ''3] [some [match [integer! 'integer! ''integer!]] end]
== #[true]
</code></pre>
<p><a href="https://forum.rebol.info/t/time-to-meet-your-match-dialect/1009">You can read more about MATCH here.</a></p>
<p>Hopefully this will be enough to get started using generalized quoting, and we'll learn as we go.</p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/quoted-arrives-formerly-known-as-lit-bit/995">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/quoted-arrives-formerly-known-as-lit-bit/995</link>
          <pubDate>Fri, 04 Jan 2019 08:23:46 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-995</guid>
          <source url="https://forum.rebol.info/t/quoted-arrives-formerly-known-as-lit-bit/995.rss">QUOTED! arrives (formerly known as &quot;lit bit&quot;)</source>
        </item>
        <item>
          <title>TAG! - COMPOSE is IT (tag-specific composition)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>There's a <a href="https://forum.rebol.info/t/quoted-arrives-formerly-known-as-lit-bit/995">new mechanism now</a> for escaping GROUP!s in your code that you want preserved during a COMPOSE.  Just use an apostrophe:</p>
<pre><code> &gt;&gt; compose [(1 + 2) '(1 + 2) ''(1 + 2)]
 == [3 (1 + 2) '(1 + 2)]
</code></pre>
<p>If you're doing more substitutions than not, you may appreciate being able to mark the occasional GROUP! with the backslash as a "do not compose" indicator.</p>
<p>But one of the good things about templating is to be able to write most of your code normally, and then point out just the parts you want to substitute.  So if you're using so many groups that just being in a GROUP! isn't distinguishing what you want to substitute, <strong>tagged COMPOSE</strong> to the rescue:</p>
<pre><code>&gt;&gt; compose &lt;*&gt; [(1 + 2) (&lt;*&gt; 1 + 2) (1 + 2)]
== [(1 + 2) 3 (1 + 2)]
</code></pre>
<p>The TAG! has to be given literally between the COMPOSE and the expression you want to compose.  (This is a requirement for <code>&lt;skip&gt;</code>-ability.  But you can pick any tag you like.  Currently it is matched case-sensitively.</p>
<p>Doubled-groups still have /ONLY semantics:</p>
<pre><code> &gt;&gt; x: [a b c]

 &gt;&gt; compose &lt;$&gt; [(1 + 2) (&lt;$&gt; reverse copy x) ((&lt;$&gt; reverse copy x)) ((1 + 2))]
 == [(1 + 2) c b a [c b a] ((1 + 2))]
</code></pre>
<p>You don't have to use symbols...any tag will do.  Could be a whole word with meaningful names, which might be valuable if you were doing it in several steps...where earlier phases could leave tags for later phases to compose.  You might also tag with numbers, <code>&lt;1&gt;</code> <code>&lt;2&gt;</code>...</p>
<p>For now this is limited to just TAG!.  It could be other inert types (like ISSUE! or TEXT!) but there doesn't seem to be a great reason to encourage that.</p>
            <p><small>6 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/tag-compose-is-it-tag-specific-composition/979">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/tag-compose-is-it-tag-specific-composition/979</link>
          <pubDate>Thu, 27 Dec 2018 08:01:33 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-979</guid>
          <source url="https://forum.rebol.info/t/tag-compose-is-it-tag-specific-composition/979.rss">TAG! - COMPOSE is IT (tag-specific composition)</source>
        </item>
        <item>
          <title>GET-GROUP!s in PARSE mean &quot;execute and splice as rule&quot;</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>There's efficiency to be gained when you compose your parse rules ahead of time.  But what if the rule depends on other things, and you want to generate a rule to splice in that gets composed in <em>every time it's run</em>?</p>
<pre><code>&gt;&gt; num: 1
&gt;&gt; char: #"a"
&gt;&gt; did parse ["a" "bb" "ccc"] [
      some [
          into [:(
              rule: reduce [num char]
              num: num + 1
              char: char + 1
              rule
          )]
     ] end
  ]
== #[true]
</code></pre>
<p><em>(Note: You shouldn't need the block outside the GET-GROUP! for the INTO, but at the moment INTO isn't aware of these get groups in its immediate argument...so they have to go in a block rule.  It will be updated to recognize them directly.)</em></p>
<p>If the expression inside the GET-GROUP! evaluates to a null, it splices nothing into the rule stream.  With so many null-signaling routines to choose from, that's rather cool.</p>
<pre><code>&gt;&gt; did parse "aaabbbcccddd" [
      some "a"
      :(case [1 &gt; 2 [[some "x"]] 4 &gt; 3 [[some "b"]]])
      some "c"
      :(switch 1 + 2 [
          4 [[some "z"]] 3 + 2 [[some "q"]]
      ])
      some "d"
      end
   ]
== #[true]
</code></pre>
<p>Though you can return BLOCK! rules to splice, you can also just return single WORD!s.  At the moment, returning a <strong><code>|</code></strong> is disabled, though that might be relaxed based on feedback and allowed to mean "skip to next rule" (but clearly this is going to be different from a <strong><code>|</code></strong> in the source, as being literally in the source is a prerequisite to participating in the skipping.)</p>
            <p><small>16 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/get-group-s-in-parse-mean-execute-and-splice-as-rule/968">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/get-group-s-in-parse-mean-execute-and-splice-as-rule/968</link>
          <pubDate>Thu, 20 Dec 2018 05:19:34 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-968</guid>
          <source url="https://forum.rebol.info/t/get-group-s-in-parse-mean-execute-and-splice-as-rule/968.rss">GET-GROUP!s in PARSE mean &quot;execute and splice as rule&quot;</source>
        </item>
        <item>
          <title>You only get...ONESHOT</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>ONESHOT is a cool new function generator, which makes a DO-like function which holds state to run only once.</p>
<pre><code>once: oneshot
for-each x [10 20 30] [
     once [print ["loop begins with" x]]
     print [x]
]
</code></pre>
<p>And that will give you:</p>
<pre><code>loop begins with 10
10
20
30
</code></pre>
<p>So although ONCE was called for each step in the loop, it only ran what it was given one time.  Unlike code that is run before the loop, it has access to the first element.  <em>(If BREAK and CONTINUE were "definitional", it would also be able to modify them just once in the loop...which will likely be a relevant thing in the near future.)</em></p>
<p>It's obviously not anything you couldn't do with declaring a LOGIC! and putting in the test-and-flip code.  But it's shorter.  And unlike wrapping that logic up in a helper function, this lets the code that you're controlling <em>change</em>, so if one of the cases runs, the other case (with differing code) won't run.</p>
<p>Plus, ONESHOT will "voidify" the evaluative result of what it's given--like a conditional would.  So NULL will always mean it didn't run the code you gave it.  So for instance, this means that for every time but the first, you could respond to it with an ELSE.</p>
<pre><code>once: oneshot
for-each x [10 20 30] [
     once [print ["first:" x]] else [print ["rest:" x]]
]
</code></pre>
<p>That gives you:</p>
<pre><code>first: 10
rest: 20
rest: 30
</code></pre>
<p>ONESHOT is actually a specialization of N-SHOT, which lets you specifiy a generic N.  If that N is negative, then it will actually <em>not</em> run the code you give it N times before it starts running it.</p>
<pre><code>&gt;&gt; anti: n-shot -2

&gt;&gt; anti [5 + 5]
// null

&gt;&gt; anti [6 + 6]
// null

&gt;&gt; anti [7 + 7]
== 14

&gt;&gt; anti [8 + 8]
== 16
</code></pre>
<p><a class="mention" href="/u/markeye">@MarkEye</a>/<a class="mention" href="/u/mark-hi">@Mark-hi</a> suggested UPSHOT as the name for the specialization when it's -1, so I went with that as the complement to ONESHOT for now.</p>
<h2>Use with <code>&lt;static&gt;</code> and get lazy initialization</h2>
<p>If you have something you want to happen only the first time you call a function, that's now pretty easy:</p>
<pre><code>operation: function [... &lt;static&gt; lazy (oneshot)] [
    lazy [
        ** "do expensive initialization here"
    ]
    ...
]
</code></pre>
<p>This is a shorter way of writing:</p>
<pre><code>operation: function [... &lt;static&gt; initialized (false)] [
    if not initialized [
        ** "do expensive initialization here"
        initialized: true
    ]
    ...
]
</code></pre>
<p>Generating oneshots makes an ACTION!, and hence incurs more overhead than making a LOGIC! variable.  But once they've been created, the execution time should be less than a conditional.  e.g. for this case, <code>lazy</code> makes its decision faster than an IF, and doesn't have to look up the words for the logic variables to be tested.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/you-only-get-oneshot/934">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/you-only-get-oneshot/934</link>
          <pubDate>Fri, 30 Nov 2018 23:46:57 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-934</guid>
          <source url="https://forum.rebol.info/t/you-only-get-oneshot/934.rss">You only get...ONESHOT</source>
        </item>
        <item>
          <title>Do not COLLECT [keep if false [$100]]</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>As I showed in the <a href="https://forum.rebol.info/t/ren-cs-eloquence-in-the-face-of-fizzbuzz/904">solution to FizzBuzz</a>, being able to take advantage of the evaluator's unique chaining abilities and "opting out" generally means making clever uses of null.</p>
<p>As another tradeoff that I think is worth it, I've changed COLLECT to return NULL if there are no non-null KEEPs.</p>
<pre><code>&gt;&gt; collect []
// null

&gt;&gt; collect [keep case [1 &gt; 2 [&lt;nope&gt;] 3 &gt; 4 [&lt;also nope&gt;]]
// null
</code></pre>
<p>When I look at that, it seems pretty natural.  In contrast, giving back a block when there's been no KEEPs seems like you're fabricating something from nothing.  I'll also mention that it helps some with performance/overhead, because you're not making empty blocks you don't need if you don't actually wind up needing one.  <em>(The implementation of collect in historical Rebol and Red does <code>make block! 16</code>, so you're taking a 16 cell block even if you don't use it, while this creates the block on demand.)</em></p>
<p>However, if this seems inconvenient, there's an easy workaround for if you want to ensure you always get an empty block back on no keeps... just do a plain non-/ONLY KEEP of an empty block.  Splicing nothing (vs null) is counted as enough intent to get some kind of result:</p>
<pre><code>&gt;&gt; maybe-empty: []
...
&gt;&gt; collect [keep [] for-each x maybe-empty [keep x]]
== []
</code></pre>
<p>We can easily chain it to make an "always-returns-a-block" version, and maybe we should put that in the box vs. making people use that idiom:</p>
<pre><code> collect-block: chain [
     :collect
        |
     func [x] [
         :x else [copy []]
     ]
 ]
</code></pre>
<p>But if you ask me, the idiom of <strong>keep []</strong> isn't too bad.  Moreover, if you just use <strong>data: try collect [...]</strong> you'll get a BLANK!, and blank is good enough to opt out of many operations that a <code>[]</code> would be opting out of:</p>
<pre><code>data: try collect [if false [keep &lt;not kept&gt;]]
for-each x data [print "won't run, data is blank and opts-out of FOR-EACH"]
</code></pre>
<p>Plus you might prefer to have something that you can test for absence with conditionality, vs EMPTY?.  (<code>if empty? data</code> is longer than just <code>if data</code>)</p>
<h2>The semi-noisy nature of null has advantages</h2>
<p>If you think casual uses of COLLECT are sure they mean they want an empty block on no KEEPs, I don't know if that seems to be the case.</p>
<p>Consider something like "print collect [...]", with that collection coming up empty.  What's PRINT supposed to be doing?  Is it a request to print a blank line--just a line feed?  Or is it a request to opt-out of printing altogether, so no newline at all?</p>
<p>I don't think there's a generic answer to that question.  So it's handy to draw attention to the ambiguity, since PRINT doesn't take NULL... only BLANK! to opt out, TEXT!, or BLOCK! to be SPACED.   So it will error and force you to make an explicit choice:</p>
<pre><code> print try collect [...] ;-- no output if there are no non-null KEEPs 
 print collect [keep [] ...] ;-- blank newline if no more KEEPs come along
 print collect-block [...] ;-- blank newline if no KEEPs, if we put it in the box
</code></pre>
<p>So this keeps you paying attention.</p>
<h2>But that's just a bonus, the real feature is tighter expression</h2>
<p>A lot of code already can't have a non-empty collect because it has literal KEEPs that always run, or collections that aren't ever empty.  Among the cases that are left, many want to do something different on an empty case and can do so with ELSE.  Among the cases that are left after that, many just want to enumerate the result...and a BLANK! from <strong>try collect</strong> serves better than the empty block does.</p>
            <p><small>6 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/do-not-collect-keep-if-false-100/923">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/do-not-collect-keep-if-false-100/923</link>
          <pubDate>Fri, 23 Nov 2018 13:55:20 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-923</guid>
          <source url="https://forum.rebol.info/t/do-not-collect-keep-if-false-100/923.rss">Do not COLLECT [keep if false [$100]]</source>
        </item>
        <item>
          <title>Comment to end-of-line with * *</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>It's Thanksgiving, and a good time to be thankful for <a href="https://forum.rebol.info/t/issues-with-invisibles-a-truly-disappearing-comment/405">"invisibles"</a>, one of the great success stories of 2018.  Their applications have gone far beyond commenting, though that's great too:</p>
<pre><code>x: 10
y: 1 comment [+ 2
z: 30] + 7
</code></pre>
<p>That'll give you <strong>y = 8</strong>.  Nifty.</p>
<p>But in the spirit of taking back attention-getting symbols like <strong><code>--</code></strong> for <a href="https://forum.rebol.info/t/taking-a-thrilling-tour-through-the-dump/909">epically more useful things</a>, I've taken back <strong><code>**</code></strong> from exponentiation (now just do infix exponents with <code>pow</code>).  In an idea near-simultaneously had by <a class="mention" href="/u/ingohohmann">@IngoHohmann</a> and I, it now acts as "comment to end of line" (or to end of block or group, whichever comes first).</p>
<p>What's the value of such a thing over <code>//</code>-style comments?  The real power is that it clearly annotates <em>code</em>, and raises a visual flag of "I am not a normal source comment"</p>
<pre><code>all [
    blah blah blah
    line two
    ** x: [some stuff here]
    do x
]
</code></pre>
<p>Had you used <code>//</code> it might be documentation.  Maybe that line is there to illustrate a property of x, to inform the next DO line?  But with <code>**</code> you know it's not an illustrative comment, it's marked out code.  It has to be LOADable, and stay LOADable.  And your eye can scan up and down the page and see these things easily before committing them on accident.</p>
<p>If you want to use it in the middle of a line, curb its to-end-of-line-ness by putting it in a GROUP!:</p>
<pre><code>any [this runs (** my-function "code that doesn't run") this runs too]
</code></pre>
<p>If you start a BLOCK! or GROUP! which then has newlines in it, that element will be the last thing considered...commented out to its end delimiter:</p>
<pre><code>&gt;&gt; print "this runs" ** (
    print "this does not run"
) print "this runs too"
</code></pre>
<p>Getting this to work required a bit of tweaking of unfinished varargs features.  But since it was done for this, now the <code>--</code> form of DUMP uses it too!</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/comment-to-end-of-line-with/920">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/comment-to-end-of-line-with/920</link>
          <pubDate>Thu, 22 Nov 2018 15:35:38 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-920</guid>
          <source url="https://forum.rebol.info/t/comment-to-end-of-line-with/920.rss">Comment to end-of-line with * *</source>
        </item>
  </channel>
</rss>
