<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Show &amp; Tell - AltRebol</title>
    <link>https://forum.rebol.info/c/usage/show-and-tell/33</link>
    <description>Topics in the &#39;Show &amp; Tell&#39; category Created something short and syrupy sweet?  Then post your scripts here; not confined to infinite length one-liners!</description>
    
      <lastBuildDate>Sun, 03 Oct 2021 17:29:29 +0000</lastBuildDate>
      <atom:link href="https://forum.rebol.info/c/usage/show-and-tell/33.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>Prettier TLS State Tables (and Assessing the Cost)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>So the spec-driven TLS originally had this state table.  On the left are states and on the right is a block of the legal states you can transition to from that state (if any).</p>
<p>Here are the states for a TLS read:</p>
<pre><code>read-proto-states: [
    client-hello [server-hello]
    server-hello [certificate]
    certificate [server-hello-done server-key-exchange]
    server-key-exchange [server-hello-done]
    server-hello-done [#complete]
    finished [change-cipher-spec alert]
    change-cipher-spec [encrypted-handshake]
    encrypted-handshake [application #complete]
    application [application alert #complete]
    alert [#complete]
    close-notify [alert]
]
</code></pre>
<p><em>It seemed to me this wasn't exploiting the types all that well.</em>  We see an ISSUE! being used for <span class="hashtag">#complete</span>.  I imagined it would be better to move the issue annotation onto the state itself: <strong>If a state was represented by an ISSUE!, then that meant the state could legally be transitioned to the completion state.</strong></p>
<p>So instead of:</p>
<pre><code>encrypted-handshake [application #complete]
</code></pre>
<p>That would become:</p>
<pre><code>#encrypted-handshake [#application]
</code></pre>
<p>(Since the application state could be terminal as well.)</p>
<p>Now you know just by looking at it that <span class="hashtag">#encrypted-handshake</span> is a <em>potentially-terminal state</em>...and that's everywhere that encrypted-handshake appears.  It's not that much more typing, since you have to put an apostrophe on most uses anyway...and it helps the state "stand out".</p>
<p>Plus making the non-terminal states stand out would be good, so I turned them into tags.</p>
<p><strong>I also thought that the blocks looked a bit boring, and I didn't like having to put single elements into blocks just for the convenience of the implementation.</strong>  I tried adding arrows and letting single elements stand alone on the mapped-to side:</p>
<pre><code>read-proto-states: [
    &lt;client-hello&gt;          -&gt; &lt;server-hello&gt;
    &lt;server-hello&gt;          -&gt; &lt;certificate&gt;
    &lt;certificate&gt;           -&gt; [#server-hello-done &lt;server-key-exchange&gt;]
    &lt;server-key-exchange&gt;   -&gt; #server-hello-done
    &lt;finished&gt;              -&gt; [&lt;change-cipher-spec&gt; #alert]
    &lt;change-cipher-spec&gt;    -&gt; #encrypted-handshake
    #encrypted-handshake    -&gt; #application
    #application            -&gt; [#application #alert]
    #alert                  -&gt; []
    &lt;close-notify&gt;          -&gt; #alert
]
</code></pre>
<p>Of course, this needs to be parsed into a MAP!, so we need some code like:</p>
<pre><code>transitions: make map! []  ; map from states to block of states
state-rule: [tag! | issue!]
uparse transdialect [
    while [
        left: state-rule '-&gt; right: [
            into block! [while state-rule, &lt;input&gt;]
            | collect keep state-rule
        ]
        (append transitions :[left right])
    ]
]
</code></pre>
<h2>Improvement...Or Dialecting For The Sake of Dialecting?</h2>
<p>The general question of whether or not to use things like ISSUE! and TAG! for states as opposed to the "cleaner" WORD!s is something that is a bit controversial.</p>
<p>One issue is that there's traditionally a greater cost to comparing strings than there is to comparing words.  So <strong>state = <span class="hashtag">#encrypted-handshake</span></strong> is slower than <strong>state = 'encrypted-handshake</strong>.  The worst case scenario is equality--because all the characters have to be compared to decide if they are equal.</p>
<p>I'd like to focus more on the qualities of the source representation than worry about the performance however.</p>
<p>There's certainly a point of view where the original wasn't as "noisy".  But if you take the extreme opinion of using WORD! for everything, then the code all blurs together.</p>
<h2>Parsing Has The Benefit Of Validation</h2>
<p>When you stylize your input and do some processing of it to get it into a canonized form, that process of translating your input is a chance to check that the data is what you expect.</p>
<p>Using a generic structure doesn't just keep you from throwing in "superficial" flourishes like <strong><code>-&gt;</code></strong>, but the generality usually goes with accepting anything.  Once you have a processing step that puts you in the position of being able to validate...which is a powerful thing.</p>
<h2>I Think These Kinds of Things Are "The Point"</h2>
<p>I don't know if this particular example is the best example.  But I do think that this is what PARSE is meant for, and UPARSE is pushing things to a new level.  We should be looking for opportunities to show off this kind of idea, vs just doing what other languages do in a weird way.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/prettier-tls-state-tables-and-assessing-the-cost/1736">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/prettier-tls-state-tables-and-assessing-the-cost/1736</link>
          <pubDate>Sun, 03 Oct 2021 17:29:29 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1736</guid>
          <source url="https://forum.rebol.info/t/prettier-tls-state-tables-and-assessing-the-cost/1736.rss">Prettier TLS State Tables (and Assessing the Cost)</source>
        </item>
        <item>
          <title>Taking Advantage of DELIMIT&#39;s BLOCK! Behavior and GET-BLOCK!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>I finally put my foot down and said that BLOCK! in DELIMIT has the behavior of <em><strong>don't evaluate, just squoosh everything together.</strong></em></p>
<pre><code>&gt;&gt; spaced ["abc" [d e "f"] "ghi"]
== "abc def ghi"
</code></pre>
<p>You can always REDUCE if you want evaluations, but there's also GET-BLOCK!...</p>
<pre><code>&gt;&gt; spaced ["abc" :["something" 1 + 2] "ghi"]
== "abc something3 ghi"
</code></pre>
<p>And with the magic of GET-BLOCK! branches, you can even opt in or out of these things!  Don't forget to use COMMA! if you think it will look better...</p>
<pre><code>&gt;&gt; spaced ["abc" if true :["something" 1 + 2] "ghi"]
== "abc something3 ghi"

&gt;&gt; spaced ["abc", if false :["something" 1 + 2], "ghi"]
== "abc ghi"
</code></pre>
<h2>Let's Look At What Old Code Had To Do</h2>
<p>Here's some code for making a log file name from pieces in the tests:</p>
<pre><code>log-file: log-file-prefix

if code-checksum [
    append log-file "_"
    append log-file copy/part skip mold code-checksum 2 6
]

append log-file "_"
append log-file copy/part skip mold test-checksum 2 6

append log-file ".log"
log-file: clean-path log-file
</code></pre>
<p>How about we tidy that up?</p>
<h2>Here Is What We Can Confidently Write In The New Way</h2>
<pre><code>log-file: clean-path unspaced [
    log-file-prefix
        if code-checksum :["_", copy/part (skip mold code-checksum 2) 6]
        "_", copy/part (skip mold test-checksum 2) 6, ".log"
]
</code></pre>
<p><strong>Not only is it cleaner, it's more efficient!</strong>  This lets us build as we go along, without having to keep expanding string memory on each APPEND...fewer function calls.  It's better all around!</p>
<p>I think we can make a JOIN using the "REPEND" replacement optimization equally efficient:</p>
<pre><code>log-file: clean-path join log-file-prefix :[
    if code-checksum :["_", copy/part (skip mold code-checksum 2) 6]
    "_", copy/part (skip mold test-checksum 2) 6, ".log"
]
</code></pre>
<h2>It Could Be Even More Efficient, If We Wanted...</h2>
<p>Given the GET-BLOCK! optimizations, a minor tweak could boost things:</p>
<pre><code>log-file: clean-path unspaced [
    log-file-prefix
        if code-checksum ':["_", copy/part (skip mold code-checksum 2) 6]
        "_", copy/part (skip mold test-checksum 2) 6, ".log"
]
</code></pre>
<p>It's a subtle difference, but we're having the IF statement evaluate to a GET-BLOCK!...instead of having a branch that evaluates a GET-BLOCK! to make a block.</p>
<p>We can make DELIMIT evaluate get-blocks as it goes, folding them into the output without generating intermediate series...much like REPEND.</p>
<p>This could be a little wild, in terms of performing evaluations when you didn't intend them:</p>
<pre><code>data: [a b c :[format hard drive]]

...

for-each item data [
    print ["The value is" data]
]
</code></pre>
<p>But that's really just the tip of the iceberg on how many ways the system is not safe against injection attacks.  But if you're working in a secure situation, you could use a guarded layer whenever dealing with external data, to limit execution.  I think that concept (which I have called "Build Your Own Safety") is likely what people who want to use the language in more secure scenarios would have to do.</p>
<p>(After all, even the most secure programs have to at some point run on an "insecure" CPU.  A flexible and fast Ren-C could be the basis for designing a more secure language on top of it...)</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/taking-advantage-of-delimits-block-behavior-and-get-block/1679">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/taking-advantage-of-delimits-block-behavior-and-get-block/1679</link>
          <pubDate>Mon, 23 Aug 2021 01:10:45 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1679</guid>
          <source url="https://forum.rebol.info/t/taking-advantage-of-delimits-block-behavior-and-get-block/1679.rss">Taking Advantage of DELIMIT&#39;s BLOCK! Behavior and GET-BLOCK!</source>
        </item>
        <item>
          <title>A Lot To UNPACK: (Replacing the SET of REDUCE BLOCK! Idiom)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>We've fretted a lot about the result of REDUCE when an expression produces something that can't be put in a block.  At first this was just NULL.  But now it's all BAD-WORD! isotope forms.</p>
<p>One reason to fret is the historical idiom of setting multiple values in a block.  This has been done with a SET of a REDUCE.  Something along the lines of:</p>
<pre><code>&gt;&gt; x: 3 + 4
== 7

&gt;&gt; set [a b] reduce [10 + 20 x]
== [30 7]

&gt;&gt; a
== 30

&gt;&gt; b
== 7
</code></pre>
<p>It's your choice to reduce the values or not.  If you don't involve REDUCE then the mechanics would all work out.  But once you get NULLs and isotopes, the reduced block can't store the values to convey them to the SET...</p>
<h2>But What If A Single Operation Did Both...?</h2>
<p>Let's imagine we have instead something called UNPACK that by default reduces.  Imagine it quotes a SET-BLOCK! on its left.</p>
<pre><code>&gt;&gt; x: 3 + 4
== 7

&gt;&gt; [a b]: unpack [10 + 20 x]
== 30

&gt;&gt; a
== 30

&gt;&gt; b
== 7
</code></pre>
<p>UNPACK manages the evaluation one expression at a time, instead of using REDUCE.  So as it goes it can set the variables to NULL or isotopes.  And by following the multi-return convention of returning the first value, you avoid ever needing to synthesize a block aggregating all the results together.</p>
<pre><code>&gt;&gt; [a b]: unpack case [
       1 = 1 [
           print "This is pretty slick..."
           [select [a 10] 'b, 1 + 2]
       ]
    ] else [
        print "This won't run because the ELSE gets a BLOCK!"
        print "Which is what you want, because the ELSE should be"
        print "what runs if no CASE was matched and have the option"
        print "of providing the block to UNPACK"
    ]
 This is pretty slick...
 ; null

&gt;&gt; a
; null

&gt;&gt; b
== 3
</code></pre>
<h2>@[...] can Even Avoid A REDUCE</h2>
<p>If you already have a block in reduced or literal form, how would you tell the UNPACK about that?  It could be a refinement like UNPACK/ONLY.  BUT...what if that were signaled with the @ block type?</p>
<pre><code>&gt;&gt; [a b]: unpack @[1 +]
== 1

&gt;&gt; a
== 1

&gt;&gt; b
== +
</code></pre>
<p>A real aspect of power in this approach is the ability to mix and match.  For instance you could have some branches in a CASE which have already reduced data and others that don't, and they could all participate with the same UNPACK operation.</p>
<pre><code>[op1 op2]: unpack case [
    ... [
        print "This branch uses values as-is"
        @[+ -]
    ]
    ... [
       print "This branch needs evaluation"
       [operators.1, pick [- /] op-num]
   ]
]
</code></pre>
<h2>Cool Dialecting Twists</h2>
<p>It seems to me nice to safeguard that you're not throwing away values:</p>
<pre><code>&gt;&gt; [a b]: unpack [1 2 3]
** Error: Too many values for vars in UNPACK (use ... if on purpose)
</code></pre>
<p>As the error says, though, we could indicate we're fine with this through a special syntax:</p>
<pre><code>&gt;&gt; [a b ...]: unpack [1 2 3]
== 1

&gt;&gt; a
== 1

&gt;&gt; b
== 2
</code></pre>
<p>(It's not as sketchy when you have too few values, because you can set the extra variables to unset...which will presumably trigger awareness of a problem at some point.)</p>
<p>Borrowing from multi-return: I think the idea of "circling" values to say which is the one you want the overall expression to evaluate to is a neat idea.</p>
<pre><code>&gt;&gt; [a @b]: unpack [1 2]
== 2
</code></pre>
<h2>And For Show And Tell...</h2>
<p>How hard is it to write such a thing, you ask?  In Ren-C it's super easy, barely an inconvenience:</p>
<pre><code>unpack: enfixed func [
    'vars [set-block!]
    block [block! quoted!]
][
    let result': ~unset~
    reduce-each val block [
        if vars.1 = '... [continue]  ; ignore rest, but keep reducing
        if tail? vars [fail "Too many values in UNPACK (use ...)"]
        if not blank? vars.1 [
            set vars.1 unmeta ^val
            if unset? the result' [result': ^val]
        ]
        vars: my next
    ]
    if vars.1 = '... [
        if not last? vars [fail "... only at the tail of UNPACK vars"]
    ] else [
        for-each var vars [  ; if not enough values for variables, unset
            if not blank? var [unset var]
        ]
    ]
    return unmeta result'
]
</code></pre>
<p>If the ^ and UNMETA seem confusing, the only thing you need to think about is that the META protocol helps you out when you're trying to deal with a situation of storing a value that can be anything...and you need to differentiate a state.  I'm making the result "meta" so that I can use plain unset to signal that it hasn't been assigned yet.  I could make a separate boolean variable instead, but then I'd have another variable and I'd have to GET/ANY the result...</p>
<p>I'm sure people will start getting the hang of it!  <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
            <p><small>8 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/a-lot-to-unpack-replacing-the-set-of-reduce-block-idiom/1634">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/a-lot-to-unpack-replacing-the-set-of-reduce-block-idiom/1634</link>
          <pubDate>Thu, 08 Jul 2021 07:44:41 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1634</guid>
          <source url="https://forum.rebol.info/t/a-lot-to-unpack-replacing-the-set-of-reduce-block-idiom/1634.rss">A Lot To UNPACK: (Replacing the SET of REDUCE BLOCK! Idiom)</source>
        </item>
        <item>
          <title>Weird Idiom: Labeling Values?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>I'm going through and changing a lot of FUNCTION uses to FUNC + LET.  The long term goal will be to eliminate the locals-gathering functionality...and you either use LET/USE or you go explicit with <code>&lt;local&gt;</code> in the function spec.</p>
<p>I came across this:</p>
<pre><code>    size-as-binary: enbin [be + 8] length of embedding
    append executable size-as-binary
</code></pre>
<p>This was the only use of the variable.  Changing it to a LET works, but it's kind of a waste:</p>
<pre><code>    let size-as-binary: enbin [be + 8] length of embedding
    append executable size-as-binary
</code></pre>
<p>LET's assignment form does run the right hand side...because the LET word itself vaporizes, so it's like the bound new SET-WORD! just runs as normal:</p>
<pre><code>    append executable let size-as-binary: enbin [be + 8] length of embedding
</code></pre>
<p>But a LET isn't really necessary here.  I had a weird thought, what if a TAG! or ISSUE! or something was used in a way that was "obviously" throwing it away?</p>
<pre><code>    append executable (&lt;size-as-binary&gt; enbin [be + 8] length of embedding)
</code></pre>
<p>Maybe a little confusing.  But it saves on a variable declaration.</p>
<p>A comment is zero overhead, so I'm doing that...</p>
<pre><code>    append executable enbin [be + 8] length of embedding  ; size of binary
</code></pre>
<p>But I just thought the idea of a deliberately discarded leading value was kind of interesting.</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/weird-idiom-labeling-values/1500">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/weird-idiom-labeling-values/1500</link>
          <pubDate>Wed, 10 Feb 2021 19:21:13 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1500</guid>
          <source url="https://forum.rebol.info/t/weird-idiom-labeling-values/1500.rss">Weird Idiom: Labeling Values?</source>
        </item>
        <item>
          <title>Resurrecting REDBOL-APPLY via Type Exposure</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>At one point, I had a simulation of the Rebol2/R3-Alpha APPLY working...all written in usermode code.</p>
<p>As a refresher: this concept of APPLY required you to line up things positionally--even refinements.  You had to look at the parameter order on the interface, and put "truthy" things in the refinement slots you wanted to enable.  Then if the refinement took argument(s), you would have to put that in the next slot.</p>
<p>So for R3-Alpha's APPEND, the ordered spec is:</p>
<pre><code>APPEND series value /part length /only /dup count
</code></pre>
<p>Let's say you wanted to do something equivalent to <strong>append/part/dup [a b c] [d e f] 2 3</strong>.  You would write:</p>
<pre><code>r3-alpha&gt;&gt; apply :append [[a b c] [d e f] true 2 false true 3]
== [a b c d e d e d e]
</code></pre>
<p>Here the first TRUE is to say we want to use the /PART...then the length of 2.  Then a FALSE to say we don't want /ONLY.  And then another TRUE to say we want /DUP, with the count as 3.</p>
<p>It's fairly convoluted, and brittle with respect to rearrangement.  But it offers you the benefit of being able to calculate whether you want to provide a refinement or not.  The block is reduced by default (with an /ONLY option to ask that it not be).</p>
<p>In the early days of frames, I thought it would be a good test to see if this exact function could be emulated by processing the block... building a FRAME!, and then DO'ing it.  So REDBOL-APPLY was written and added to the tests.</p>
<h2>Then Ren-C Became <a href="https://forum.rebol.info/t/pure-and-refined-simplifying-refinements-to-one-or-zero-args/1120">Pure and Refined</a>...</h2>
<p>With the great improvement of refinements becoming their own arguments, came a new puzzle from an interface perspective.  Where it had used to say things like:</p>
<pre><code>ren-c-before&gt;&gt; parameters of :append
== [series value /part length /only /dup count]
</code></pre>
<p>It would now say:</p>
<pre><code>ren-c-after&gt;&gt; parameters of :append
== [series value /part /only /dup]
</code></pre>
<p>You might notice a piece of information gets lost there: <strong>which refinements take arguments at the callsite, vs. which ones don't</strong>.  Here the /ONLY looks just like the /PART and /DUP.  If you're going to have a REDBOL-APPLY that splits out the refinement on/off from the argument, you have to know if there is an argument to fill in.</p>
<p>I'll emphasize here that <strong>whether or not this particular APPLY primitive is desirable or not isn't the point.</strong>  It's a question of whether there's enough information.  And you have to have more than the parameter list above.</p>
<p>So one place people might have looked to would be the TYPESETS OF reflector, and maybe check to see if the typeset was empty (?)  But the typeset code was never all that good.</p>
<h2>Enter The New AS FRAME! Aliasing Ability</h2>
<p>I only just pushed this a bit forward, so it's not stable yet.  But it was enough to get REDBOL-APPLY working.  Here's what the frame alias of APPEND looks like:</p>
<pre><code>&gt;&gt; as frame! :append
== #[frame! {append} [
    return : [any-series! port! map! object! module! bitset!]:
    series : [any-series! port! map! object! module! bitset!]
    value : [&lt;opt&gt; any-value!]
    part : /[any-number! any-series! pair!]
    only : /[]
    dup : /[any-number! pair!]
    line : /[]
]]
</code></pre>
<p>The keys can't hold the information about whether something is a refinement or quoted or not.  So those attributes are moved onto the BLOCK!.  Here we see that PART, ONLY, DUP, and LINE are refinements...while ONLY and LINE have no specified types.</p>
<h2>And Here's The First Try That Gets The Tests Passing Again</h2>
<p>It's big and pokey.  And it trips over the weird parameter compaction a little bit... there's still a lot of questions about how you would take something that could either be <strong>':foo</strong> or <strong>/foo</strong> and extract plain <strong>foo</strong> out of it.  (It's not as obvious as you might think that "to word! should just do that".)</p>
<p>There's plenty of room for improvement.  But clumsy though it is, it shows some of the non-trivial meta-language behavior that I think can be put in the hands of mere mortals...in that Minecraft-of-programming way.  This really is letting people get intimately involved in the design of their own function generators and control structures...</p>
<pre><code>redbol-apply: func [
    return: [&lt;opt&gt; any-value!]
    action [action!]
    block [block!]
    /only
    &lt;local&gt; types arg key frame params mode
][
    types: as frame! :action  ; exemplar of types
    frame: make frame! :action  ; frame we are building
    params: parameters of :action  ; ordered list of parameters
    mode: &lt;normal&gt;

    ; Rebol2 and R3-Alpha APPLY would fill in NONE for any parameters that
    ; were not provided in the apply block:
    ;
    ;     rebol2/r3-alpha&gt;&gt; apply func [a b c] [reduce [a b c]] []
    ;     == [none none none]
    ;
    ; This means we need to enumerate and fill in the frame as long as there
    ; are parameters--not as long as there are block values.
    ;
    while [not tail? params] [
        case [
            not block [
                arg: null  ; could also do BLANK! if no more block data
            ]
            only [  ; /ONLY means do not evaluate arguments
                arg: get/any 'block/1
                block: next block
            ]
            true [  ; evaluate (skipping comments and other invisibles)
                until .not.quoted? [[block arg]: evaluate block]
            ]
        ]

        key: to word! dequote params/1
        all [
            refinement? params/1
            elide if not block [break]  ; done if refinements w/no more block
            mode = &lt;normal&gt;
        ] then [
            mode: if arg [#]  ; set mode to either use or don't use next arg
            if empty? second pick types key [  ; no-arg refine...
                set (in frame key) mode  ; ...must be # or NULL
            ] else [
                continue  ; keep param on the refinement, get next arg
            ]
        ] else [
            if mode [  ; normal or # case will set
                set (in frame key) get/any 'arg
            ]
        ]

        mode: &lt;normal&gt;
        params: next params
    ]

    ; Too many arguments was not a problem for R3-alpha's APPLY, it would
    ; evaluate them all even if not used by the function.  It may or may not
    ; be better to have it be an error.
    ;
    ; https://github.com/metaeducation/rebol-issues/issues/2237
    ;
    comment [
        all [block, not tail? block] then [
            fail "Too many arguments passed in REDBOL-APPLY block."
        ]
    ]

    do frame
]</code></pre>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/resurrecting-redbol-apply-via-type-exposure/1474">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/resurrecting-redbol-apply-via-type-exposure/1474</link>
          <pubDate>Mon, 25 Jan 2021 11:50:41 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1474</guid>
          <source url="https://forum.rebol.info/t/resurrecting-redbol-apply-via-type-exposure/1474.rss">Resurrecting REDBOL-APPLY via Type Exposure</source>
        </item>
        <item>
          <title>iframe in replpad-js</title>
          <dc:creator><![CDATA[okram]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>I was thinking about using rebol to automate some tasks on web applications  have to use regularly. Obviously, replpad-js can leverage the browser (which can take care of cookies, etc.). I want the <code>IFRAME</code> to be resizable and I do not want to use any JS for that.</p>
<pre><code class="lang-auto">inline-css: function [
    {Provide default CSS for resizing inline frame}
][
    css-do {.replpad-resizer { display:flex; margin:0; padding:0; resize:both; overflow:hidden }
            .replpad-resizer &gt; .replpad-resized { flex-grow:1; margin:0; padding:0; border:0 }
            .replpad-border { background:gray; border:1px dashed black; }}
]
</code></pre>
<p>The <code>inline</code> function takes the URL and an id and inserts the <code>IFRAME</code> (maybe it should use the original URL as the id?).</p>
<pre><code class="lang-auto">inline: function [
    {Provide a browsing context in the replpad}
    url [url!]
    name [text!]
][
    replpad-write/html unspaced [
        &lt;div class="replpad-resizer replpad-border"&gt;
        {&lt;iframe class="replpad-resized" src="} url {" id="} name {"&gt;&lt;/iframe&gt;}
        &lt;/div&gt;
    ]
]
</code></pre>
            <p><small>8 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/iframe-in-replpad-js/1449">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/iframe-in-replpad-js/1449</link>
          <pubDate>Thu, 31 Dec 2020 19:21:46 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1449</guid>
          <source url="https://forum.rebol.info/t/iframe-in-replpad-js/1449.rss">iframe in replpad-js</source>
        </item>
        <item>
          <title>YIELDER and GENERATOR (and thinking about Coroutines)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>The stackless model so far has been built on a generic and comprehensible building block called a <strong>YIELDER</strong>.  I thought I'd walk through it a little.</p>
<h1>To understand YIELDER, first look at GENERATOR</h1>
<p>I think a generator is pretty easy to understand.  It is like a function, but instead of RETURN it has something called YIELD.  Each time YIELD is called the generator gives back the result but is left in a suspended state, and the next call to the generator will pick up right after the YIELD:</p>
<pre><code>counter: generator [
     let n: 0
     cycle [
          n: n + 1
          yield n
     ]
]

&gt;&gt; counter
== 1

&gt;&gt; counter
== 2
</code></pre>
<h2>Generators are building blocks, meant to be used with functions</h2>
<p>Generators don't take parameters.  So if you want to parameterize them, you should combine them with a function.  Imagine you wanted to be able to specify a bump amount for your counter:</p>
<pre><code>make-counter: func [bump] [
     return generator [
         let n: 0
         cycle [yield n: n + 1]
     ]
]

&gt;&gt; counter: make-counter 5

&gt;&gt; counter
== 1

&gt;&gt; counter
== 6

&gt;&gt; counter
== 11
</code></pre>
<h2>But functions aren't limited to being just "generator makers"...</h2>
<p>For instance: functions can be generator wrappers, that actually delegate to the generator...or perhaps even destroy it and make new ones.  Consider making a resettable counter, as <a class="mention" href="/u/giuliolunati">@giuliolunati</a> has in his GENERATE usermode generator:</p>
<pre><code> counter: func [/reset &lt;static&gt; n (0) gen (null)] [
     if reset [n: 0, return]
     return reeval gen: default [
         generator [
             cycle [yield n: n + 1]
         ]
     ]
 ]

 &gt;&gt; counter
 == 1

 &gt;&gt; counter
 == 2

 &gt;&gt; counter/reset

 &gt;&gt; counter
 == 1

 &gt;&gt; counter
 == 2
</code></pre>
<p>This gives a lot of flexibility in the design of generator interfaces.  Considering the above example alone: what if you are in a situation where you think the <strong>counter/reset</strong> should have returned 1 instead of being a separate step that had no return result?  Or maybe you think it should have returned what the last generator value was.</p>
<p>By making generators a "simplistic" building block, you're in control of these interface choices.</p>
<h2>The YIELDER hybridizes with functions for efficiency</h2>
<p>I said that generators don't have parameters or a function spec, but that is because they are a specialization of a version that does have a spec... called a YIELDER.</p>
<pre><code>weird-print: yielder [x] [
    cycle [
        print ["Odd print:" x]
        yield none
        print ["Even print:" x]
        yield none
    ]
]

&gt;&gt; weird-print "Hello"
Odd print: Hello

&gt;&gt; weird-print "Weird"
Even print: Weird

&gt;&gt; weird-print "World"
Odd print: World
</code></pre>
<p>This isn't anything you couldn't have achieved with a function that wrapped a generator, that held that generator statically and then sub-dispatched to it.  It's just cleaner and more efficient.  <em>(Since GENERATOR is implemented as <code>yielder [] [...generator body...]</code> it's kind of like the DOES analogue to FUNC.)</em></p>
<p>But this kind of gives you a sense of the parts box you have for building relatively efficient generator-type things.</p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/yielder-and-generator-and-thinking-about-coroutines/1311">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/yielder-and-generator-and-thinking-about-coroutines/1311</link>
          <pubDate>Tue, 28 Jul 2020 03:52:04 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1311</guid>
          <source url="https://forum.rebol.info/t/yielder-and-generator-and-thinking-about-coroutines/1311.rss">YIELDER and GENERATOR (and thinking about Coroutines)</source>
        </item>
        <item>
          <title>Portable Bridge Notation (PBN) Parser</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>I decided I would do a small task in the web Ren-C build, which is to take the <a href="https://www.tistis.nl/pbn/" rel="nofollow noopener">"Portable Bridge Notation"</a> for representing a deal of a hand of cards, and turn it into blocks of symbolic data representing each player's hand.</p>
<p>The notation is pretty straightforward, e.g.</p>
<pre><code>N:QJ6.K652.J85.T98 873.J97.AT764.Q4 K5.T83.KQ9.A7652 AT942.AQ4.32.KJ3
</code></pre>
<p>Separated by spaces are the cards for each of 4 hands.  The suits are separated by dots, and the order is <strong><code>clubs.diamonds.hearts.spades</code></strong>.  T is used for 10, while J/Q/K/A are the typical Jack/Queen/King/Ace.  The first letter is a direction (N=North, E=East, S=South, W=West) of which player the first hand represented is for.</p>
<p>This case decodes like so:</p>
<p><div class="lightbox-wrapper"><a class="lightbox" href="https://forum.rebol.info/uploads/default/original/1X/af1db86d4b17341751b69cbc3cba816ca16b2af6.jpeg" data-download-href="https://forum.rebol.info/uploads/default/af1db86d4b17341751b69cbc3cba816ca16b2af6" title="pbn-converter.jpg"><img src="https://forum.rebol.info/uploads/default/optimized/1X/af1db86d4b17341751b69cbc3cba816ca16b2af6_2_690x458.jpeg" alt="pbn-converter" data-base62-sha1="oZ9erLwEVhI0IGIYxhS9X9InLRY" width="690" height="458" srcset="https://forum.rebol.info/uploads/default/optimized/1X/af1db86d4b17341751b69cbc3cba816ca16b2af6_2_690x458.jpeg, https://forum.rebol.info/uploads/default/optimized/1X/af1db86d4b17341751b69cbc3cba816ca16b2af6_2_1035x687.jpeg 1.5x, https://forum.rebol.info/uploads/default/optimized/1X/af1db86d4b17341751b69cbc3cba816ca16b2af6_2_1380x916.jpeg 2x" data-small-upload="https://forum.rebol.info/uploads/default/optimized/1X/af1db86d4b17341751b69cbc3cba816ca16b2af6_2_10x10.png"><div class="meta">
<svg class="fa d-icon d-icon-far-image svg-icon" aria-hidden="true"><use xlink:href="#far-image"></use></svg><span class="filename">pbn-converter.jpg</span><span class="informations">1502×997 204 KB</span><svg class="fa d-icon d-icon-discourse-expand svg-icon" aria-hidden="true"><use xlink:href="#discourse-expand"></use></svg>
</div></a></div></p>
<p><em>(<a href="https://github.com/hostilefork/replpad-js/blob/d7af14eea92d23d50c2bd25d5dfca20a11929a8a/replpad.reb#L173" rel="nofollow noopener">console escaping is now done by Rebol code</a>, so this shows some colorization and live hyperlink as an example of what we might do with that)</em>.</p>
<p>I wanted the PBN conversion to be accessible and demonstrate "best practices".  Here's what I came up with:</p>
<pre><code>pbn-to-hands: func [
    {Convert portable bridge notation to BLOCK!-structured hands}

    return: [object!]
    pbn [text!]
][
    let rank-rule: [
        'A | 'K | 'Q | 'J | 'T | '9 | '8 | '7 | '6 | '5 | '4 | '3 | '2
    ]

    let suit-order: [♣ ♦ ♥ ♠]
    let suit: void

    let one-hand: void
    let one-hand-rule: [
        (suit: '♣)
        [
            collect one-hand [4 [
                any [
                    set rank rank-rule
                    keep :[
                        as word! unspaced [suit either rank = #"T" [10] [rank]]
                    ]
                ]
                :(
                    suit: select suit-order suit
                    if suit ["."] else '[ahead [space | end]]
                )
            ]]
        ]
        |
        (fail "Invalid Hand information in PBN")
    ]

    let hands: make object! [N: E: S: W: void]
    let direction-order: [N E S W]

    let start: void
    let direction: void

    parse pbn [
        any space  ; We allow leading whitespace, good idea?

        [
            set start ['N | 'E | 'S | 'W] (
                start: to word! start
                direction: start
            )
            |
            (fail "PBN must start with N, E, S, or W")
        ]

        [":" | (fail "PBN second character must be `:`")]

        [
            [4 [
                one-hand-rule (  ; Should set `one-hand` if rule succeeds.
                    hands/(direction): one-hand
                    one-hand: void
                    direction: (select direction-order direction) else [
                        first direction-order
                    ]
                )
                any space  ; Should more than one space between hands be ok?
            ]]
            |
            (fail "PBN must have 4 hand definitions")
        ]
        end
    ]

    assert [direction = start]  ; skipping around should have cycled
    return hands
]</code></pre>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/portable-bridge-notation-pbn-parser/1306">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/portable-bridge-notation-pbn-parser/1306</link>
          <pubDate>Sun, 19 Jul 2020 01:58:13 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1306</guid>
          <source url="https://forum.rebol.info/t/portable-bridge-notation-pbn-parser/1306.rss">Portable Bridge Notation (PBN) Parser</source>
        </item>
        <item>
          <title>Collector In Disguise</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>So, this is somewhat trivial.  But what if you wanted a function that instead of RETURN ending the function, it just added to the results and moved on?  <a href="https://www.youtube.com/watch?v=35qsykW3f58" rel="nofollow noopener">We might call this a COLLECTOR</a>.</p>
<p>Let's imagine that we like KEEP better than renaming to RETURN</p>
<pre><code>collector: func [spec block] [return func spec compose [collect (block)]]
; ^-- Ren-C semantics for COMPOSE, BLOCK! only splices if ((...))

c: collector [x] [
    keep x + 1
    keep x + 2
    keep x + 3
]

&gt;&gt; c 10
== [11 12 13]

&gt;&gt; c 20
== [21 22 23]

&gt;&gt; c 30
== [31 32 33]
</code></pre>
<p><em>(Note: This is an interesting example of the "what do I do with a BLOCK!, splice by default or not?"  I still find this to be a central question.  I'm pretty confident that differentiating the splice case in COMPOSE visually with <code>((...))</code> is a good move.  But I'm still on the fence about what the bigger story is.  Lately my leaning is that we do have modal parameters, e.g. <code>keep @value</code> will act the same as <code>keep/only value</code>, but plain KEEP has the variance in behavior for blocks that it has today...risky though it is.  People just learn to live with it or use @ or /ONLY habitually.)</em></p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/collector-in-disguise/1277">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/collector-in-disguise/1277</link>
          <pubDate>Tue, 28 Apr 2020 11:47:36 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1277</guid>
          <source url="https://forum.rebol.info/t/collector-in-disguise/1277.rss">Collector In Disguise</source>
        </item>
        <item>
          <title>API Use Example: Elliptic Curve</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>It turns out we probably don't need to be adding <a href="https://en.wikipedia.org/wiki/Curve25519" rel="nofollow noopener">Curve25519</a> right at the moment for TLS.  But how quick I could bridge to a short C implementation's function was really neat, so I thought I'd both save the code and show it off.</p>
<p>What happens is it takes a 32-byte input and an optional 32-byte basepoint, both as BINARY!.  Then it returns another 32-byte result from calling the C implementation on the <code>unsigned char*</code> buffers (REBYTE):</p>
<pre><code>//
//  export curve25519: native [
//      return: "32-byte binary of public key data"
//          [binary!]
//      secret "32-byte binary of secret data"
//          [binary!]
//      /basepoint "optional 32-bytes, defaults to #{09000000...}"
//          [binary!] 
//  ]
//
REBNATIVE(curve25519)
{
    CRYPT_INCLUDE_PARAMS_OF_CURVE25519;

    size_t secret_size;
    REBYTE *secret = rebBytes(&amp;secret_size,
        "if 32 != length of", ARG(secret), "[",
            "fail {SECRET must be a 32-byte BINARY! for curve25519}",
        "]",
        ARG(secret),
    );
    assert(secret_size == 32);

    size_t basepoint_size;
    REBYTE *opt_basepoint = rebBytes(&amp;basepoint_size,
        "if all [", REF(basepoint), "32 != length of", REF(basepoint), "] [",
            "fail {/BASEPOINT must be a 32-byte BINARY! for curve25519}",
        "]",
        REF(basepoint),
    );
    assert(opt_basepoint ? basepoint_size == 32 : basepoint_size == 0);

    REBYTE mypublic[32];  // "public" is a C++ keyword :-/

    curve25519(mypublic, secret, opt_basepoint);
    rebFree(secret);
    rebFree(opt_basepoint);  // null-tolerant, like C's free()

    return rebSizedBinary(mypublic, 32);
}
</code></pre>
<p>Here you see the power of libRebol's hybridized calls.  rebBytes isn't just a routine for extracting the binary bytes out of a Rebol value...it's able to do a size check first (which FAILs if it needs to).  Then the last item in the evaluation is the argument itself.  C's 0-for-null is leveraged simply, so that if an argument is null the extractors just give back null.</p>
<p>Being able to do this in plain ANSI C is really rather awesome!</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/api-use-example-elliptic-curve/1263">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/api-use-example-elliptic-curve/1263</link>
          <pubDate>Wed, 19 Feb 2020 03:14:59 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1263</guid>
          <source url="https://forum.rebol.info/t/api-use-example-elliptic-curve/1263.rss">API Use Example: Elliptic Curve</source>
        </item>
        <item>
          <title>Multiple Return Values Via Enfix</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>I had an observation that we can actually do multiple return values today, with enfix and skippable parameters:</p>
<p>Imagine you want to make something where it returns the sum of two values and the difference...but only the sum if you aren't using a multi-return.</p>
<pre><code>sum-and-difference: enfixed func [:left [&lt;skip&gt; set-block!] arg1 arg2] [
    let sum: arg1 + arg2  ; always returned, only calculate once
    if set? 'left [
        switch length of left [
            1 [  ; we have `[x]: ...` act the same as `x: ...` 
               set left/1 sum
            ]
            2 [  ; only calculate difference for multiple returns
               set left/1 sum
               set left/2 arg1 - arg2
            ]
            fail "sum-and-difference can only return 1 or 2 values"
        ]
    ]
    return sum
]
</code></pre>
<h2>and presto...</h2>
<pre><code>&gt;&gt; x: sum-and-difference 20 10
== 30  ; handled by plain evaluator mechanics

&gt;&gt; [y z]: sum-and-difference 20 10
== 30  ; handled by the enfix quoting

&gt;&gt; y
== 30

&gt;&gt; z
== 10
</code></pre>
<p>Notice that adopts the principle that it doesn't actually try to return a BLOCK! with the multiple return values, but only the first value.  But the interesting bit is that when you go about it this way, the convention is not really enforced.</p>
<h2>what's wrong with doing it this way?</h2>
<p>A disadvantage of this technique is it means you cannot make enfixed functions that have multiple return values (in the sense they've already used their enfixedness for the purpose of the multiple return value itself).</p>
<p>That may or may not be bad.  :-/  This offers a lot of flexibility to people for designing how their multiple return values work.  They could decide that blanks mean skip the assignment, so for <strong>[_ z]: sum-and-difference 20 10</strong> it could be decided not to calculate the sum at all, and to return the difference.  Or people who disagree with my philosophy about return the first thing could come up with their own rules...returning blocks that voidify, or maybe even the ability to mark which thing to return like <strong>[y <span class="mention">@z</span>]: sum-and-difference 20 10</strong> could calculate both but return the difference.</p>
<p>We could build any of those ideas in--but telling people they are their own boss and can design it how they want is a powerful idea that is a bit unnerving.  Though Rebol has a lot of those.  Truly a strange way of looking at multiple return value mechanics.</p>
<p>But it's still cool just in terms of prototyping--as well as to show that the mechanics aren't that far out.  I feel like the interface for multiple-returns should be something along these lines, e.g. if you say <strong>func <code>[return: [&lt;multi&gt;]</code> ...]</strong> what you actually get is some way to address the variables that you are assigning...basically an analogue to being sensitive to the contents SET-BLOCK! from the left (though maybe for information-hiding purposes you could only know if an assignment was desired, and not be able to read the previous values from the left-hand side).</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/multiple-return-values-via-enfix/1257">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/multiple-return-values-via-enfix/1257</link>
          <pubDate>Sat, 01 Feb 2020 05:04:04 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1257</guid>
          <source url="https://forum.rebol.info/t/multiple-return-values-via-enfix/1257.rss">Multiple Return Values Via Enfix</source>
        </item>
        <item>
          <title>REN-C code show off</title>
          <dc:creator><![CDATA[iArnold]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>Think about the Fizz Buzz code Brian created and showed at the 2019 Conference:</p>
<pre><code class="lang-auto">count-up n 100 [
    print [ unspaced [
        if n mod 3 = 0 ["Fizz"]
        if n mod 5 = 0 ["Büzz"]
    ] else [n]]
]
</code></pre>
<p>Any more pieces of code where REN-C excels?</p>
<p>There are more programming ideas at</p>
<p><a href="https://rosettacode.org/wiki/Category:Programming_Tasks" rel="nofollow noopener">Rosettacode</a></p>
<p><a href="https://codeforces.com" rel="nofollow noopener">Code Forces</a></p>
            <p><small>4 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/ren-c-code-show-off/1255">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/ren-c-code-show-off/1255</link>
          <pubDate>Fri, 24 Jan 2020 13:50:29 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1255</guid>
          <source url="https://forum.rebol.info/t/ren-c-code-show-off/1255.rss">REN-C code show off</source>
        </item>
        <item>
          <title>Looking into a *usermode* POINTFREE</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>The concept of <a href="https://en.wikipedia.org/wiki/Tacit_programming">"Point Free" or "Tacit Programming"</a> is that it's a way of relating functions to each other without mentioning their arguments.</p>
<p>So instead of writing something like:</p>
<pre><code> append-to-data: function [value] [append data value]
</code></pre>
<p>You'd have some way of avoiding the redundancy of having to say "value" twice.  So imagine declaring an identical function with a syntax like:</p>
<pre><code> append-to-data: pointfree [append data]
</code></pre>
<p>That would notice you didn't provide all the parameters to append, so an implicit parameter to the new function would be added.  But what if you wanted instead something like:</p>
<pre><code>append-10: function [series] [append series 10]
</code></pre>
<p>So maybe you would have some syntax in POINTFREE for that where you put a placeholder in spots that you wanted implicitly picked up.  Maybe BLANK! as a default:</p>
<pre><code>append-10: pointfree [append _ 10]
</code></pre>
<p><em>(Note: The name <strong>pointfree</strong> is deliberately chosen as bad, since it won't be taken for other reasons...and also reinforces the term for Rebol programmers unused to FP concepts.  What I'm actually thinking is that this will be folded into lambda as the behavior when you don't use a block.  So <strong>(-&gt; append _ 10)</strong> for example.)</em></p>
<blockquote>
<p><strong>UPDATE:</strong> To eliminate potential accidents, it was unbundled from lambda and uses the similar-but-notably-distinct notation <strong><code>&lt;-</code></strong> now.</p>
</blockquote>
<h2>Writing This In Usermode In Historical Rebol Is Non-Trivial</h2>
<p>If you think writing a reliable POINTFREE yourself would be easy in Rebol2/Red, I would invite you to try.  There's a lot to get right with parameter analysis and ordering refinements; beyond the average user.  It doesn't get much easier if you are coding inside the system, either.</p>
<p>It would also be noticeably slower, using any method in near-reach.  The only mechanisms would involve creating a whole new function spec, where the evaluator would have to pass parameters to that function...then start evaluating again to make a nested call...type checking all over again.</p>
<p>Ren-C has several tricks up its sleeve, including a new tool introduced today for writing your own specializations.  That's the ability to MAKE ACTION! out of a FRAME! with some of its parameters filled.  And since you can MAKE FRAME! out of an ACTION!, this provides a convenient round-trip:</p>
<pre><code>&gt;&gt; data: [a b c]

&gt;&gt; f: make frame! :append
&gt;&gt; f/series: data

&gt;&gt; apd: make action! f
&gt;&gt; apd [d e f]

&gt;&gt; data
== [a b c d e f]
</code></pre>
<p>There's also a great convenience afforded by Ren-C's smart specialization handling.  Consider:</p>
<pre><code>&gt;&gt; parameters of :append
== [series value /part /only /dup /line]

&gt;&gt; apdup: :append/dup

&gt;&gt; parameters of :apdup
== [series value dup /part /only /line]
</code></pre>
<p>So if you have someone writing <strong>pointfree [append/dup ...]</strong> you don't worry...just GET the PATH!, and the function you are handed back doesn't even report DUP as a refinement.  It's a normal parameter now.</p>
<p>There's also more unlocked by the idea of <a href="https://forum.rebol.info/t/pure-and-refined-simplifying-refinements-to-one-or-zero-args/1120">refinements naming their 0-or-1 arguments</a>.  We've seen it open doors with <a href="https://forum.rebol.info/t/augment-add-parameters-and-refinements-after-the-fact/1216">AUGMENT</a>, but it helps here and elsewhere.</p>
<h2>A Start on the Vision of POINTFREE</h2>
<p>This usermode implementation is incomplete and raises some issues (including that I'm not totally thrilled with the <span class="mention">@var</span> skippable syntax in EVALUATE).</p>
<p>But it shows relatively little code taking care of some rather complex acrobatics.  I'd hope it wouldn't be too far beyond the reach of a novice to write:</p>
<pre><code>pointfree: func [
    {Specialize by example: https://en.wikipedia.org/wiki/Tacit_programming}

    return: [action!]
    block [block!]
][
    let action: (match action! any [
        if match [word! path!] :block/1 [get block/1]
        :block/1
    ]) else [
        fail "POINTFREE requires ACTION! argument at head of block"
    ]
    block: next block  ; rest of block is invocation by example

    ; If we did a GET of a PATH! it will come back as a partially specialized
    ; function, where the refinements are reported as normal args at the
    ; right spot in the evaluation order.  (e.g. GET 'APPEND/DUP returns a
    ; function where DUP is a plain WORD! parameter in the third spot).
    ;
    ; We prune out any unused refinements for convenience.
    ;
    let params: map-each w parameters of :action [
        match [word! lit-word! get-word!] w  ; !!! what about skippable params?
    ]

    let frame: make frame! :action  ; all frame fields default to NULL

    ; Step through the block we are given--first looking to see if there is
    ; a BLANK! in the slot where a parameter was accepted.  If it is blank,
    ; then leave the parameter null in the frame.  Otherwise take one step
    ; of evaluation or literal (as appropriate) and put the parameter in the
    ; frame slot.
    ;
    let var
    iterate params [
        case [
            blank? :block/1 [block: next block]

            word? params/1 [
                if not block: evaluate @var block [
                    break  ; ran out of args, assume remaining unspecialized
                ]
                frame/(params/1): :var
            ]
            
            all [
                lit-word? params/1
                match [group! get-word! get-path!] :block/1
            ][
                frame/(params/1): reeval :block/1
                block: next block
            ]

            default [  ; hard literal argument or non-escaped soft literal
                frame/(params/1): :block/1
                block: next block
            ]
        ]
    ]

    ; We now create an action out of the frame.  NULL parameters are taken as
    ; being unspecialized and gathered at the callsite.
    ;
    return make action! :frame
]</code></pre>
            <p><small>7 posts - 4 participants</small></p>
            <p><a href="https://forum.rebol.info/t/looking-into-a-usermode-pointfree/1236">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/looking-into-a-usermode-pointfree/1236</link>
          <pubDate>Wed, 30 Oct 2019 13:38:19 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1236</guid>
          <source url="https://forum.rebol.info/t/looking-into-a-usermode-pointfree/1236.rss">Looking into a *usermode* POINTFREE</source>
        </item>
        <item>
          <title>Stylistic Questions and Soft-Quoted Branching</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>Here is a small implementation of SIGN-OF to look at:</p>
<pre><code>sign-of: func [
    "Returns sign of number as 1, 0, or -1 (to use as multiplier)."
    number [any-number! money! time!]
][
    case [
        positive? number [1]
        negative? number [-1]
        default [0]
    ]
]
</code></pre>
<p>You could do this with an ELSE if you wished (I've mentioned they are <em>nearly</em> the same, but not quite... a SWITCH/ALL will always run the default, but only run the ELSE if at least one branch runs):</p>
<pre><code>case [
    positive? number [1]
    negative? number [-1]
] else [0]
</code></pre>
<p>Moving in another direction: if we accept <a href="https://forum.rebol.info/t/soft-quoted-branching-light-elegant-fast/1020">soft-quoted branching</a> you could write the body as:</p>
<pre><code>case [
    positive? number '1
    negative? number '-1
    default '0
]
</code></pre>
<p>It can get even briefer if you understand the premise of <a href="https://forum.rebol.info/t/the-fallout-from-the-switch-fallout-feature/312">fallout</a> (which is why <a href="https://forum.rebol.info/t/default-now-usable-in-case-switch/739">DEFAULT can work here at all</a>).  You can omit the default.</p>
<pre><code>case [
    positive? number '1
    negative? number '-1
    '0
]
</code></pre>
<p>We're not really set up for performance analysis at this moment.  But if we talk about what ultimately will cost the least, that's the cheapest.  It's two series, one with 3 cells that will round up to a 4 cell pool (CASE, BLOCK!, terminator)...and one with 8 cells (WORD! WORD! QUOTED! WORD! WORD! QUOTED! QUOTED! terminator).  During CASE the evaluator creates basically one frame, which is reused.</p>
<p>By contrast, if you look at the original code at the top of the post with the 3 blocks for the branches, the evaluator does much more work.  Each block as a branch sets up a new frame and iteration.  This is not to mention the storage--which is more optimal in Ren-C (which can pack single element blocks into a series node vs. needing a dynamic allocation in addition to the series node...because it uses the space that <em>would</em> be tracking information for a dynamic allocation to store the cell itself).  But even so, each series node is still the size of two cells...and you need the cell to refer to it...and you're taxing the GC a bit more and losing locality.</p>
<h2>The Moral of the Story</h2>
<p><strong>I think the moral of the story is that soft-quoted branching should probably be here to stay.</strong>  It's an unusual idea, and you don't have to use it if you don't feel like it.  The biggest backwards compatibility issue on general use is that if you want a branch to be generated from code--or a variable--you have to put it in a GROUP! or somesuch:</p>
<pre><code> if condition (branch)  ; as opposed to `if condition branch`
 if condition :branch  ; this should probably work too
</code></pre>
<p>We <em>could</em> make it so that a single WORD! containing a BLOCK! were used, that it would accept it too.  I don't know how wise that is.  Certainly accepting an ACTION! would be weird:</p>
<pre><code> code: ["Hello" print]
 if condition reverse code
</code></pre>
<p>If that were allowed, then you'd get the equivalent of:</p>
<pre><code>code: ["Hello" print]
(if condition :reverse) code
</code></pre>
<p>e.g. if condition were truthy, it would call REVERSE on the condition...and then evaluate to code.  :-/  Anyway, I don't think having to put generated branches in a GROUP! is all that terrible--people are awfully used to putting ordinary branches in BLOCK!s...is it really so oppressive if the rarer case needs delimiters too?</p>
<p>The enhancements to COMPOSE really make this work well, I think:</p>
<pre><code> compose: [  ; Ren-C won't splice unless you say (( ))
      ...
      data: either condition '(thing1) '(thing2)
      ...
 ]
</code></pre>
<p>If you were to try and do that in R3-Alpha, how would you even go about it?</p>
<pre><code> compose/only/deep: [
      ...
      data: either condition [quote (thing1)] [quote (thing2)]
      ...
 ]
</code></pre>
<p>Even in the time when EITHER/ONLY was supported, you couldn't mix and match...both branches would be evaluated or both would be literal.  Soft-quoting gives you all options:</p>
<pre><code> &gt;&gt; either 1 &lt; 2 [print "code!"] '[data]
 code!

 &gt;&gt; either 1 &gt; 2 [print "code!] '[data]
 == [data]
</code></pre>
<p>So...while I've been looking at the concept with a critical eye during its inception period, I'm about to take it for granted.  If anyone who doesn't like soft-quoted branching (who hasn't drank the <a href="https://forum.rebol.info/t/quoted-arrives-formerly-known-as-lit-bit/995/2">Red Groupthink Kool-Aid</a> <img src="https://forum.rebol.info/images/emoji/twitter/roll_eyes.png?v=9" title=":roll_eyes:" class="emoji" alt=":roll_eyes:">), they should speak up now.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/stylistic-questions-and-soft-quoted-branching/1220">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/stylistic-questions-and-soft-quoted-branching/1220</link>
          <pubDate>Mon, 30 Sep 2019 11:32:29 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1220</guid>
          <source url="https://forum.rebol.info/t/stylistic-questions-and-soft-quoted-branching/1220.rss">Stylistic Questions and Soft-Quoted Branching</source>
        </item>
        <item>
          <title>Compatibility MAP-EACH (and problems therewith)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>In trying to make a shim where MAP-EACH splices and has /ONLY, I thought the easiest way of doing it might be to redo it in terms of a COLLECT of a FOR-EACH.</p>
<p>This delves some into the ambition of Ren-C to raise the bar for Rebol, so it raises some questions.  First, let's try a naive approach:</p>
<pre><code>map-each: function [
    {https://forum.rebol.info/t/1155}
    return: [block!]
    'vars [blank! word! block!]
    data [any-series! any-path! action!]
    body [block!]
    /only
][
    collect [
        for-each :vars :data [
            keep/(only) do body
        ]
    ]
]
</code></pre>
<p>One reason this won't work correctly is because BODY is executed via a "link" of DO instead of being embedded into the body of the FOR-EACH.  That means it won't bind to the VARS variables.  And in a definitional-break-and-continue world (which I've been considering) it won't have words like CONTINUE or BREAK bound.</p>
<p>We can address that by embedding the code in, let's say we just put it in as a GROUP!</p>
<pre><code>    collect [
        for-each :vars :data compose [
            keep/(only) (as group! body)  ; only inside path, not a compose/deep
        ]
    ]
</code></pre>
<p>This simple implementation supplements the body of the MAP-EACH with additional code.  It does it by composing in the body code as a GROUP!, so that it will pick up any bindings the FOR-EACH would add.</p>
<p>Fair enough, but it has a couple of problems.  One problem: what if I said <strong>map-each keep [1 2 3] [...]</strong>?  :-/  Our supplemental body adds code that the user doesn't see at the callsite, so they don't know to avoid usage of words that are in that supplemental body for their loop variables.  This gets worse the more supplemental code you have.</p>
<h2>I think we need to expose something lower-level than FOR-EACH</h2>
<p>Really it seems like what you need here is a tool that lets you set up whatever binding object a loop is going to use, gives you a chance to bind code to that object, then lets you run the iteration independent of binding.  Something like:</p>
<pre><code>    collect [
        [context looper]: make-loop-stuff :vars :data
        bind body context
        while [looper] [
            keep/(only) do body
        ]
    ]
</code></pre>
<p>The imagined MAKE-LOOP-STUFF would give you two things back: a context to bind any code into that you wanted to see the changes to variables in, and a function you could call that would update the values of those variables as long as there was more data.</p>
<h2>....Just another epicycle of the binding problems...</h2>
<p>Binding in Rebol will always be Rube-Goldberg-like, and so the question is how to maximize the fun and minimize the annoyance, while still getting decent performance.  I think if people can think of FOR-EACH as a higher level "macro" which makes a lot of assumptions in order to be ergonomic, they can realize that writing their own loop is going to involve digging deeper.</p>
<p>Something like the pattern above could be used to implement FOR-EACH, MAP-EACH, or REMOVE-EACH...though they could retain their native optimized versions.  There's still worries about mutating the bindings on passed-in code (the <strong>bind body context</strong> above) so a "good" answer would be something like <strong>body: in context body</strong> where that was understood to not modify the original, but give a rebound "view" at a lower cost.</p>
            <p><small>5 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/compatibility-map-each-and-problems-therewith/1192">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/compatibility-map-each-and-problems-therewith/1192</link>
          <pubDate>Fri, 09 Aug 2019 19:21:38 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1192</guid>
          <source url="https://forum.rebol.info/t/compatibility-map-each-and-problems-therewith/1192.rss">Compatibility MAP-EACH (and problems therewith)</source>
        </item>
        <item>
          <title>Shim Code for Modal Arguments</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>I've described a <a href="https://forum.rebol.info/t/new-parameter-convention-concept-modal-arguments-or-the-arg/1187">new parameter convention that I call an @arg</a> which could be supported by the evaluator.  But here is a bit of code to implement the trick in present-day Ren-C:</p>
<pre><code>old-append: :append

append: function [
    series
    :nosplice [&lt;skip&gt; sym-word! sym-path! sym-block! sym-group!]
    value [&lt;...&gt; any-value!]
    /only
][
    switch type of :nosplice [
        null [old-append/(only) series take value]  ; no @... so act variadic
        sym-block! [old-append/only series as block! splicer]
        sym-group! [old-append/only series do as group! splicer]
        sym-word!
        sym-path! [old-append/only series get splicer]
   ]
]
</code></pre>
<h2>Consequences</h2>
<p>This leaves splicing the default:</p>
<pre><code>&gt;&gt; append [a b c] [d e]
== [a b c d e]
</code></pre>
<p>But if you use an @... at the callsite it offers alternate ways of requesting /ONLY:</p>
<pre><code>&gt;&gt; append [a b c] @[d e]
== [a b c [d e]]
</code></pre>
<p>The trickery though is that it <em>has to be a literal @</em>... at the callsite.  Indirectly that doesn't apply (if it comes from a reference or expression), it will append in the typical fashion, whatever that would be:</p>
<pre><code>&gt;&gt; item: @[d e]
== @[d e]

&gt;&gt; append [a b c] item
== [a b c d e]  ; or should only plain BLOCK! splice?
</code></pre>
<p>The callsite permits conventional expressions for the plain case (now an /ONLY behavior), written out as a full evaluation (e.g. the argument is not quoted):</p>
<pre><code>&gt;&gt; append [a b c] reverse copy [d e]
== [a b c e d]
</code></pre>
<p>On the other hand, the /only cases are all going through a quoted argument...but these provide variations besides an @-block:</p>
<pre><code>&gt;&gt; append [a b c] @item
== [a b c [d e]]

&gt;&gt; append [a b c] @(reverse copy item)
== [a b c [e d]]
</code></pre>
<p>And again, these variations are visible at the callsite; they don't accidentally sneak in to run code as /ONLY if your callsite didn't make it look that way just due to some indirect value:</p>
<pre><code>&gt;&gt; item: @(reverse copy item)
== @(reverse copy item)

&gt;&gt; append [a b c] item
== [a b c reverse copy item]  ; ANY-ARRAY! splice?
</code></pre>
<p>If you really do want to deliberately append an @... then you can do so with quoting (which you'd have to do for a WORD! or other evaluative type that you didn't mean "do something evaluatory with")</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/shim-code-for-modal-arguments/1185">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/shim-code-for-modal-arguments/1185</link>
          <pubDate>Tue, 23 Jul 2019 01:08:31 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1185</guid>
          <source url="https://forum.rebol.info/t/shim-code-for-modal-arguments/1185.rss">Shim Code for Modal Arguments</source>
        </item>
        <item>
          <title>Writing JavaScript natives to call the GitHub API</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>I saw an example showing that the GitHub API had been enabled to support the CORS protocol, and successfully managed to do a JavaScript fetch() of a file blob from it.  It was very cool when it worked--especially since the Base64 decoding I used was libRebol!</p>
<p>It turns out that wasn't actually necessary: What I didn't know was that GitHub had enabled fetch() on the <code>raw.github.com</code> family of URLs too (!)  So just using those URLs is much cleaner.</p>
<p>But it was a good thing to test and get working.  And I'm sure people will be wanting to make GitHub API requests of other kinds.  So here's the function I had.  It has a spec that's a Rebol block, and can be called from Rebol...but which has a body of JavaScript (that also calls back into Rebol via the libRebol JS API...!)</p>
<pre><code>github-read: js-awaiter [
    owner [text!]
    repo [text!]  ; !!! TBD: branch?
    path [text!]
]{
    let owner = reb.Spell(reb.ArgR('owner'))
    let repo = reb.Spell(reb.ArgR('repo'))
    let path = reb.Spell(reb.ArgR('path'))

    let url = "https://api.github.com/repos/" + owner + "/" + repo
        + "/contents" + path

    let response = await fetch(url)
    if (!response.ok)  // https://www.tjvantoll.com/2015/09/13/fetch-and-errors/
        throw Error(response.statusText)

    let json = await response.json()  // GitHub gives Base64 in JSON envelope

    return reb.Promise("debase/base", reb.T(json.content), reb.I(64))  // see note
}
</code></pre>
<blockquote>
<p>Note: The actual way you have to return that "promise" at this exact moment isn't as pretty, but that's what I'm working on.  Current code makes you write it as a function that calls reb.Run()</p>
<pre><code>return function () {
    return reb.Run("debase/base", reb.T(json.content), reb.I(64))
} 
</code></pre>
</blockquote>
<p>Despite needing to perform various I/O operations that need to unblock the stack, it will not return to the Rebol caller until the final result is finished.  It's a tricky process to orchestrate and do the bookkeeping of threads to allow the back and forth to make it all happen.  And when threads are NOT available, it's very tricky too!</p>
<p><em>(But the absolute trickiest bit is writing one codebase that can be built both ways, and does all that management in a non-invasive way to the Rebol core!)</em></p>
<p>Another piece of this puzzle was the code that transformed URLs, which was just a little parse rule.  It shows the use of <strong>:(...)</strong> as a way of running code and then splicing the result of the rule in.  If it's null, it vaporizes.  (There's no /blob in the raw URLs)</p>
<pre><code>parse url [
    ["https://github.com/" (raw: false) | "https://raw.github.com" (raw: true)]
    copy owner: to "/" skip
    copy repo: to "/" skip
    :(if not raw ["blob/"])
    copy branch: to "/"
    copy path: to end  ; include the leading /
] else [
    ; Not a GitHub file URL
]</code></pre>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/writing-javascript-natives-to-call-the-github-api/1114">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/writing-javascript-natives-to-call-the-github-api/1114</link>
          <pubDate>Thu, 14 Mar 2019 20:32:06 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1114</guid>
          <source url="https://forum.rebol.info/t/writing-javascript-natives-to-call-the-github-api/1114.rss">Writing JavaScript natives to call the GitHub API</source>
        </item>
        <item>
          <title>Open Your Mind: A COLLECT in PARSE Meditation</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>The first time I used CALL, I griped that it was somewhat unusable (with a complaint that basically everyone else who tried it had, my complaint was far from unique).  I would have thought that if I said <strong>call {r3 --do "print {Hello}"}</strong> that it would "do what I meant".  Instead, what it did was try and find an executable file whose name (including spaces and quotes) was <code>r3 --do "print {Hello}"</code>, and run it.</p>
<p>As crazy as that interpretation may seem on the surface, it actually came from a desire to not get involved in the details of a technical difference between Windows and POSIX.  To make a long story short: Windows <a href="https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessw">CreateProcess()</a> has a command-line parser built in, so it notices the spaces and does the quote escaping...the call would pick apart and translate something like <code>r3 --do "print \"hi\""</code> for you.  POSIX does not do this, and expects you to pass in an array with elements <code>r3</code>, <code>--do</code>, <code>print "hi"</code> that has already been processed.</p>
<p>So there was this "scary" proposition of having to write a parser in POSIX to get this to work, and all the risks it entailed.  How would you know you got it right, that you'd turned the <code>\"</code> into regular <code>"</code> and matched everything up right?  CALL was already a daunting jungle of C code, how many points of failure would you want?  <a href="https://github.com/rebol/rebol-issues/issues/2225">Shixin was rightfully fearful</a> (well, skeptical I should say) of getting into that business in C.</p>
<p><em>But we have Ren-C, and we can call it from C.</em></p>
<h2>Free Your Mind</h2>
<p>Here's how we now break those parameters up, if we happen to be on POSIX and /SHELL is not used:</p>
<pre><code>parse-command-to-argv*: function [
    {Helper for when POSIX gets a TEXT! and the /SHELL refinement not used}
    return: [block!]
    command [text!]
][
    quoted-shell-item-rule: [  ; Note: ANY because "" is legal as a quoted arg
        any [{\"} | not {"} skip]  ; escaped quotes and nonquotes
    ]
    unquoted-shell-item-rule: [some [not space skip]]

    parse command [
        collect result: [any [
            any space [
                {"} keep quoted-shell-item-rule {"}
                | keep unquoted-shell-item-rule
            ]
        ]
        any space end]
    ] else [
        fail "Could not parse command line into argv[] block."
    ]
    for-each item result [replace/all item {\"} {"}]
    return result
]
</code></pre>
<p>The C code in the module just calls this helper in the POSIX extension implementing CALL as <strong><code>rebValue("parse-command-to-argv*", command)</code></strong>.  The helper resides in the module and is only visible to it, but the C finds it because when extension natives are loaded, they remember which module they were in, and this information factors into the binding.</p>
<p>It's a Zen moment, isn't it?</p>
<p>It may not be perfect (improvements welcome).  And if it lets you down, you can always do what you used to...use CALL/SHELL and defer to the shell to do whatever-it-does with the text as its single argument.  You'd need to anyway, if your call contained any ${ENVIRONMENT_VARIABLES} you wanted to substitute, or if you wanted to invoke "dir" or "echo" or other things that only exist in "sh" or "cmd.exe".  (Of course if you run a program that way, you pay for the overhead of two processes invoked, vs. just one.)</p>
<p>But I think the main thing is just taking away that fear.  Making the solution match the size of the problem--the so called "essential complexity".  That's the goal of this exercise, and we are getting ever closer to it.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/open-your-mind-a-collect-in-parse-meditation/1100">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/open-your-mind-a-collect-in-parse-meditation/1100</link>
          <pubDate>Tue, 05 Mar 2019 14:26:18 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1100</guid>
          <source url="https://forum.rebol.info/t/open-your-mind-a-collect-in-parse-meditation/1100.rss">Open Your Mind: A COLLECT in PARSE Meditation</source>
        </item>
        <item>
          <title>Creating an EPUB file with the ZIP module</title>
          <dc:creator><![CDATA[rgchris]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>I'm using the built-in <a href="https://github.com/metaeducation/ren-c/blob/master/src/os/unzip.reb" rel="nofollow noopener">ZIP module</a> to try and build a minimal EPUB file like so:</p>
<pre><code class="lang-auto">Rebol [
    Title: "Package The Test Book"
    Date: 5-Feb-2019
    Author: "Christopher Ross-Gill"
    Rights: http://opensource.org/licenses/Apache-2.0
    Notes: [
        https://ebooks.stackexchange.com/a/1184
        {Source of Minimal eBook}
    ]
]

zip %Test.epub [
    %mimetype {application/epub+zip}

    %META-INF/container.xml {
        &lt;?xml version="1.0"?&gt;
        &lt;container version="1.0" xmlns="urn:oasis:names:tc:opendocument:xmlns:container"&gt;
            &lt;rootfiles&gt;
                &lt;rootfile full-path="OEBPS/content.opf" media-type="application/oebps-package+xml"/&gt;
            &lt;/rootfiles&gt;
        &lt;/container&gt;
    }

    %OEBPS/content.opf {
        &lt;?xml version="1.0" encoding="UTF-8" ?&gt;
        &lt;package xmlns="http://www.idpf.org/2007/opf" xmlns:dc="http://purl.org/dc/elements/1.1/" unique-identifier="db-id" version="3.0"&gt;

        &lt;metadata&gt;
            &lt;dc:title id="t1"&gt;Title&lt;/dc:title&gt;
            &lt;dc:identifier id="db-id"&gt;isbn&lt;/dc:identifier&gt;
            &lt;meta property="dcterms:modified"&gt;2014-03-27T09:14:09Z&lt;/meta&gt;
            &lt;dc:language&gt;en&lt;/dc:language&gt;
        &lt;/metadata&gt;

        &lt;manifest&gt;
            &lt;item id="toc" properties="nav" href="toc.xhtml" media-type="application/xhtml+xml" /&gt;
            &lt;item id="ncx" href="toc.ncx" media-type="application/x-dtbncx+xml" /&gt;
            &lt;item id="template_css" href="template.css" media-type="text/css" /&gt;
            &lt;item id="hello" href="1_hello.xhtml" media-type="application/xhtml+xml" /&gt;
        &lt;/manifest&gt;

        &lt;spine toc="ncx"&gt;
            &lt;itemref idref="hello" /&gt;
        &lt;/spine&gt;

        &lt;/package&gt;
    }

    %OEBPS/toc.xhtml {
        &lt;?xml version="1.0" encoding="utf-8"?&gt;
        &lt;html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops"&gt;
        &lt;head&gt;
        &lt;title&gt;toc.xhtml&lt;/title&gt;
        &lt;link href="template.css" rel="stylesheet" type="text/css" /&gt;
        &lt;/head&gt;

        &lt;body&gt;

            &lt;nav id="toc" epub:type="toc"&gt;
                &lt;h1 class="frontmatter"&gt;Table of Contents&lt;/h1&gt;
                &lt;ol class="contents"&gt;
                       &lt;li&gt;&lt;a href="1_hello.xhtml"&gt;Hello&lt;/a&gt;&lt;/li&gt;
                &lt;/ol&gt;

            &lt;/nav&gt;

        &lt;/body&gt;

        &lt;/html&gt;
    }

    %OEBPS/1_hello.xhtml {
        &lt;?xml version="1.0" encoding="utf-8"?&gt;
        &lt;html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops"&gt;
        &lt;head&gt;
        &lt;title&gt;1_hello.xhtml&lt;/title&gt;
        &lt;link href="template.css" rel="stylesheet" type="text/css" /&gt;
        &lt;/head&gt;

        &lt;body&gt;

            &lt;h1&gt;Hello World!&lt;/h1&gt;

        &lt;/body&gt;
        &lt;/html&gt;
    }

    %OEBPS/toc.ncx {
        &lt;?xml version="1.0" encoding="UTF-8" ?&gt;
        &lt;ncx version="2005-1" xml:lang="en" xmlns="http://www.daisy.org/z3986/2005/ncx/"&gt;

        &lt;head&gt;
            &lt;meta name="dtb:uid" content="isbn"/&gt;
            &lt;meta name="dtb:depth" content="1"/&gt;
        &lt;/head&gt;

        &lt;docTitle&gt;
            &lt;text&gt;&lt;/text&gt;
        &lt;/docTitle&gt;

        &lt;navMap&gt;
            &lt;navPoint id="hello" playOrder="1"&gt;
                &lt;navLabel&gt;&lt;text&gt;cover&lt;/text&gt;&lt;/navLabel&gt;
                &lt;content src="1_hello.xhtml" /&gt;
            &lt;/navPoint&gt;
        &lt;/navMap&gt;

        &lt;/ncx&gt;
    }

    %OEBPS/template.css {
        h1 {
          text-align: center;
        }
    }
]
</code></pre>
<h2>Caveats</h2>
<p>Currently it doesn't validate.</p>
<pre><code class="lang-nohighlight">$ epubcheck Test.epub
FATAL(PKG-008): Test.epub/META-INF/container.xml(-1,-1): Unable to read file 'META-INF/container.xml'.
ERROR(RSC-003): Test.epub/META-INF/container.xml(-1,-1): No rootfile tag with media type 'application/oebps-package+xml' was found in the container.

Check finished with errors
Messages: 1 fatal / 1 errors / 0 warnings / 0 info

epubcheck completed
</code></pre>
<p>Nor does the archive unpack as a <code>.zip</code> on MacOS Finder.</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/creating-an-epub-file-with-the-zip-module/1055">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/creating-an-epub-file-with-the-zip-module/1055</link>
          <pubDate>Tue, 05 Feb 2019 16:07:57 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1055</guid>
          <source url="https://forum.rebol.info/t/creating-an-epub-file-with-the-zip-module/1055.rss">Creating an EPUB file with the ZIP module</source>
        </item>
        <item>
          <title>ARITY-OF: Then and Now</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>I'm going to have to start getting kind of brutal cutting dicey things out of the system for Beta/One.  So when I ran across the ARITY-OF routine and <a href="https://github.com/metaeducation/ren-c/blob/34aa979003554fccc87482098ee817b0e401f59a/src/mezz/base-funcs.r#L678" rel="nofollow noopener">all its disclaimers and concerns</a>, I thought <em>"oh no, well this simple-seeming thing is more trouble than it's worth, to explain and document..."</em></p>
<p>Classical Rebol doesn't have it.  People who want to know the arity of a function have to get WORDS OF the function, then count up to the first refinement, and then say "done".</p>
<p>But you're not done, because if you're processing source you might have seen something like APPEND/DUP/PART.  How do you ask for the arity of that, without calling it?  Massive unsolved problem.</p>
<h2>But, wait a minute...</h2>
<p>It was unsolved <em>back then</em>.  But there's a lot to be said for doing things right.  <img src="//forum.rebol.info/images/emoji/twitter/man_mechanic.png?v=7" title=":man_mechanic:" class="emoji" alt=":man_mechanic:"></p>
<pre><code>&gt;&gt; parameters of :append
== [series value /part limit /only /dup count /line]

&gt;&gt; parameters of :append/dup
== [series value count /part limit /only /line]

&gt;&gt; parameters of :append/part
== [series value limit /only /dup count /line]

&gt;&gt; parameters of :append/part/dup
== [series value limit count /only /line]

&gt;&gt; parameters of :append/dup/part
== [series value count limit /only /line]
</code></pre>
<h2>...and so all we have to write is....</h2>
<pre><code>arity-of: function [
    "Get the number of fixed arguments to an ACTION! (if not variadic)"
    return: [integer!]
    action [action!]
][
    if variadic? :action [
        fail "ARITY-OF cannot give an answer for variadic actions"
    ]
    arity: 0
    for-each p parameters of :action [
        if refinement? :p [break]
        arity: arity + 1
    ]
    return arity
]
</code></pre>
<p>Exercise for the reader: try doing this in Rebol2/R3-Alpha/Red <img src="//forum.rebol.info/images/emoji/twitter/slight_smile.png?v=7" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
<pre><code>&gt;&gt; map-each x [
          append append/dup append/part append/dup/part append/part/dup
     ][
          arity-of get x
    ]
== [2 3 3 4 4]</code></pre>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/arity-of-then-and-now/1000">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/arity-of-then-and-now/1000</link>
          <pubDate>Mon, 07 Jan 2019 21:35:55 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1000</guid>
          <source url="https://forum.rebol.info/t/arity-of-then-and-now/1000.rss">ARITY-OF: Then and Now</source>
        </item>
        <item>
          <title>COLLECT-LINES: an adaptation story</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>Here's an interesting cookbook recipe.  Frequently, the goal of a COLLECT process is to collect a certain number of strings representing command lines, or something like that.  Each line is represented by a block, but needs to be SPACED.  This can be a bit annoying to have to say every time:</p>
<pre><code> collect [
     keep spaced [...]
     if condition [
         keep spaced [...]
     ]
 ]
</code></pre>
<p>What if you wanted to specialize COLLECT as COLLECT-LINES so it would do the SPACED automatically?</p>
<pre><code> collect-lines: adapt 'collect [
      body: compose [
           keep: adapt 'keep [value: spaced value]
           (as group! body)
      ]
  ]
</code></pre>
<p>So you're augmenting the body with a little bit of prelude code that adapts the keep.  What's nice is that by using AS you don't need to deep copy that body, you're just aliasing it.  This means that when COLLECT goes through and binds the augmented body to keep, the little adapter has the same binding...so it affects that keep.</p>
<blockquote>
<p>There's a particular finesse in Ren-C because when you put something in a stream of code using AS GROUP!, that won't synthesize anything.  If your group is empty, it will act like it's not there.</p>
<pre><code>&gt;&gt; do [1 + 2 ()]
== 3
</code></pre>
<p>That's actually pretty important for when you're doing these kinds of code splicings, you can really "opt out" of sections.</p>
</blockquote>
<p>If you're going to do it this simply, you can eliminate some of the repetition <a href="https://trello.com/c/8Bmwvwya" rel="nofollow noopener">with MY</a> (which quotes a set word on the left, and injects the value as the first parameter of what comes next).</p>
<pre><code> collect-lines: adapt 'collect [
      body: compose [
           keep: my adapt [value: my spaced]
           (as group! body)
      ]
  ]
</code></pre>
<p>That's quick and dirty enough for casual usage.  But this looks nice enough we might even want it in the box.<br>
So thinking through a few edge cases...</p>
<p>Some of the refinements to KEEP don't make sense any more, like /ONLY and perhaps /PART (you'd be passing in a block and then specifying a /PART based on the text...probably not what you meant).  You probably want each line to be on its own line when collected in the list, so /LINE should be true.  Other refinements, like /DUP can probably be left as-is.</p>
<p>So let's get rid of the refinements that don't make sense and set it up to default to a newline on each string in the collected block.  Also, you need to TRY on the value because it might be null, and then you'd want SPACED to see it as a BLANK! instead of an error, returning a null and thus preserving it:</p>
<pre><code> collect-lines: adapt 'collect [
      body: compose [
           keep: adapt specialize 'keep [
               line: true | only: false | part: _
           ] [value: spaced try :value]
           (as group! body)
      ]
  ]
</code></pre>
<p>Now we have a nice little routine:</p>
<pre><code> &gt;&gt; collect-lines [
       keep ["How" "about" "this?"]
       keep case [
           1 = 2 [["Not" "Kept"]]
           3 = 4 [["This" "Neither"]]
       ]
       keep/dup ["Pretty" "cool" "eh?"] 2
    ]
== [
    "How about this?"
    "Pretty cool eh?"
    "Pretty cool eh?"
]
</code></pre>
<p>So... how difficult would that be to do in Rebol2/R3-Alpha/Red?  And how likely are you to get it wrong while trying?</p>
<h3>One issue to think about...</h3>
<p>With the recent change to where COLLECT only creates a block if you do a KEEP of some non-null material, there was a workaround to say <code>keep []</code> as a no-op at the top of the collect body, to get the block.  That won't work here, since <code>keep []</code> will add an empty string to the collected lines.</p>
<p>Off the top of my head:</p>
<ul>
<li>
<p>Since COLLECT-LINES is not "full band" any more (it knows you don't want to collect a BLANK!), it might use BLANK! to be the "no-op, but means you kept something".  So <code>keep _</code> would execute the un-adapted <code>keep []</code> internally, yielding the same effect.</p>
</li>
<li>
<p>COLLECT-LINES could just sneak in a <code>keep []</code> before it does the specialization and always return a block, foregoing COLLECT's "null if no KEEPs" property.</p>
</li>
</ul>
<p>What's nice about actually doing these little experiments is you get to think about what pressures it puts on routines like SPACED.  Increasingly I am of the opinion that SPACED of a TEXT! should just return that text--there's almost no case where enforcing that it's a BLOCK! has value.</p>
            <p><small>6 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/collect-lines-an-adaptation-story/945">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/collect-lines-an-adaptation-story/945</link>
          <pubDate>Thu, 06 Dec 2018 21:36:37 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-945</guid>
          <source url="https://forum.rebol.info/t/collect-lines-an-adaptation-story/945.rss">COLLECT-LINES: an adaptation story</source>
        </item>
        <item>
          <title>Replacing IFs with ALLs and IF-NOTs with ANYs</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>I've known that there were cases where people used ALL to run a chain of code without using the result.  So where other languages might write:</p>
<pre><code>if (condition1 and (cond = ition2) and con(dit, ion3)))
    break;
</code></pre>
<p>Rebol programmers might say:</p>
<pre><code>all [
    condition1
    cond = ition2
    con dit ion3
    break
]
</code></pre>
<p>With conditional AND in Ren-C, you get a choice.  It seems to me that whether it's clearer or not is on a case by case basis.</p>
<p>I saw something in some Red code that was the other way around.  Imagine a negated if, which you can write in Ren-C like this if you like:</p>
<pre><code> if not condition1 and [cond != ition2] and [not con dit ion3] [
     break
]
</code></pre>
<p>But you could also use an ANY for this, with no IF:</p>
<pre><code> any [
     condition1
     cond = ition2
     con dit ion3
     break
 ]
</code></pre>
<p>Maybe I'm late to the game in thinking of using ANY in this way, to test things when you're really not intending to use the result, just to conditionally avoid running some code in later any cases.  But it brings up the cognitive question of whether you think of your code like this or not.  It's hard to say with a fake example like this.</p>
<p>In historical Rebol, if you wanted to put multiple lines in the last case of an any you could do that with a GROUP!, e.g.</p>
<pre><code> any [
     condition1
     cond = ition2
     con dit ion3
     (
         line one
         line two
     )
 ]
</code></pre>
<p>This lets you stop worrying about whether the lines of code at the end are able to affect the ANY's result  Ren-C gives you ELSE and THEN, so for the ANY case:</p>
<pre><code> any [
     condition1
     cond = ition2
     con dit ion3
 ] else [
     line one
     line two
 ]
</code></pre>
<p>But you can use THEN or ELSE with either construct, as appropriate (or you can use both).  I've found that:</p>
<pre><code>all [...] then [...]
</code></pre>
<p>...is particularly pleasing and comes up often, and is better than <code>if all [...] [...]</code> for keeping your place in the source when the ALL block is long.  It scans better.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/replacing-ifs-with-alls-and-if-nots-with-anys/925">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/replacing-ifs-with-alls-and-if-nots-with-anys/925</link>
          <pubDate>Sat, 24 Nov 2018 19:50:58 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-925</guid>
          <source url="https://forum.rebol.info/t/replacing-ifs-with-alls-and-if-nots-with-anys/925.rss">Replacing IFs with ALLs and IF-NOTs with ANYs</source>
        </item>
        <item>
          <title>BREAK and CONTINUE propagation</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>Have you ever been inside a nested loop and wanted to BREAK or CONTINUE the outer loop...not the inner one you're presently iterating?</p>
<pre><code> for-each x data [ // outer loop
     for-each y data [ // inner loop
          if some-test [
              break // !!! want this to break outer loop, d'oh
          ]
          ...
     ]
     ...
 ]
</code></pre>
<p>Well you're in luck <img src="//forum.rebol.info/images/emoji/twitter/four_leaf_clover.png?v=7" title=":four_leaf_clover:" class="emoji" alt=":four_leaf_clover:"> ...thanks to the "simple magic" <a href="https://forum.rebol.info/t/the-simple-yet-powerful-magic-of-the-loop-result-protocol/609">loop result protocol</a>, you have an answer.</p>
<pre><code> for-each x data [
     for-each y data [
          if some-test [
              break
          ]
          ...
     ] else [break]
     ...
 ]
</code></pre>
<p>If you read the details, ELSE will run <em>if-and-only-if</em> the loop breaks.  So you can feel confident putting the second BREAK in there.</p>
<p>What if you had wanted to CONTINUE the outer loop instead?  Well, all you need to do there is break the inner loop and use that signal to continue the outer loop.</p>
<pre><code> for-each x data [
     for-each y data [
          if some-test [
              break // in order to continue outer loop
          ]
          ...
     ] else [continue] // ta-da!
     ...
 ]
</code></pre>
<p>Pretty sweet, eh?  And don't miss out on how you can use OR to test for either a BREAK -or- the loop body never running due to absence of data or iterations, which comes in handy quite often.</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/break-and-continue-propagation/914">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/break-and-continue-propagation/914</link>
          <pubDate>Mon, 19 Nov 2018 05:55:49 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-914</guid>
          <source url="https://forum.rebol.info/t/break-and-continue-propagation/914.rss">BREAK and CONTINUE propagation</source>
        </item>
        <item>
          <title>Ren-C&#39;s eloquence in the face of FizzBuzz</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p><div class="lightbox-wrapper"><a class="lightbox" href="https://forum.rebol.info/uploads/default/original/1X/bfcdfb0a237ed678b4c9e3d0f043e92a076e8206.jpeg" data-download-href="https://forum.rebol.info/uploads/default/bfcdfb0a237ed678b4c9e3d0f043e92a076e8206" title="fizzbuzz-snap"><img src="https://forum.rebol.info/uploads/default/optimized/1X/bfcdfb0a237ed678b4c9e3d0f043e92a076e8206_2_670x499.jpeg" alt="fizzbuzz-snap" data-base62-sha1="rmMvvVBnn2g0ybqB0jwY0Xy24lM" width="670" height="499" srcset="https://forum.rebol.info/uploads/default/optimized/1X/bfcdfb0a237ed678b4c9e3d0f043e92a076e8206_2_670x499.jpeg, https://forum.rebol.info/uploads/default/optimized/1X/bfcdfb0a237ed678b4c9e3d0f043e92a076e8206_2_1005x748.jpeg 1.5x, https://forum.rebol.info/uploads/default/optimized/1X/bfcdfb0a237ed678b4c9e3d0f043e92a076e8206_2_1340x998.jpeg 2x" data-small-upload="https://forum.rebol.info/uploads/default/optimized/1X/bfcdfb0a237ed678b4c9e3d0f043e92a076e8206_2_10x10.png"><div class="meta"><svg class="fa d-icon d-icon-far-image svg-icon" aria-hidden="true"><use xlink:href="#far-image"></use></svg><span class="filename">fizzbuzz-snap</span><span class="informations">1998×1489 243 KB</span><svg class="fa d-icon d-icon-discourse-expand svg-icon" aria-hidden="true"><use xlink:href="#discourse-expand"></use></svg></div></a></div></p>
<p>So there's a silly problem called "FizzBuzz" which is stated very simply:</p>
<pre><code>Write a program that prints the numbers from 1 to 100.
But for multiples of three print "Fizz" instead of the number
....and for the multiples of five print "Buzz".
For numbers which are multiples of both three and five print "FizzBuzz".
</code></pre>
<p>The claim is that as easy as this problem sounds, many programmers who walk into interviews have trouble with it.  On the <a href="http://wiki.c2.com/?FizzBuzzTest">c2 programming wiki</a>, someone argues for why this might be the case:</p>
<blockquote>
<p><em>"I think Fizz-Buzz is "hard" for some programmers because (<span class="hashtag">#1</span>) it doesn't fit into any of the patterns that were given to them in school assignments, and (<span class="hashtag">#2</span>) <strong>it isn't possible to directly and simply represent the necessary tests, without duplication, in just about any commonly-used modern programming language.</strong>"</em></p>
</blockquote>
<p>But the design of Ren-C has more than enough chops for this problem!  It's particularly elegant using a <a href="https://github.com/metaeducation/ren-c/commit/26f94f6803df8d8e4895706a83658ddbf27bde28">recent change to DELIMIT</a>, including its specializations like SPACED and UNSPACED.</p>
<p>So how about that FizzBuzz?</p>
<pre><code>count-up n 100 [
    print [
         unspaced [
              if n mod 3 = 0 ["Fizz"]
              if n mod 5 = 0 ["Buzz"]
         ] else [n]
    ]
]
</code></pre>
<p>Presto...that's all it takes!!!  UNSPACED will return null if everything in its body opts out, which is the cue for the generic ELSE to run.  This brings the magic of being able to avoid duplication in the tests.  It's like every piece of problem specification corresponds to just one word in the program!</p>
<pre><code>1
2
Fizz
4
Buzz
Fizz
7
8
Fizz
Buzz
11
Fizz
13
14
FizzBuzz
16
17
Fizz
19
Buzz
Fizz
22
23
Fizz
Buzz
26
Fizz
28
29
FizzBuzz
31
32
Fizz
34
Buzz
Fizz
37
38
Fizz
Buzz
41
Fizz
43
44
FizzBuzz
46
47
Fizz
49
Buzz
Fizz
52
53
Fizz
Buzz
56
Fizz
58
59
FizzBuzz
61
62
Fizz
64
Buzz
Fizz
67
68
Fizz
Buzz
71
Fizz
73
74
FizzBuzz
76
77
Fizz
79
Buzz
Fizz
82
83
Fizz
Buzz
86
Fizz
88
89
FizzBuzz
91
92
Fizz
94
Buzz
Fizz
97
98
Fizz
Buzz</code></pre>
            <p><small>14 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/ren-cs-eloquence-in-the-face-of-fizzbuzz/904">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/ren-cs-eloquence-in-the-face-of-fizzbuzz/904</link>
          <pubDate>Wed, 14 Nov 2018 06:19:00 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-904</guid>
          <source url="https://forum.rebol.info/t/ren-cs-eloquence-in-the-face-of-fizzbuzz/904.rss">Ren-C&#39;s eloquence in the face of FizzBuzz</source>
        </item>
        <item>
          <title>About the Show &amp; Tell category</title>
          <dc:creator><![CDATA[gchiu]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>Created something short and syrupy sweet?  Then post your scripts here; not confined to infinite length one-liners!</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/about-the-show-tell-category/225">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/about-the-show-tell-category/225</link>
          <pubDate>Tue, 25 Jul 2017 04:56:41 +0000</pubDate>
          <discourse:topicPinned>Yes</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-225</guid>
          <source url="https://forum.rebol.info/t/about-the-show-tell-category/225.rss">About the Show &amp; Tell category</source>
        </item>
  </channel>
</rss>
