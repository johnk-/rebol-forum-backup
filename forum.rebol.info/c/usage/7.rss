<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Usage - AltRebol</title>
    <link>https://forum.rebol.info/c/usage/7</link>
    <description>Topics in the &#39;Usage&#39; category Questions and discussion about using Rebol.</description>
    
      <lastBuildDate>Sat, 22 Jan 2022 08:13:51 +0000</lastBuildDate>
      <atom:link href="https://forum.rebol.info/c/usage/7.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>Understanding Definitional Scoping</title>
          <dc:creator><![CDATA[DefinitionalUsername]]></dc:creator>
          <category>First Steps</category>
          <description><![CDATA[
            <p>I just started learning Red/Rebol, and I was having trouble understanding the scoping rules. I did read the <a href="https://stackoverflow.com/a/21964858" rel="noopener nofollow ugc">Stack Overflow</a> and <a href="https://en.wikibooks.org/wiki/Rebol_Programming/Advanced/Bindology" rel="noopener nofollow ugc">Bindology</a>, and I think I somewhat understand, but I'm not sure! I'd be grateful if someone can confirm the my deductions about the following code from the SE post:</p>
<pre><code class="lang-auto">rebol []

a: 1

func-1: func [] [a]

inner: context [
    a: 2
    func-2: func [] [a]
    func-3: func [/local a] [a: 3 func-1]
]

reduce [func-1 inner/func-2 inner/func-3]
</code></pre>
<ol>
<li>
<strong>Compile-time:</strong> First, when the code is compiled, a list of top-level names is created. <em>(<code>a</code>, <code>func-1</code>, <code>inner</code>)</em>
</li>
<li>
<strong>Load-time:</strong> When the code is loaded, context <strong>A</strong> is created with those symbols as members. Also, the entire code is walked through, and every occurrence of those symbols is bound to these entries. <em>(e.g., <code>a</code> inside <code>func-2</code> would be bound to the top-level <code>a</code>)</em>
</li>
<li>
<strong>Run-time:</strong> When <code>a: 1</code> is executed, the value <code>1</code> is stored in the <code>a</code>'s slot in the context.</li>
<li>The <code>func</code> keyword after <code>func-1:</code> creates a new function, and assigns it to <code>func-1</code>. However, it leaves the binding of <code>a</code> intact.</li>
<li>The <code>context</code> keyword after <code>inner:</code> creates a new context <strong>B</strong>, walks over all the block, collecting all new symbols, and inserts those in the new object.</li>
<li>
<code>a: 2</code> assigns value <code>2</code> in <code>a</code>'s slot in the new context.</li>
<li>
<code>func</code> after <code>func-2:</code> creates a function while keeping <code>a</code>'s new binding intact, and assigns it to <code>func-2</code>'s slot.</li>
<li>
<code>func</code> after <code>func-3:</code> creates a function and creates a new context <strong>C</strong> in which <code>a</code> is inserted and bound.</li>
<li>Upon execution of <code>reduce</code>, <code>func-1</code> returns <code>1</code> from context <strong>A</strong>, <code>func-2</code> return <code>2</code> from context <strong>B</strong>, and <code>func-3</code> executes <code>func-1</code> which returns <code>1</code> from context <strong>A</strong> again.</li>
</ol>
<p>So, now,  a few questions:</p>
<ul>
<li>Is the above correct? If it is,</li>
<li>How does the <code>context</code> keyword determine which set-words it should create a slot for? i.e.,
<ul>
<li>if <code>a: 2</code> didn't exist, will it still create the slot for <code>a</code> due to <code>a: 3</code> deep inside?</li>
<li>What about if <code>a:3</code> didn't exist either? Will the new context contain a slot for <code>a</code> just due to <code>a</code> inside <code>func-2</code>'s body?</li>
</ul>
</li>
<li>Did <code>context</code> bind <code>a</code> in <code>[/local a]</code> too, before <code>func</code> was executed?</li>
<li>When a new context is created, does it copy existing symbols or bindings from the older context? If not,</li>
<li>Is there a parent-child relationship between contexts, or are they free-standing? Given a context, can I chase some pointer to its parent or child?</li>
</ul>
<p>Sorry for so many questions, I think I am getting extra confused since I already have programming experience and need to unlearn some stuff before being able to grok Rebol.</p>
<p>Thank you.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/understanding-definitional-scoping/1785">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/understanding-definitional-scoping/1785</link>
          <pubDate>Sat, 22 Jan 2022 08:13:51 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1785</guid>
          <source url="https://forum.rebol.info/t/understanding-definitional-scoping/1785.rss">Understanding Definitional Scoping</source>
        </item>
        <item>
          <title>Prettier TLS State Tables (and Assessing the Cost)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>So the spec-driven TLS originally had this state table.  On the left are states and on the right is a block of the legal states you can transition to from that state (if any).</p>
<p>Here are the states for a TLS read:</p>
<pre><code>read-proto-states: [
    client-hello [server-hello]
    server-hello [certificate]
    certificate [server-hello-done server-key-exchange]
    server-key-exchange [server-hello-done]
    server-hello-done [#complete]
    finished [change-cipher-spec alert]
    change-cipher-spec [encrypted-handshake]
    encrypted-handshake [application #complete]
    application [application alert #complete]
    alert [#complete]
    close-notify [alert]
]
</code></pre>
<p><em>It seemed to me this wasn't exploiting the types all that well.</em>  We see an ISSUE! being used for <span class="hashtag">#complete</span>.  I imagined it would be better to move the issue annotation onto the state itself: <strong>If a state was represented by an ISSUE!, then that meant the state could legally be transitioned to the completion state.</strong></p>
<p>So instead of:</p>
<pre><code>encrypted-handshake [application #complete]
</code></pre>
<p>That would become:</p>
<pre><code>#encrypted-handshake [#application]
</code></pre>
<p>(Since the application state could be terminal as well.)</p>
<p>Now you know just by looking at it that <span class="hashtag">#encrypted-handshake</span> is a <em>potentially-terminal state</em>...and that's everywhere that encrypted-handshake appears.  It's not that much more typing, since you have to put an apostrophe on most uses anyway...and it helps the state "stand out".</p>
<p>Plus making the non-terminal states stand out would be good, so I turned them into tags.</p>
<p><strong>I also thought that the blocks looked a bit boring, and I didn't like having to put single elements into blocks just for the convenience of the implementation.</strong>  I tried adding arrows and letting single elements stand alone on the mapped-to side:</p>
<pre><code>read-proto-states: [
    &lt;client-hello&gt;          -&gt; &lt;server-hello&gt;
    &lt;server-hello&gt;          -&gt; &lt;certificate&gt;
    &lt;certificate&gt;           -&gt; [#server-hello-done &lt;server-key-exchange&gt;]
    &lt;server-key-exchange&gt;   -&gt; #server-hello-done
    &lt;finished&gt;              -&gt; [&lt;change-cipher-spec&gt; #alert]
    &lt;change-cipher-spec&gt;    -&gt; #encrypted-handshake
    #encrypted-handshake    -&gt; #application
    #application            -&gt; [#application #alert]
    #alert                  -&gt; []
    &lt;close-notify&gt;          -&gt; #alert
]
</code></pre>
<p>Of course, this needs to be parsed into a MAP!, so we need some code like:</p>
<pre><code>transitions: make map! []  ; map from states to block of states
state-rule: [tag! | issue!]
uparse transdialect [
    while [
        left: state-rule '-&gt; right: [
            into block! [while state-rule, &lt;input&gt;]
            | collect keep state-rule
        ]
        (append transitions :[left right])
    ]
]
</code></pre>
<h2>Improvement...Or Dialecting For The Sake of Dialecting?</h2>
<p>The general question of whether or not to use things like ISSUE! and TAG! for states as opposed to the "cleaner" WORD!s is something that is a bit controversial.</p>
<p>One issue is that there's traditionally a greater cost to comparing strings than there is to comparing words.  So <strong>state = <span class="hashtag">#encrypted-handshake</span></strong> is slower than <strong>state = 'encrypted-handshake</strong>.  The worst case scenario is equality--because all the characters have to be compared to decide if they are equal.</p>
<p>I'd like to focus more on the qualities of the source representation than worry about the performance however.</p>
<p>There's certainly a point of view where the original wasn't as "noisy".  But if you take the extreme opinion of using WORD! for everything, then the code all blurs together.</p>
<h2>Parsing Has The Benefit Of Validation</h2>
<p>When you stylize your input and do some processing of it to get it into a canonized form, that process of translating your input is a chance to check that the data is what you expect.</p>
<p>Using a generic structure doesn't just keep you from throwing in "superficial" flourishes like <strong><code>-&gt;</code></strong>, but the generality usually goes with accepting anything.  Once you have a processing step that puts you in the position of being able to validate...which is a powerful thing.</p>
<h2>I Think These Kinds of Things Are "The Point"</h2>
<p>I don't know if this particular example is the best example.  But I do think that this is what PARSE is meant for, and UPARSE is pushing things to a new level.  We should be looking for opportunities to show off this kind of idea, vs just doing what other languages do in a weird way.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/prettier-tls-state-tables-and-assessing-the-cost/1736">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/prettier-tls-state-tables-and-assessing-the-cost/1736</link>
          <pubDate>Sun, 03 Oct 2021 17:29:29 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1736</guid>
          <source url="https://forum.rebol.info/t/prettier-tls-state-tables-and-assessing-the-cost/1736.rss">Prettier TLS State Tables (and Assessing the Cost)</source>
        </item>
        <item>
          <title>Regarding The &quot;Finality&quot; Of FAIL, RETURN, etc.</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>There are some functions that by name carry a certain <em>"finality"</em>.  You don't expect there to be a way to pass them an argument that will revoke them.</p>
<p>For instance, it would be a bit weird if FAIL followed the BLANK-IN, NULL-OUT convention:</p>
<pre><code>foo: func [error [error! blank!]] [
    fail error

    print "This looks like unreachable code."
]
</code></pre>
<p>Today we don't offer that Wayne's World version of "FAIL.... NOT!"  So you have to write:</p>
<pre><code>if error [fail error]
</code></pre>
<p>I've actually been in situations where repeating the error expression is complicated by things like API handle freeing issues, to where I've considered making something like MAYBE-FAIL which would be a No-Op on BLANK!... or perhaps a refinement as FAIL/MAYBE.</p>
<p>But I've not considered the idea of making plain FAIL a no-op on blanks.  That seems wrong.</p>
<h2>Does RETURN Have A Similar "Finality"?</h2>
<p>I've written a bunch about <a href="https://forum.rebol.info/t/uparse-return-subtleties/1589/4">how I stopped worrying and learned to love UPARSE's RETURN</a>.</p>
<p>But there's something a little weird to my tastes about it being "non-final".  For example:</p>
<pre><code>&gt;&gt; uparse "aabc" [some "a" return "x" | some "a" return "b"]
== "b"  ; today's answer (also R3-Alpha's answer with PARSE)
</code></pre>
<p>When it reached the point of RETURN "X", there were two potential interpretations:</p>
<ol>
<li>
<p><em>"Okay, it's time to return!  Let's see if this rule matches or not...and if not, we're returning NULL!"</em></p>
</li>
<li>
<p><em>"It might be time to return if this rule matches.  If it doesn't match, pretend we were never asked to return."</em></p>
</li>
</ol>
<p>Today we have (2).  It's strictly more powerful... as you can get (1) with <strong>return opt "x"</strong>.</p>
<pre><code>&gt;&gt; uparse "aabc" [some "a" return opt "x" | some "a" return opt "b"]
; null
</code></pre>
<p>Note also that if your RETURN value is in a GROUP! and evaluated as DO code instead of a rule, it will always succeed...and hence always final.  It's only when you pass a rule that it can get revoked.</p>
<p>As with needing to write <strong>if error [fail error]</strong>, if we switched to parse-RETURN-finality that would mean more code for opting out:</p>
<pre><code>; opting out in RETURN-non-final style
uparse data [... return [your rule here] ...]

; opting out in RETURN-final style
uparse data [... result: [your rule here] return (result) ...]
</code></pre>
<p><strong>But I still feel weird about RETURN in PARSE being something that can just be opted out of by the nature of its argument.</strong></p>
<p>And so far, every time I've wanted to use RETURN it has been either a RETURN of a GROUP! (thus unconditional) or a RETURN OPT.</p>
<p>So I'm thinking of making RETURN "final"...if you give it a rule that doesn't match it returns NULL.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/regarding-the-finality-of-fail-return-etc/1735">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/regarding-the-finality-of-fail-return-etc/1735</link>
          <pubDate>Sun, 03 Oct 2021 15:49:20 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1735</guid>
          <source url="https://forum.rebol.info/t/regarding-the-finality-of-fail-return-etc/1735.rss">Regarding The &quot;Finality&quot; Of FAIL, RETURN, etc.</source>
        </item>
        <item>
          <title>There Came an ECHO</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>I just fixed a bug in Sea of Words...which hopefully means it's a little more trustworthy.</p>
<p>It seemed like a good time to add the ECHO feature I've talked about.</p>
<pre><code>&gt;&gt; echo It's this feature, which I've described in the past.
It's this feature, which I've described in the past.
</code></pre>
<p>ECHO is a variadic function which processes what you pass it to the end of line.  If you prefer, you can also use a BLOCK!.</p>
<pre><code>&gt;&gt; echo [A block allows
    you to put an arbitrary number
    of newlines]
A block allows you to put an arbitrary number of newlines

&gt;&gt; echo [Or two echos] echo [on the same line]
Or two echos
on the same line
</code></pre>
<p>There is a variable substitution mechanism so you can use @ to point out variables or expressions.</p>
<pre><code>&gt;&gt; x: 10
&gt;&gt; echo The value is @x
The value is 10

&gt;&gt; echo The doubled value is @(x * 2)
The doubled value is 20
</code></pre>
<h2>It's Shorter!</h2>
<p>Can't argue against that.</p>
<pre><code>print ["You have written" num-lines "lines of code."]

echo [You have written @num-lines lines of code.]

echo You have written @num-lines of code.
</code></pre>
<h2>The API Benefits</h2>
<p>Not needing quotes helps API calls:</p>
<pre><code>rebElide("print [{You have written}", num_lines, "{lines of code.}]");

rebElide("echo [You have written", num_lines, "lines of code.]");

rebElide("echo You have written", num_lines, "lines of code.");
</code></pre>
<p>It's the kind of change that opens up the choose-your-own-adventure of syntax to let you build a system more like bash, or less like bash.  It's an important decoupling of the use of words from the creation of variables.  So, onward.</p>
            <p><small>8 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/there-came-an-echo/1722">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/there-came-an-echo/1722</link>
          <pubDate>Sun, 19 Sep 2021 17:05:11 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1722</guid>
          <source url="https://forum.rebol.info/t/there-came-an-echo/1722.rss">There Came an ECHO</source>
        </item>
        <item>
          <title>Running into issues with PARSE</title>
          <dc:creator><![CDATA[RayMPerry]]></dc:creator>
          <category>First Steps</category>
          <description><![CDATA[
            <p>Hi. I'm new to Ren-C and have been trying to get this simple parser to work.</p>
<p>(For context, <code>MOCK_DATA.csv</code> contains 1000 rows of "First Name, Last Name, Email, Date of Birth".)</p>
<p><div class="lightbox-wrapper"><a class="lightbox" href="https://forum.rebol.info/uploads/default/original/1X/f541999fd2a7af1257d0701a8d2ceb52c3e9bf5c.png" data-download-href="https://forum.rebol.info/uploads/default/f541999fd2a7af1257d0701a8d2ceb52c3e9bf5c" title="2021-09-12_22-23"><img src="https://forum.rebol.info/uploads/default/optimized/1X/f541999fd2a7af1257d0701a8d2ceb52c3e9bf5c_2_690x196.png" alt="2021-09-12_22-23" data-base62-sha1="yZDwIV9AxGIyq4mlMnwWFR32k1e" width="690" height="196" srcset="https://forum.rebol.info/uploads/default/optimized/1X/f541999fd2a7af1257d0701a8d2ceb52c3e9bf5c_2_690x196.png, https://forum.rebol.info/uploads/default/optimized/1X/f541999fd2a7af1257d0701a8d2ceb52c3e9bf5c_2_1035x294.png 1.5x, https://forum.rebol.info/uploads/default/optimized/1X/f541999fd2a7af1257d0701a8d2ceb52c3e9bf5c_2_1380x392.png 2x" data-small-upload="https://forum.rebol.info/uploads/default/optimized/1X/f541999fd2a7af1257d0701a8d2ceb52c3e9bf5c_2_10x10.png"><div class="meta">
<svg class="fa d-icon d-icon-far-image svg-icon" aria-hidden="true"><use xlink:href="#far-image"></use></svg><span class="filename">2021-09-12_22-23</span><span class="informations">1604Ã—456 56.2 KB</span><svg class="fa d-icon d-icon-discourse-expand svg-icon" aria-hidden="true"><use xlink:href="#discourse-expand"></use></svg>
</div></a></div></p>
<p>The questions I have are:</p>
<ol>
<li>How do I read this error?</li>
<li>Where should I be looking for valid words/syntax?</li>
</ol>
<p>Thanks in advance.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/running-into-issues-with-parse/1716">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/running-into-issues-with-parse/1716</link>
          <pubDate>Mon, 13 Sep 2021 03:28:41 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1716</guid>
          <source url="https://forum.rebol.info/t/running-into-issues-with-parse/1716.rss">Running into issues with PARSE</source>
        </item>
        <item>
          <title>Taking Advantage of DELIMIT&#39;s BLOCK! Behavior and GET-BLOCK!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>I finally put my foot down and said that BLOCK! in DELIMIT has the behavior of <em><strong>don't evaluate, just squoosh everything together.</strong></em></p>
<pre><code>&gt;&gt; spaced ["abc" [d e "f"] "ghi"]
== "abc def ghi"
</code></pre>
<p>You can always REDUCE if you want evaluations, but there's also GET-BLOCK!...</p>
<pre><code>&gt;&gt; spaced ["abc" :["something" 1 + 2] "ghi"]
== "abc something3 ghi"
</code></pre>
<p>And with the magic of GET-BLOCK! branches, you can even opt in or out of these things!  Don't forget to use COMMA! if you think it will look better...</p>
<pre><code>&gt;&gt; spaced ["abc" if true :["something" 1 + 2] "ghi"]
== "abc something3 ghi"

&gt;&gt; spaced ["abc", if false :["something" 1 + 2], "ghi"]
== "abc ghi"
</code></pre>
<h2>Let's Look At What Old Code Had To Do</h2>
<p>Here's some code for making a log file name from pieces in the tests:</p>
<pre><code>log-file: log-file-prefix

if code-checksum [
    append log-file "_"
    append log-file copy/part skip mold code-checksum 2 6
]

append log-file "_"
append log-file copy/part skip mold test-checksum 2 6

append log-file ".log"
log-file: clean-path log-file
</code></pre>
<p>How about we tidy that up?</p>
<h2>Here Is What We Can Confidently Write In The New Way</h2>
<pre><code>log-file: clean-path unspaced [
    log-file-prefix
        if code-checksum :["_", copy/part (skip mold code-checksum 2) 6]
        "_", copy/part (skip mold test-checksum 2) 6, ".log"
]
</code></pre>
<p><strong>Not only is it cleaner, it's more efficient!</strong>  This lets us build as we go along, without having to keep expanding string memory on each APPEND...fewer function calls.  It's better all around!</p>
<p>I think we can make a JOIN using the "REPEND" replacement optimization equally efficient:</p>
<pre><code>log-file: clean-path join log-file-prefix :[
    if code-checksum :["_", copy/part (skip mold code-checksum 2) 6]
    "_", copy/part (skip mold test-checksum 2) 6, ".log"
]
</code></pre>
<h2>It Could Be Even More Efficient, If We Wanted...</h2>
<p>Given the GET-BLOCK! optimizations, a minor tweak could boost things:</p>
<pre><code>log-file: clean-path unspaced [
    log-file-prefix
        if code-checksum ':["_", copy/part (skip mold code-checksum 2) 6]
        "_", copy/part (skip mold test-checksum 2) 6, ".log"
]
</code></pre>
<p>It's a subtle difference, but we're having the IF statement evaluate to a GET-BLOCK!...instead of having a branch that evaluates a GET-BLOCK! to make a block.</p>
<p>We can make DELIMIT evaluate get-blocks as it goes, folding them into the output without generating intermediate series...much like REPEND.</p>
<p>This could be a little wild, in terms of performing evaluations when you didn't intend them:</p>
<pre><code>data: [a b c :[format hard drive]]

...

for-each item data [
    print ["The value is" data]
]
</code></pre>
<p>But that's really just the tip of the iceberg on how many ways the system is not safe against injection attacks.  But if you're working in a secure situation, you could use a guarded layer whenever dealing with external data, to limit execution.  I think that concept (which I have called "Build Your Own Safety") is likely what people who want to use the language in more secure scenarios would have to do.</p>
<p>(After all, even the most secure programs have to at some point run on an "insecure" CPU.  A flexible and fast Ren-C could be the basis for designing a more secure language on top of it...)</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/taking-advantage-of-delimits-block-behavior-and-get-block/1679">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/taking-advantage-of-delimits-block-behavior-and-get-block/1679</link>
          <pubDate>Mon, 23 Aug 2021 01:10:45 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1679</guid>
          <source url="https://forum.rebol.info/t/taking-advantage-of-delimits-block-behavior-and-get-block/1679.rss">Taking Advantage of DELIMIT&#39;s BLOCK! Behavior and GET-BLOCK!</source>
        </item>
        <item>
          <title>A Lot To UNPACK: (Replacing the SET of REDUCE BLOCK! Idiom)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>We've fretted a lot about the result of REDUCE when an expression produces something that can't be put in a block.  At first this was just NULL.  But now it's all BAD-WORD! isotope forms.</p>
<p>One reason to fret is the historical idiom of setting multiple values in a block.  This has been done with a SET of a REDUCE.  Something along the lines of:</p>
<pre><code>&gt;&gt; x: 3 + 4
== 7

&gt;&gt; set [a b] reduce [10 + 20 x]
== [30 7]

&gt;&gt; a
== 30

&gt;&gt; b
== 7
</code></pre>
<p>It's your choice to reduce the values or not.  If you don't involve REDUCE then the mechanics would all work out.  But once you get NULLs and isotopes, the reduced block can't store the values to convey them to the SET...</p>
<h2>But What If A Single Operation Did Both...?</h2>
<p>Let's imagine we have instead something called UNPACK that by default reduces.  Imagine it quotes a SET-BLOCK! on its left.</p>
<pre><code>&gt;&gt; x: 3 + 4
== 7

&gt;&gt; [a b]: unpack [10 + 20 x]
== 30

&gt;&gt; a
== 30

&gt;&gt; b
== 7
</code></pre>
<p>UNPACK manages the evaluation one expression at a time, instead of using REDUCE.  So as it goes it can set the variables to NULL or isotopes.  And by following the multi-return convention of returning the first value, you avoid ever needing to synthesize a block aggregating all the results together.</p>
<pre><code>&gt;&gt; [a b]: unpack case [
       1 = 1 [
           print "This is pretty slick..."
           [select [a 10] 'b, 1 + 2]
       ]
    ] else [
        print "This won't run because the ELSE gets a BLOCK!"
        print "Which is what you want, because the ELSE should be"
        print "what runs if no CASE was matched and have the option"
        print "of providing the block to UNPACK"
    ]
 This is pretty slick...
 ; null

&gt;&gt; a
; null

&gt;&gt; b
== 3
</code></pre>
<h2>@[...] can Even Avoid A REDUCE</h2>
<p>If you already have a block in reduced or literal form, how would you tell the UNPACK about that?  It could be a refinement like UNPACK/ONLY.  BUT...what if that were signaled with the @ block type?</p>
<pre><code>&gt;&gt; [a b]: unpack @[1 +]
== 1

&gt;&gt; a
== 1

&gt;&gt; b
== +
</code></pre>
<p>A real aspect of power in this approach is the ability to mix and match.  For instance you could have some branches in a CASE which have already reduced data and others that don't, and they could all participate with the same UNPACK operation.</p>
<pre><code>[op1 op2]: unpack case [
    ... [
        print "This branch uses values as-is"
        @[+ -]
    ]
    ... [
       print "This branch needs evaluation"
       [operators.1, pick [- /] op-num]
   ]
]
</code></pre>
<h2>Cool Dialecting Twists</h2>
<p>It seems to me nice to safeguard that you're not throwing away values:</p>
<pre><code>&gt;&gt; [a b]: unpack [1 2 3]
** Error: Too many values for vars in UNPACK (use ... if on purpose)
</code></pre>
<p>As the error says, though, we could indicate we're fine with this through a special syntax:</p>
<pre><code>&gt;&gt; [a b ...]: unpack [1 2 3]
== 1

&gt;&gt; a
== 1

&gt;&gt; b
== 2
</code></pre>
<p>(It's not as sketchy when you have too few values, because you can set the extra variables to unset...which will presumably trigger awareness of a problem at some point.)</p>
<p>Borrowing from multi-return: I think the idea of "circling" values to say which is the one you want the overall expression to evaluate to is a neat idea.</p>
<pre><code>&gt;&gt; [a @b]: unpack [1 2]
== 2
</code></pre>
<h2>And For Show And Tell...</h2>
<p>How hard is it to write such a thing, you ask?  In Ren-C it's super easy, barely an inconvenience:</p>
<pre><code>unpack: enfixed func [
    'vars [set-block!]
    block [block! quoted!]
][
    let result': ~unset~
    reduce-each val block [
        if vars.1 = '... [continue]  ; ignore rest, but keep reducing
        if tail? vars [fail "Too many values in UNPACK (use ...)"]
        if not blank? vars.1 [
            set vars.1 unmeta ^val
            if unset? the result' [result': ^val]
        ]
        vars: my next
    ]
    if vars.1 = '... [
        if not last? vars [fail "... only at the tail of UNPACK vars"]
    ] else [
        for-each var vars [  ; if not enough values for variables, unset
            if not blank? var [unset var]
        ]
    ]
    return unmeta result'
]
</code></pre>
<p>If the ^ and UNMETA seem confusing, the only thing you need to think about is that the META protocol helps you out when you're trying to deal with a situation of storing a value that can be anything...and you need to differentiate a state.  I'm making the result "meta" so that I can use plain unset to signal that it hasn't been assigned yet.  I could make a separate boolean variable instead, but then I'd have another variable and I'd have to GET/ANY the result...</p>
<p>I'm sure people will start getting the hang of it!  <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
            <p><small>8 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/a-lot-to-unpack-replacing-the-set-of-reduce-block-idiom/1634">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/a-lot-to-unpack-replacing-the-set-of-reduce-block-idiom/1634</link>
          <pubDate>Thu, 08 Jul 2021 07:44:41 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1634</guid>
          <source url="https://forum.rebol.info/t/a-lot-to-unpack-replacing-the-set-of-reduce-block-idiom/1634.rss">A Lot To UNPACK: (Replacing the SET of REDUCE BLOCK! Idiom)</source>
        </item>
        <item>
          <title>Building on VS 2019</title>
          <dc:creator><![CDATA[Brett]]></dc:creator>
          <category>First Steps</category>
          <description><![CDATA[
            <p>Thought I'd have a look at the newest ren-c, but I tried and failed to build on VS 2019.  Wondering if builds with Visual Studio 2019 should be working or if that's on hold for now?</p>
<p>If it's on hold until a request, don't spend a lot of time trying to get it working for just me as my immediate interest and priority now is in end user business tools and integration for myself and my wife rather than language work per se. I.e web api's and <a href="http://vb.net">vb.net</a> because I need whip up things in languages I'm familiar with to get things done with little time.</p>
<p>What I did:</p>
<ul>
<li>
<p>Copied r3-windows-x86-8994d23.exe to ./prebuilt</p>
</li>
<li>
<p>Installed VS C++ tools (clicked the box that looked right).</p>
</li>
<li>
<p>Run a command file with the following:</p>
<p>call "C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Auxiliary\Build\vcvars64.bat"<br>
set R3_MAKE=C:\Projects\ren-c\prebuilt\r3-windows-x86-8994d23.exe<br>
"%R3_MAKE%" ../make.r config: ../configs/vs2019-x64.r debug: asserts optimize: 2</p>
</li>
</ul>
<p>What I got was:</p>
<pre><code>...
Dynamic extensions
** Script Error: generate has no value
** Where: switch for-each do catch either else _ do
** Near: [rebmake visual-studio ~~ generate (x86)]
** File: ../make.r
** Line: 871
</code></pre>
<p>Then I changed the line in make for the vs2019 target from:</p>
<pre><code>rebmake/visual-studio/generate/(x86) output-dir solution
</code></pre>
<p>to:</p>
<pre><code>rebmake/makefile/generate/(x86) output-dir solution
</code></pre>
<p>and got a different error, so then I thought I'd ask here, since I'm clueless about compiling with C, C++.</p>
<p>Thank you.</p>
            <p><small>5 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/building-on-vs-2019/1632">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/building-on-vs-2019/1632</link>
          <pubDate>Wed, 07 Jul 2021 02:58:57 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1632</guid>
          <source url="https://forum.rebol.info/t/building-on-vs-2019/1632.rss">Building on VS 2019</source>
        </item>
        <item>
          <title>Should Built-In Constructs Leverage More &quot;Reserved Words&quot;?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>I was looking at an old proposal for using <strong>|</strong> in PRINT to mean "newline".</p>
<pre><code>print [
    "DESCRIPTION:" |
    tab, any [description, "(undocumented)"] |
    tab (uppercase word) {is} classification #"."
]
</code></pre>
<p>That was taken off the table due to <strong>|</strong> being used as an expression barrier.  But COMMA! is doing a much better job of that, so it's back in the realm of possibility.</p>
<p>And I was also looking at some API code in ODBC like this:</p>
<pre><code>rebValue(
    "switch @", ARG(encoding), "[",
        "'utf-8 [", rebI(CHAR_COL_UTF8), "]",
        "'ucs-2 [", rebI(CHAR_COL_UTF16), "]",
        "'utf-16 [", rebI(CHAR_COL_UTF16), "]",
        "'latin-1 [", rebI(CHAR_COL_LATIN1), "]",
    "] else [",
        "fail {ENCODING must be UTF-8, UCS-2, UTF-16, or LATIN-1}"
    "]"
);
</code></pre>
<p>It made me wonder what if SWITCH let you use something like, say, fat arrow:</p>
<pre><code>rebValue(
    "switch @", ARG(encoding), "[",
        "'utf-8 =&gt;", rebI(CHAR_COL_UTF8),
        "'ucs-2 =&gt;", rebI(CHAR_COL_UTF16),
        "'utf-16 =&gt;", rebI(CHAR_COL_UTF16),
        "'latin-1 =&gt;", rebI(CHAR_COL_LATIN1),
    "] else [",
        "fail {ENCODING must be UTF-8, UCS-2, UTF-16, or LATIN-1}"
    "]"
);
</code></pre>
<h2>Are Core Constructs Underplaying Their Hand?</h2>
<p>I've felt for a long time that PRINT is not strong enough, because it hasn't taken things like TAG! away to signal format changes (colors?).</p>
<p>And when I look at the difference we get in SWITCH above, esp in the API, it makes me wonder if something like that is appropriate.  Though maybe the @ symbol is better to be pushed further to this purpose as a legal branch type...</p>
<p>...anyway the details aren't important.  I guess I'm asking more <em>"could we make a better language if we were more willing to steal words"</em>.</p>
<p>Do we need distinctions...such as "core switch" and "rich switch", and then let people pick which they use?  Where they're expected to hack up the switch to customize it to their tastes?</p>
<p>(Just wanted to put this out there, as I'm deleting a note about | as newline in PRINT on the Trello.)</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/should-built-in-constructs-leverage-more-reserved-words/1622">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-built-in-constructs-leverage-more-reserved-words/1622</link>
          <pubDate>Sat, 05 Jun 2021 16:47:02 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1622</guid>
          <source url="https://forum.rebol.info/t/should-built-in-constructs-leverage-more-reserved-words/1622.rss">Should Built-In Constructs Leverage More &quot;Reserved Words&quot;?</source>
        </item>
        <item>
          <title>The 2021 Philosophy of NULL vs. BLANK! vs. BAD-WORD!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>I was looking at rebmake code where many variables had been assigned to a BLANK!:</p>
<pre><code>extension-class: make object! [
    class: #extension
    name: _
    loadable: yes  ; can be loaded at runtime
    modules: _
    source: _  ; main script
    depends: _  ; additional C files compiled in
    requires: _  ; it might require other extensions
    ...
]
</code></pre>
<p>It struck me that the code had to take a lot of precautions to wind up not putting these real BLANK! values into blocks.  If something like <strong><code>depends</code></strong> can be-a-BLOCK-or-not, then when you write code like <strong>append items depends</strong> there's always the risk that it's still a blank.  You had to OPT it:</p>
<pre><code>append items opt depends  ; if depends was a BLANK!, make it a NULL
</code></pre>
<p>That's easy to forget, and a nightmare to go back and find where the blanks are coming from...since there was no error-in-the-moment.  There had been functions created to hunt and check through blocks for BLANK!s, since it was a common way to get things to trip up...but you were doing it all after-the-fact, when it was too late.</p>
<p><strong>What I've been talking about sounds like a much better plan</strong>:</p>
<ul>
<li>
<p>Make these kinds of things NULL to start off with</p>
</li>
<li>
<p>Have it so that APPEND and friends will error if you append a NULL, but perform a no-op if you append a BLANK! (if not quoted or /ONLY)</p>
</li>
<li>
<p>Use TRY at the callsites that want to show that they are wishing to opt-out of an append in the cases where they really were aware the value could be NULL.</p>
</li>
</ul>
<p>I tried it, and indeed it did seem like a much better plan.  Unfortunately... <em>I forgot that the reason it had been done this way was that the bootstrap executable errored when you accessed plain NULL variables, because those were considered "unset".</em>  <img src="https://forum.rebol.info/images/emoji/twitter/man_facepalming.png?v=9" title=":man_facepalming:" class="emoji" alt=":man_facepalming:"></p>
<p>That historical accident aside...the exercise showed the unique value of what NULL does today...as a <em>conditionally-false</em> and <em>non-valued</em> thing.  If we tried to make anything else serve this role (let's say the unfriendly BAD-WORD! <strong>~null~</strong>) then things would be twisting out of shape to accomplish it.</p>
<h2>There's No Single Answer To What To Initialize Variables To</h2>
<p>A BAD-WORD! is a good choice when you really expect something to happen before anybody even looks at the variable.</p>
<pre><code>  config: ~initialize-system-not-called~

  initialize-system: func [
      {Let's say this function reads the config file}
  ][
      ...
      config: [...]
  ]
</code></pre>
<p>This causes a nice labeled message anytime someone references CONFIG too early.  We're now at the point where that error happens on GET-WORD! or plain WORD!...which has the nice property of making GET-WORD! clearly convey that you intend to defuse a function execution.</p>
<p>Going this route would create a pain point for anyone who thought they were going to test for whether you had a config initialized by testing <strong>if config [...]</strong>.  So that has to be considered as whether it's what you want.</p>
<p>Because on the other hand, you should use NULL as the initialization for something you may run some code and find it doesn't assign, and you want to be able to test that.</p>
<pre><code> directory: null

 for-each [key val] config [
     if key = 'directory [
         if directory [
             fail ["Directory was already set by config:" directory]
         ]
         directory: val
     ]
 ]
</code></pre>
<p>This will be a better choice if you want most operations to fail if they try to use the directory that hasn't been assigned.  BLANK! is a more permissive choice, as it would be willing to APPEND and be a no-op (for example).   More functions are willing to take BLANK!.  It's easy to convert a NULL to a BLANK! with TRY, so you aren't far from it when you need it.</p>
<p>You still might want to initialize variables to blank, if that suits your thoughts of what's convenient.  You'll get fewer errors to point out you're using something you haven't "assigned meaningfully", but maybe that is desirable for your case.</p>
<p>The Rebmake case shows a situation where the NULL is likely better, even if BLANK!s vaporize in appends by default.  Because an APPEND/ONLY ... VAR or a APPEND ... @ VAR will still append that blank you may not want.</p>
<h2>Literalizing Operators Further Justify NULL</h2>
<p>NULL has  a critical property as a non-valued thing with the literalizing operators.</p>
<pre><code>&gt;&gt; ^ if false [&lt;let's make a null&gt;]
; null

&gt;&gt; ^ ^ if false [&lt;let's make a null&gt;]
; null
</code></pre>
<p><strong>No matter how many times you literalize a NULL, the result is still NULL.</strong>  If we tried to make any <em>value</em> interact with the literalized domain, we wouldn't have this, and it is critical.</p>
<p>I've said before and I've said it again: If you like Ren-C features (let's say, UPARSE?) then you like NULL whether you realize it or not.  It's foundational.</p>
<h2>But Fewer Operations Will Be Taking NULL Now...</h2>
<p>It was already the case that not a lot of operations would take NULL.  In the interest of erroring, the <a href="https://forum.rebol.info/t/blank-in-null-out-convention-vs-logic-returning-actions/954">BLANK!-in-NULL-out convention</a> had been established and working well.</p>
<p>Now APPEND and friends are joining the fold, also taking the meaning that BLANK! is a request to "opt-out"...with NULL representing an error.  You'll be required to TRY arguments to opt out of the null cases.</p>
<p>There's some question of how this should impact something like COMPOSE.  I feel like as a dialect, COMPOSE is in something of a different space.  It's not a "function taking arguments", it's a template for code at a high level.  I think the choice for dialects to vaporize NULLs is something unique to their flow and operation...a bit different from function arguments.</p>
<p>In other words, I still am quite attached to:</p>
<pre><code> &gt;&gt; compose [&lt;a&gt; (if false [&lt;b&gt;]) &lt;c&gt;]
 == [&lt;a&gt; &lt;c&gt;]
</code></pre>
<p>I don't want to have to write:</p>
<pre><code> &gt;&gt; compose [&lt;a&gt; (try if false [&lt;b&gt;]) &lt;c&gt;]
 == [&lt;a&gt; &lt;c&gt;]
</code></pre>
<p>And I also don't want to have to worry about all the quoting operations to get things as /ONLY by default inside COMPOSE.  The idea of using <strong>(( ))</strong> is that it could go to the semantics of splicing, and then blanks would vaporize and you'd have to quote any evaluative values...</p>
<p>More discussion on this to come.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/the-2021-philosophy-of-null-vs-blank-vs-bad-word/1604">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-2021-philosophy-of-null-vs-blank-vs-bad-word/1604</link>
          <pubDate>Fri, 14 May 2021 14:44:05 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1604</guid>
          <source url="https://forum.rebol.info/t/the-2021-philosophy-of-null-vs-blank-vs-bad-word/1604.rss">The 2021 Philosophy of NULL vs. BLANK! vs. BAD-WORD!</source>
        </item>
        <item>
          <title>Debunking the Arity-1 MAKE</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>Rebol2, R3-Alpha, and Red embrace the idea of an arity-1 MAKE, that you use for any type.</p>
<p>When a single parameter seems insufficient to create a datatype, it just stuffed the two things into a BLOCK!.  That led to things like this FUNC definition in the bootstrap for R3-Alpha...which is a weird two-step process.  It wants to copy the spec/body in most cases, but the mezzanine optimizes and does not write code in a style that would need to copy the spec/body...so there's a "funco" helper:</p>
<pre><code>funco: make function! [[
    {Non-copying function constructor (optimized for boot).}
    spec [block!] {Help string (opt) followed by arg words}
    body [block!] {The body block of the function}
][
    make function! reduce [spec body]
]]

func: funco [
    {Defines a user function with given spec and body.}
    spec [block!] {Help string (opt) followed by arg words}
    body [block!] {The body block of the function}
][
    make function! copy/deep reduce [spec body]  ; (now it deep copies)
]
</code></pre>
<h2>Is This Just "Make-Work"? (pun intended)</h2>
<p>Imagine a different approach in which FUNC itself is just a native that takes two parameters and makes a function out of it.  There would be several benefits:</p>
<ul>
<li>
<p>You don't need to run a REDUCE to make a block that you're ultimately just going to separate into two blocks.  That's wasted space and computation.  The FUNC passes through the two blocks separately.</p>
</li>
<li>
<p>You avoid looking into a table of MAKE dispatchers, breaking down a block and re-type checking it to make sure it's a block of exactly two other blocks.  The FUNC type checking takes care of that on the independent proeprties.</p>
</li>
<li>
<p>If there's a low-level property such as not copying the blocks passed in, that could be handled by a refinement (/NOCOPY) which makes the distinction clearer in the cases that use it.</p>
</li>
</ul>
<p>Faster, clearer.  No one really uses the "polymorphism" of <strong>make some-type some-definition</strong> without really knowing what type or definition is, right?  That seems essentially meaningless.</p>
<h2>So What Is The Theoretical Value of Arity-1 MAKE?</h2>
<p>I'd assumed that the actual theoretical value was something along the lines of <em>having a serialization form of every type as a BLOCK!</em> (or other simple type)</p>
<p>Perhaps the reasoning went:</p>
<ul>
<li>
<em>if</em> you can <em>create</em> any type from a single argument like a BLOCK!</li>
<li>...then that means you can MOLD any instance of a value into that same representation.</li>
</ul>
<p>So what I did in the early days of Ren-C is I tried to enforce a correspondence between <strong>make function! [...]</strong> and <strong>#[function! [...]]</strong>.  The code that was dispatched by MAKE was the same code that constructing a molded function would call.</p>
<p><em>That was a nice thought, but due to binding, it doesn't actually work.</em>  Basic disproof:</p>
<pre><code>&gt;&gt; obj: make object! [y: 10]

&gt;&gt; f: func [x] bind [x + y] obj

&gt;&gt; y: 100

&gt;&gt; molded: mold f
== "#[action! [[x] [x + y]]]"

&gt;&gt; g: load molded

&gt;&gt; f 1
== 11

&gt;&gt; g 1
== 101
</code></pre>
<p>The only real way to preserve the loaded connections of things is in some kind of binary serialization format (like "redbin" is pursuing)...or to always be storing the session's memory as a persistent VM state (like Smalltalk's Squeak and such).</p>
<h3>...any counter-arguments in defense of the usefulness of Arity-1 Make?</h3>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/debunking-the-arity-1-make/1591">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/debunking-the-arity-1-make/1591</link>
          <pubDate>Fri, 30 Apr 2021 16:54:31 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1591</guid>
          <source url="https://forum.rebol.info/t/debunking-the-arity-1-make/1591.rss">Debunking the Arity-1 MAKE</source>
        </item>
        <item>
          <title>Circling Multi-Returns: Choose Which Is Expression Result</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>I'm still evaluating how well the idea behind multiple-returns works...but by and large, they seem to be working pretty well.</p>
<p>So I've gone ahead and moved them from the "usermode prototype" to natively implementing them as part of the evaluator, which speeds them up by a factor of... a lot.</p>
<p>While doing so, I added a new feature of being able to "circle" which result will be the value of the overall expression.  Previously this was always the "main" return value, but now you can pick another via a SYM-WORD!.</p>
<p>Here's a function with a secondary return value to demonstrate with:</p>
<pre><code>multi: func [
    return: "Main return value"
        [integer!]
    secondary: "Secondary return value"
        [integer!]
][
    if secondary [  ; NULL if not asked for via multi-return (or refinement)
        set secondary 20  ; reminder: `set # ...` is a no-op
    ]
    return 10
]
</code></pre>
<p>Traditionally you could ask for both results, and the overall result would be the first return:</p>
<pre><code>&gt;&gt; [a b]: multi
== 10  ; defaults to same value as first result, e.g. a

&gt;&gt; a
== 10

&gt;&gt; b
== 20
</code></pre>
<p>But now you can use a SYM-WORD! instead to ask for a different result, e.g. the second:</p>
<pre><code>&gt;&gt; [a @b]: multi
== 20  ; same value as b

&gt;&gt; a
== 10

&gt;&gt; b
== 20
</code></pre>
<p>You can combine this with things like GROUP!s to calculate the variable name, or even omit the variable name and use <code>#</code>:</p>
<pre><code>&gt;&gt; [a @(#)]: multi
== 20  

&gt;&gt; a
== 10
</code></pre>
<p>There are some places where this comes in handy, although you generally want to pick the main return to be the thing people are most interested in responding to (e.g. determining success or failure of an operation).</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/circling-multi-returns-choose-which-is-expression-result/1587">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/circling-multi-returns-choose-which-is-expression-result/1587</link>
          <pubDate>Sat, 17 Apr 2021 06:06:59 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1587</guid>
          <source url="https://forum.rebol.info/t/circling-multi-returns-choose-which-is-expression-result/1587.rss">Circling Multi-Returns: Choose Which Is Expression Result</source>
        </item>
        <item>
          <title>Weird WORD!s - Allow, But Backtick Escape Them?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>I suggested the idea of using <strong><code>&lt;.&gt;</code></strong> as a weird TAG! in PARSE... then I remembered... that's a TUPLE!.</p>
<p>My feeling is you should be able to build paths and tuples out of anything that's a valid WORD!.  But is it time we had an escaping mode for "weird words"?  If you want to make the above TUPLE!, what if you had to write:</p>
<pre><code>`&lt;`.`&gt;`
</code></pre>
<p>Otherwise, <code>&lt;.&gt;</code> would be a TAG!</p>
<p>Having an escaping mode for words would open up more lexical space.  For instance,  I like the idea of allowing $FOO, $(FOO), $FOO/BAR, $[FOO BAR] etc. as another type...</p>
<p>But this would seem to kill off the idea of being able to have <code>$</code> and <code>$$</code> etc. as WORD!s, because you get into ambiguous situations... is $/foo a PATH! with the $ word in the first slot, or an ENV-PATH! with an empty first slot?</p>
<p>These ambiguities create problems for other things that might stand alone all right, because we don't want to have "second-class-citizen" WORD!s that can't appear in paths.</p>
<p>But what if we used backticks if they wind up in paths?</p>
<pre><code>`$`/foo   ; PATH! with $ in the first slot
$/foo  ; ENV-PATH! with blank in the first slot
</code></pre>
<p>This could give us the likes of <code>:</code> and <code>::</code> as operators...</p>
<pre><code>&gt;&gt; `:`: does [print "I am colon!"]

&gt;&gt; :
I am colon!

&gt;&gt; type of :`:`
== #[datatype! action!]
</code></pre>
<p>It could work for other standalone characters, like <strong><code>@</code></strong> and perhaps <strong><code>&amp;</code></strong>.  <strong>%</strong> could be the same (with %"" or %{} used for empty file)</p>
<p>I feel like # and / may not be good candidates for this treatment, it would need more thought.</p>
<p><strong>The point wouldn't be that you'd likely be going crazy with paths involving these characters, but rather that you might want to do interesting things with them standalone.</strong>  It's just to put them on the map as legitimate words.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/weird-word-s-allow-but-backtick-escape-them/1560">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/weird-word-s-allow-but-backtick-escape-them/1560</link>
          <pubDate>Mon, 15 Mar 2021 03:30:50 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1560</guid>
          <source url="https://forum.rebol.info/t/weird-word-s-allow-but-backtick-escape-them/1560.rss">Weird WORD!s - Allow, But Backtick Escape Them?</source>
        </item>
        <item>
          <title>Don&#39;t Fear The WORD!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>Something Rebol touts as a big advantage is that it hasn't pinned a meaning to any words, so you can use them to mean what you want.</p>
<p>But I frequently have stressed over this, because words have associated costs that are non-trivial.</p>
<h2>Example: The Section Divider: <strong><code>===</code></strong>
</h2>
<p>I thought it would be neat if we could use this to have a Markdown-Like split of headers which just used plain words:</p>
<pre><code>all [
    === STEP WITH JUST WORDS ===

    step1 arg1

    === {STEP WITH STRING, NOT AS PLEASING} ===

    step2 arg2
]
then [
    print "=== is invisible, so it doesn't interfere with things like ALL!"
]
</code></pre>
<p>The idea is that it could be hooked in ways a comment couldn't...to print out messages to know you've reached the step (for instance).</p>
<p>Because I thought it was more pleasing, I designed it to permit words.  === was as a variadic function which would keep looking across its input until it found a === to terminate.</p>
<p><em>(Note: Wanting to reclaim <strong>==</strong> for using as an even briefer way of saying "section" is one of several motivators for cleaning up the use of it for equality)</em></p>
<p>But there are issues that come up from trying to write strings without string delimiters in Redbol.</p>
<p><strong>You have to write LOAD-able syntax.</strong>  Having COMMA! makes it a bit more tolerable, but you can still get in trouble with unusual uses of other characters.</p>
<pre><code>=== Here's a 3rd example; broken! ===
</code></pre>
<p>That's going to not be able to handle <code>3rd</code> in the current system (though <a href="https://forum.rebol.info/t/pack-sequence-type/1503">the PACK! proposal</a> could help here).  Then the semicolon will wind out commenting stuff out.</p>
<p><strong>Meaning of GROUP! is contentious.</strong>  I use a lot of parentheses when I write text, and not mean running code.  But we presumably want a way to get expressions in there:</p>
<p>That might not be a problem if we limit that to GET-GROUP!.</p>
<pre><code>=== DEMO OF VARIATIONS (GROUP EXAMPLE) ===

count-up n 100 [
    === Running Step :(n) ===
    print "This might be a way of doing it?"
]
</code></pre>
<p>Another alternative could be to use blocks for any evaluated portions, since square brackets don't often come up in English writing.</p>
<p><strong>Plenty of Other Questions</strong>... I don't want to tackle them all here, because I'd like to move to the big issue.</p>
<h2>Biggest Issue: Creating Tons Of Stray Bindings</h2>
<p>On the happy side, with LET we are moving into an idea of dynamism in binding so that using a SET-WORD! doesn't get you a local.  That keeps this from throwing in a local definition of PARSE:</p>
<pre><code>foo: function [data] [
    === BEGIN PARSE: It would suck if this overwrote PARSE! ===
    parse data [...]  ; if PARSE: was gathered as local, parse would be unset
]
</code></pre>
<p>Things like this are why I was so adamant against locals gathering.  It's good that it's gone from standard use, and relegated to being a weird feature for code golfing.  LET may be slow right now, but better to be slow than absolutely wrong.  Slow features can be sped up.  Wrong features can only be deleted.</p>
<p>The storage and loading of words themselves is actually pretty efficient.  The system is geared around it.  I'm not terribly concerned about the storage overhead difference between strings and a bunch of words.</p>
<p><strong>What's more troubling is all the bindings made in the user context.</strong>  These words don't know their binding isn't going to be used.  So the user context gets expanded and expanded.</p>
<p>I won't rewrite the explanation of this here.  But see <strong><a href="https://forum.rebol.info/t/the-real-story-about-user-and-lib-contexts/764">The Real Story About User and Lib Contexts</a></strong></p>
<h2>I Think Supporting Words This Way Is Mission Critical</h2>
<p>There are a lot of kneejerk responses which would dislike <strong>===</strong> in the form that I suggest.</p>
<p>Some people wouldn't like that it's variadic.  They might believe the principle of Rebol is based on blocks...so variadic functions shouldn't even be in the language to begin with.  I think they're wrong, and we now depend on variadicness quite a lot.</p>
<p>Others might worry about the overhead caused by bloating up the symbol space...or the length of the code block.  Or the CPU cycles consumed by having to run a variadic loop across the content of the line...one value at a time.</p>
<p><strong>But I think my leaning is that being able to choose to work this way is the distinguishing factor of the language.</strong></p>
<p>You can still use <strong><code>=== {Text} ===</code></strong> if you really want to.  Or you can avoid using === altogether and just use a comment like <strong><code>;===</code></strong> or <strong><code>;;</code></strong> and it won't have any runtime aspects at all...though then you won't get a log when it reaches that line if you want it.</p>
<p>Using bash is making me realize that even as light as Rebol can be a lot of the time, it's still too heavy sometimes.  Having to put things in quotes adds up 2 characters at a time, over time.  We should keep an eye on bending the mechanics to make it possible to use LOAD-ed "Rebol sentences" literally, and find places where that makes sense.</p>
<h2>This Means Binding Has To Be Rethought... More...</h2>
<p>We're just pinning down more of the requirements.  So as those requirements get locked, then hopefully that will make a design "emerge".</p>
            <p><small>5 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/dont-fear-the-word/1549">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/dont-fear-the-word/1549</link>
          <pubDate>Wed, 10 Mar 2021 03:17:22 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1549</guid>
          <source url="https://forum.rebol.info/t/dont-fear-the-word/1549.rss">Don&#39;t Fear The WORD!</source>
        </item>
        <item>
          <title>`call` asynchronously?</title>
          <dc:creator><![CDATA[okram]]></dc:creator>
          <category>Usage</category>
          <description><![CDATA[
            <p>On Atronix R3 when I run <code>call "zathura"</code> the program runs asynchronously. When I do the same in Ren-C it waits for the program to terminate. The available refinements do not seem to help.</p>
            <p><small>6 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/call-asynchronously/1509">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/call-asynchronously/1509</link>
          <pubDate>Mon, 15 Feb 2021 17:19:03 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1509</guid>
          <source url="https://forum.rebol.info/t/call-asynchronously/1509.rss">`call` asynchronously?</source>
        </item>
        <item>
          <title>Weird Idiom: Labeling Values?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>I'm going through and changing a lot of FUNCTION uses to FUNC + LET.  The long term goal will be to eliminate the locals-gathering functionality...and you either use LET/USE or you go explicit with <code>&lt;local&gt;</code> in the function spec.</p>
<p>I came across this:</p>
<pre><code>    size-as-binary: enbin [be + 8] length of embedding
    append executable size-as-binary
</code></pre>
<p>This was the only use of the variable.  Changing it to a LET works, but it's kind of a waste:</p>
<pre><code>    let size-as-binary: enbin [be + 8] length of embedding
    append executable size-as-binary
</code></pre>
<p>LET's assignment form does run the right hand side...because the LET word itself vaporizes, so it's like the bound new SET-WORD! just runs as normal:</p>
<pre><code>    append executable let size-as-binary: enbin [be + 8] length of embedding
</code></pre>
<p>But a LET isn't really necessary here.  I had a weird thought, what if a TAG! or ISSUE! or something was used in a way that was "obviously" throwing it away?</p>
<pre><code>    append executable (&lt;size-as-binary&gt; enbin [be + 8] length of embedding)
</code></pre>
<p>Maybe a little confusing.  But it saves on a variable declaration.</p>
<p>A comment is zero overhead, so I'm doing that...</p>
<pre><code>    append executable enbin [be + 8] length of embedding  ; size of binary
</code></pre>
<p>But I just thought the idea of a deliberately discarded leading value was kind of interesting.</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/weird-idiom-labeling-values/1500">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/weird-idiom-labeling-values/1500</link>
          <pubDate>Wed, 10 Feb 2021 19:21:13 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1500</guid>
          <source url="https://forum.rebol.info/t/weird-idiom-labeling-values/1500.rss">Weird Idiom: Labeling Values?</source>
        </item>
        <item>
          <title>Pivotal Design Question: Is Evaluator State Just A Block?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>I ran into a hitch with LET and EVALUATE in single-stepping.</p>
<p>It raises a pretty big question about how much we want to tie the hands of the evaluator in favor of "simplicity".</p>
<h2>The Problem</h2>
<p>On the surface a LET statement might seem impossible for step by step evaluation:</p>
<pre><code>&gt;&gt; block: evaluate [let x: 10 print ["X is" x]]
== [print ["X is" x]]
</code></pre>
<p>That LET statement declared a variable, but where did it go?  It only lives until the block is over.  It would seem that the PRINT is out of luck.</p>
<p><em>But...</em> I could make it work since a BLOCK! can carry along virtual binding state.  So, at each step you just get a little more state added on.  The <strong>[print ["X is x]]</strong> is <em>different</em> from the block you'd have gotten from saying SKIP 3 on the full block, due to this binding.</p>
<p><strong>But what if you reposition the block?</strong></p>
<pre><code>&gt;&gt; block: head block
== [let x: 10 print ["X is" x]]
</code></pre>
<p>Now you have a block that has X defined in its bindings, and if you step through it you'll define it again.</p>
<h2>Can This Be Solved?</h2>
<p>I think the cleanest and clearest way to solve it is to rethink EVALUATE so that it operates on a FRAME!...not a BLOCK!.  This would match the internal model better.</p>
<p>Today, we have to tear down a frame and build up a new one each time you do a step.  This would say that you'd be keeping it alive.</p>
<p>You'd be limited in terms of being able to look back over past values you had already evaluated.  That limitation would keep you from rewinding... if you wanted to go back and do things over, you'd have to do that by working with your original block that started the whole process.</p>
<p>What you'd be able to do in terms of looking ahead would be more like what a variadic is able to do today.</p>
<h2>The Big Philosophical Question</h2>
<p>I guess the big philosophical question is not necessarily so much about LET itself, but <strong>should we rule out the existence of things like LET in general</strong>.</p>
<p>In other words: is it imperative to step the evaluator across a block and <em>not</em> accrue any state particular to that evaluation?</p>
<p>I've been kind of looking for a convergence between things like the evaluator and PARSE, and so asking what the restrictions on the evaluator are may be asking what the restrictions are on anything that tries to leverage the FRAME!-based processing of blocks...for tracking positions, giving errors, etc.  If we require them all to be amnesiacs after every step, this would make it hard to write things like the COLLECT/KEEP feature in parse with the rollback feature...because it would have to record its state in some external thing.</p>
<p><a class="mention" href="/u/rgchris">@rgchris</a> --^ please see that and think about it.  If EVALUATE returned a FRAME! representing the block and not a new position of a block, what kind of disruption would it be?  Do you see the accrual of state in the evaluator to be something that should be ruled out--thus killing off LET or anything like LET--to be worth it to have the feature of a memoryless evaluator?</p>
<hr>
<p><strong>My leaning on this is to say that we would be crippling the language by ruling out LET-like things in the design.</strong></p>
<p>Right now, I have this test code working.  Note it's three evaluation steps, because the LET is actually invisible (1 unit lookahead to see x and add the binding, then leaves <code>x: 10</code> to run normally)</p>
<pre><code>x: &lt;in-user-context&gt;
output: '~unset~
block: evaluate evaluate evaluate [let x: 10 output: x]
did all [
    block = []
    output = 10
    x = &lt;in-user-context&gt;
]
</code></pre>
<p>And when you look at some of the other designs of how this is plugging together, I don't think we should turn back.  It's simply too hard to build abstractions on top of FUNC if the bodies cannot dynamically declare new variables, and I think forcing everyone in those situations to deal with USE is ergonomically just too awkward to feel like the language is living up to its promises.</p>
<p>I don't want to give up on virtual binding and LET when it has come this far.  It may be broken, but its brokenness is already a better kind of broken than what was there before...and there's no proof yet that it can't be made better.</p>
<p>Rebol's M.O. has been throwing imaginative <em>but I want the code to look like THIS</em> at a data structure and see how far that can go...without proof that it can or should work well.  Every now and again I think I should have the right to throw my own bad idea that looks good in there.  And maybe some poor sucker in the future can figure out the limits of how it can be made to seem like it works more.   <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/pivotal-design-question-is-evaluator-state-just-a-block/1496">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/pivotal-design-question-is-evaluator-state-just-a-block/1496</link>
          <pubDate>Tue, 09 Feb 2021 21:25:35 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1496</guid>
          <source url="https://forum.rebol.info/t/pivotal-design-question-is-evaluator-state-just-a-block/1496.rss">Pivotal Design Question: Is Evaluator State Just A Block?</source>
        </item>
        <item>
          <title>On Wasted Bits</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>In one of my Philadelphia talks, I cited a quote from Paul Graham in <a>The 1,000 Year Language</a></p>
<blockquote>
<p><em>"I learned to program when computer power was scarce. I can remember taking all the spaces out of my Basic programs so they would fit into the memory of a 4K TRS-80. The thought of all this stupendously inefficient software burning up cycles doing the same thing over and over seems kind of gross to me. But I think my intuitions here are wrong. I'm like someone who grew up poor, and can't bear to spend money even for something important, like going to the doctor."</em></p>
<p>...</p>
<p><em>"The desire for speed is so deeply engrained in us, with our puny computers, that it will take a conscious effort to overcome it. In language design, we should be consciously seeking out situations where we can trade efficiency for even the smallest increase in convenience."</em></p>
</blockquote>
<p>I've been struggling some with this fight.  For instance, the scenario of:</p>
<pre><code>count-up x 1000000 [
    let y: x + 1
    print [y]
]
</code></pre>
<p>What I have explored is the question of making LET a dynamic construct.  This dynamism would mean it wouldn't be scanned for in advance (like "FUNCT" looked for SET-WORD!).  It would actually bring a new variable and binding into existence... basically just syntax sugar for if you had written:</p>
<pre><code>count-up x 1000000 [
    use [y] [
        y: x + 1
        print [y]
    ]
]
</code></pre>
<p>It's uncomfortable to induce the thought that you'd be making a new object each time through the loop...an object with one field (y).  That's a million objects being made, that the GC will have to grapple with.</p>
<p>I'm working on making these as small as possible...and the GC will sweep them up.  But people who have seen LET or LET-like constructs from other languages would not generally assume that it would cause so much pain to the GC.  It feels so much more catastrophically worse than creating a single object:</p>
<pre><code>let y
count-up x 1000000 [
    y: x + 1
    print [y]
]
</code></pre>
<p>And if you were using <strong><code>func [... &lt;local&gt; y]</code></strong> that's even more efficient.  It doesn't create a separate object identity at all, but piggy-backs on the frame (where the arguments are already stored).</p>
<p>Of course, we're dealing with an incredibly dumb "mark and sweep the world" GC right now, that only starts cleaning up when it hits a wall.  If we were more clever, I'm sure there could be ways that the GC could localize most LETs and do zoning cleverness...doing light pick-ups of GC objects.</p>
<h2>I May Be Worrying Too Much</h2>
<p>The size of the variable is smaller than the size of the frame created by an addition, e.g. by the <strong>+</strong>.  If someone is at the level of optimizing for the LETs, they'd make a much bigger difference by eliminating the block:</p>
<pre><code>count-up x 1000000 [
    let y: x + 1
    print x
]
</code></pre>
<p><em>(Note: PRINT requires blocks on non-strings, non-newline characters <a href="https://forum.rebol.info/t/limiting-print-to-block-text-perhaps-blank-to-opt-out/855">for a pretty good reason</a>, but I'm just trying to make the point about the relative costs of things.)</em></p>
<p>The creation of FRAME! (e.g. for a BLOCK!) has been optimized to reduce the GC load to just about the minimum that it can, but that minimum is the same minimum as what we're looking at for a LET.  So when the cost of a LET is more or less on the same level as the cost for a GROUP!, how much should we really be asking people to worry about it?</p>
<p>When you think about the forces in play here--the ability to do rearrangements to optimize it if you need to, and Paul Graham's remarks about expressivity being the long tail--I think making LET dynamic is probably the winning bet.</p>
<p>Luddites who don't like it can use <strong><code>&lt;local&gt;</code></strong> and be no worse off.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/on-wasted-bits/1492">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/on-wasted-bits/1492</link>
          <pubDate>Sat, 06 Feb 2021 06:54:49 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1492</guid>
          <source url="https://forum.rebol.info/t/on-wasted-bits/1492.rss">On Wasted Bits</source>
        </item>
        <item>
          <title>&#39;Enum&#39; Handling</title>
          <dc:creator><![CDATA[rgchris]]></dc:creator>
          <category>Usage</category>
          <description><![CDATA[
            <p>I'm curious what the current best practice is for handling 'enum'-like scenarios.</p>
<p>For my contrived example, I have an ORDER-FOOD function where you pick your dish, and that dish comes with onions.</p>
<pre><code class="lang-nohighlight">order: func [
    'dish [word!]
    /sub 'veggie [word!]
][
    ...
]
</code></pre>
<p>You can substitute onions for one other vegetable, but obviously I only have so many vegetables at a given time, so I'd like to be sure that you either get onions or another available vegetable.</p>
<pre><code class="lang-nohighlight">order enchiladas
order/sub burrito mushrooms
</code></pre>
<p>First thought is using <code>'default</code>:</p>
<pre><code class="lang-nohighlight">veggie: default ['onions]
</code></pre>
<p>That's fine so long as I have what the given vegetable is. What if I only have <code>[onions zucchini artichoke carrot]</code>?</p>
<p>There is the FIND approach:</p>
<pre><code class="lang-nohighlight">if not find veggie-box veggie [
    veggie: onions
]
</code></pre>
<p>Then again, I'm always mindful of CSS's: <em>if it doesn't exist, ignore it</em>. This approach has allowed CSS to adapt as new methodologies exist. How <code>display</code> that has been around for as long as I can recall gains a <code>grid</code> value that permits all kinds of heretofore layout possibilities. Any browser out there that doesn't know what <code>grid</code> means will happily display content as if it was whatever the call to <code>grid</code> replaced. Similarly, all the properties associated with grid layout are just ignored by older browsers.</p>
<p>Not quite sure how that maps to my function, but it'd be interesting to say:</p>
<pre><code class="lang-nohighlight">any [
    order/sub bibimbap bok-choy
    order/sub bibimbap carrot
    order burger
]
</code></pre>
<p>In the event of its availability one day, that I may have that fresh crunchy cabbage.</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/enum-handling/1489">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/enum-handling/1489</link>
          <pubDate>Fri, 05 Feb 2021 23:35:07 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1489</guid>
          <source url="https://forum.rebol.info/t/enum-handling/1489.rss">&#39;Enum&#39; Handling</source>
        </item>
        <item>
          <title>Resurrecting REDBOL-APPLY via Type Exposure</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>At one point, I had a simulation of the Rebol2/R3-Alpha APPLY working...all written in usermode code.</p>
<p>As a refresher: this concept of APPLY required you to line up things positionally--even refinements.  You had to look at the parameter order on the interface, and put "truthy" things in the refinement slots you wanted to enable.  Then if the refinement took argument(s), you would have to put that in the next slot.</p>
<p>So for R3-Alpha's APPEND, the ordered spec is:</p>
<pre><code>APPEND series value /part length /only /dup count
</code></pre>
<p>Let's say you wanted to do something equivalent to <strong>append/part/dup [a b c] [d e f] 2 3</strong>.  You would write:</p>
<pre><code>r3-alpha&gt;&gt; apply :append [[a b c] [d e f] true 2 false true 3]
== [a b c d e d e d e]
</code></pre>
<p>Here the first TRUE is to say we want to use the /PART...then the length of 2.  Then a FALSE to say we don't want /ONLY.  And then another TRUE to say we want /DUP, with the count as 3.</p>
<p>It's fairly convoluted, and brittle with respect to rearrangement.  But it offers you the benefit of being able to calculate whether you want to provide a refinement or not.  The block is reduced by default (with an /ONLY option to ask that it not be).</p>
<p>In the early days of frames, I thought it would be a good test to see if this exact function could be emulated by processing the block... building a FRAME!, and then DO'ing it.  So REDBOL-APPLY was written and added to the tests.</p>
<h2>Then Ren-C Became <a href="https://forum.rebol.info/t/pure-and-refined-simplifying-refinements-to-one-or-zero-args/1120">Pure and Refined</a>...</h2>
<p>With the great improvement of refinements becoming their own arguments, came a new puzzle from an interface perspective.  Where it had used to say things like:</p>
<pre><code>ren-c-before&gt;&gt; parameters of :append
== [series value /part length /only /dup count]
</code></pre>
<p>It would now say:</p>
<pre><code>ren-c-after&gt;&gt; parameters of :append
== [series value /part /only /dup]
</code></pre>
<p>You might notice a piece of information gets lost there: <strong>which refinements take arguments at the callsite, vs. which ones don't</strong>.  Here the /ONLY looks just like the /PART and /DUP.  If you're going to have a REDBOL-APPLY that splits out the refinement on/off from the argument, you have to know if there is an argument to fill in.</p>
<p>I'll emphasize here that <strong>whether or not this particular APPLY primitive is desirable or not isn't the point.</strong>  It's a question of whether there's enough information.  And you have to have more than the parameter list above.</p>
<p>So one place people might have looked to would be the TYPESETS OF reflector, and maybe check to see if the typeset was empty (?)  But the typeset code was never all that good.</p>
<h2>Enter The New AS FRAME! Aliasing Ability</h2>
<p>I only just pushed this a bit forward, so it's not stable yet.  But it was enough to get REDBOL-APPLY working.  Here's what the frame alias of APPEND looks like:</p>
<pre><code>&gt;&gt; as frame! :append
== #[frame! {append} [
    return : [any-series! port! map! object! module! bitset!]:
    series : [any-series! port! map! object! module! bitset!]
    value : [&lt;opt&gt; any-value!]
    part : /[any-number! any-series! pair!]
    only : /[]
    dup : /[any-number! pair!]
    line : /[]
]]
</code></pre>
<p>The keys can't hold the information about whether something is a refinement or quoted or not.  So those attributes are moved onto the BLOCK!.  Here we see that PART, ONLY, DUP, and LINE are refinements...while ONLY and LINE have no specified types.</p>
<h2>And Here's The First Try That Gets The Tests Passing Again</h2>
<p>It's big and pokey.  And it trips over the weird parameter compaction a little bit... there's still a lot of questions about how you would take something that could either be <strong>':foo</strong> or <strong>/foo</strong> and extract plain <strong>foo</strong> out of it.  (It's not as obvious as you might think that "to word! should just do that".)</p>
<p>There's plenty of room for improvement.  But clumsy though it is, it shows some of the non-trivial meta-language behavior that I think can be put in the hands of mere mortals...in that Minecraft-of-programming way.  This really is letting people get intimately involved in the design of their own function generators and control structures...</p>
<pre><code>redbol-apply: func [
    return: [&lt;opt&gt; any-value!]
    action [action!]
    block [block!]
    /only
    &lt;local&gt; types arg key frame params mode
][
    types: as frame! :action  ; exemplar of types
    frame: make frame! :action  ; frame we are building
    params: parameters of :action  ; ordered list of parameters
    mode: &lt;normal&gt;

    ; Rebol2 and R3-Alpha APPLY would fill in NONE for any parameters that
    ; were not provided in the apply block:
    ;
    ;     rebol2/r3-alpha&gt;&gt; apply func [a b c] [reduce [a b c]] []
    ;     == [none none none]
    ;
    ; This means we need to enumerate and fill in the frame as long as there
    ; are parameters--not as long as there are block values.
    ;
    while [not tail? params] [
        case [
            not block [
                arg: null  ; could also do BLANK! if no more block data
            ]
            only [  ; /ONLY means do not evaluate arguments
                arg: get/any 'block/1
                block: next block
            ]
            true [  ; evaluate (skipping comments and other invisibles)
                until .not.quoted? [[block arg]: evaluate block]
            ]
        ]

        key: to word! dequote params/1
        all [
            refinement? params/1
            elide if not block [break]  ; done if refinements w/no more block
            mode = &lt;normal&gt;
        ] then [
            mode: if arg [#]  ; set mode to either use or don't use next arg
            if empty? second pick types key [  ; no-arg refine...
                set (in frame key) mode  ; ...must be # or NULL
            ] else [
                continue  ; keep param on the refinement, get next arg
            ]
        ] else [
            if mode [  ; normal or # case will set
                set (in frame key) get/any 'arg
            ]
        ]

        mode: &lt;normal&gt;
        params: next params
    ]

    ; Too many arguments was not a problem for R3-alpha's APPLY, it would
    ; evaluate them all even if not used by the function.  It may or may not
    ; be better to have it be an error.
    ;
    ; https://github.com/metaeducation/rebol-issues/issues/2237
    ;
    comment [
        all [block, not tail? block] then [
            fail "Too many arguments passed in REDBOL-APPLY block."
        ]
    ]

    do frame
]</code></pre>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/resurrecting-redbol-apply-via-type-exposure/1474">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/resurrecting-redbol-apply-via-type-exposure/1474</link>
          <pubDate>Mon, 25 Jan 2021 11:50:41 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1474</guid>
          <source url="https://forum.rebol.info/t/resurrecting-redbol-apply-via-type-exposure/1474.rss">Resurrecting REDBOL-APPLY via Type Exposure</source>
        </item>
        <item>
          <title>Case Study of Case Behavior: The AN Function</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>In thinking about weird applications of case, I was reminded of the little trick of the AN function:</p>
<pre><code>&gt;&gt; an "integer"
== "an integer"

&gt;&gt; an "text"
== "a text"
</code></pre>
<p>It simply checks the letters of the start of the rendering of what comes after it, and resolves to either "a" or "an".  I came up with it during the automatic generation of help strings for typecheckers, something along the lines of:</p>
<pre><code>for-each type data-types [
    help-string: spaced ["Checks to see if value is" an mold type]
    ...
]
</code></pre>
<p>But what if the A or An is at the start of a sentence?  Wouldn't the case of the operator matter?</p>
<pre><code>&gt;&gt; An "integer"
== "An integer"
</code></pre>
<p>Or how about all-caps?</p>
<pre><code>&gt;&gt; AN "INTEGER"
== "AN INTEGER"
</code></pre>
<p>In a case-insensitive world, all of these calls are to the same function.  So what it had to do was consult the stack to see what the label was it was invoked with, and go by the case of that.</p>
<p>But in a case-sensitive world, these would be three different functions (most likely, specializations of a core <code>AN*</code> that took what casing you wanted).</p>
<p>I'm not sure where this fits in the <a class="mention" href="/u/mark-hi">@Mark-hi</a> taxonomy of rightness or wrongness.  But it does point to an axis of flexibility where someone can use stack reflection to force case-sensitive behavior in a case-insensitive system.</p>
            <p><small>4 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/case-study-of-case-behavior-the-an-function/1469">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/case-study-of-case-behavior-the-an-function/1469</link>
          <pubDate>Mon, 18 Jan 2021 21:37:34 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1469</guid>
          <source url="https://forum.rebol.info/t/case-study-of-case-behavior-the-an-function/1469.rss">Case Study of Case Behavior: The AN Function</source>
        </item>
        <item>
          <title>Why Isn&#39;t PRINT Invisible (&quot;void&quot;)?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>Since PRINT doesn't have an interesting return value, we might ask what the harm would be in making it invisible.</p>
<p>But let's generalize the question to SOME-FUNCTION where the key point is that at the time you write it, you haven't thought of a meaningful result for it.</p>
<h2>Catching Erroneous Assignments</h2>
<p>Returning an "ornery" value helps catch mistakes more easily when a meaningless result is accidentally used.</p>
<p>But with invisibles, we might adopt a philosophy like C's, and say you cannot put a void function directly after an assignment:</p>
<pre><code>int x = some_void_function(...);  /* compiler will error */
</code></pre>
<p>Interestingly, C lets use them in comma-delimited expressions so long as they are discarded...you have to use parentheses to do it:</p>
<pre><code>int x = (some_void_function(...), 10 + 20);  /* this is okay */
int x =  some_void_function(...), 10 + 20;  /* this errors */
</code></pre>
<p>We could do something similar</p>
<pre><code>x: comment "hi" 1 + 2  ; this could error
x: (comment "hi" 1 + 2)  ; this could be okay
</code></pre>
<p>That's a little bit of a bummer for comment, but not the end of the world.</p>
<p>However, I want to see Ren-C's void/invisible used for things like BREAKPOINT and other tools... where having to rearrange your code in this way could be a nuisance (or dialect-wise, the GROUP!s could have semantic implications, e.g. if the code was inside of a COMPOSE).</p>
<p>But there are other issues...</p>
<h2>Limiting Interface Flexibility</h2>
<p>If at the time of writing a function you know that it doesn't have a meaningful return value, then making it void--instead of returning a trash value--ties your hands in changing it.</p>
<p>People will start writing things like:</p>
<pre><code>all [
    ...
    some-function ...  ; user assumes no effect, because invisible
    ...
]
</code></pre>
<p>But if SOME-FUNCTION had returned a trash value, then they could have gotten the same effect more obviously with:</p>
<pre><code>all [
    ...
    elide some-function ...
    ...
]
</code></pre>
<p>This also gives more freedom to change the interface later, if you think of an interesting value to return.  You can progressively add more return types after the fact.  But once people assume you always return void, this trap will happen...you're locked in forever in a way that was pretty much completely avoidable.</p>
<h2>In PRINT's Case, a Differentiated NULL Output Has Value</h2>
<p>Having a return value from PRINT that is either an ornery value or nothing lets you offer the neat option of returning NULL if the result of the print was nothing.</p>
<pre><code> &gt;&gt; line: "some text"
 &gt;&gt; print line then [print "We had output!"]
 some text
 We had output!

 &gt;&gt; line: _
 &gt;&gt; print line then [print "We had output!"]  ; no-op
</code></pre>
<p>To do this kind of thing requires having an output value.</p>
<p>I might be convinced that how people want to use PRINT is universally enough that they would rather it be invisible.  But that would involve a very specific understanding of a very common function...similar to how <strong>elide</strong> and <strong>comment</strong> and <strong>assert</strong> and <strong>--</strong> are known to have no result.</p>
<p>I don't think the average "no meaningful result" function fits in this category, and I'd say I'm fairly skeptical if PRINT belongs in it.</p>
<h2>I Think "Void" Functions Should Be Used Sparingly</h2>
<p>I think the feature should be <em>discoverable</em>, because how it's done is unique...and we are giving it a more normal name ("void function")</p>
<p>I'm feeling a bit more amenable to the idea that these are void return modes, even if it creates barriers to a multi-valued RETURN:</p>
<pre><code>f1: func [x] [return]
f1: func [x] [return comment x]
</code></pre>
<p>But this means there needs to be a relatively comfortable syntax for returning a BAD-WORD! that is like what we're used to.  <a href="https://forum.rebol.info/t/the-return-of-none/1467">I'm wondering if <strong>return none</strong>, recycling the word none for <strong>~none~</strong>, is the right compromise.</a></p>
<blockquote>
<p><strong>UPDATE:</strong> I've found some other reasons why not to do this again.  So I think arity-0 RETURN is likely going to keep the "return meaningless (and ornery) value" semantic.</p>
</blockquote>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/why-isnt-print-invisible-void/1466">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/why-isnt-print-invisible-void/1466</link>
          <pubDate>Mon, 18 Jan 2021 01:40:15 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1466</guid>
          <source url="https://forum.rebol.info/t/why-isnt-print-invisible-void/1466.rss">Why Isn&#39;t PRINT Invisible (&quot;void&quot;)?</source>
        </item>
        <item>
          <title>Can Functions You âž¤ Now REORDER</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>As things have slowly nudged along in the function composition space, I've kept a generic reordering facility in mind.</p>
<p>And today... less than a week into 2021... we have a first version of it, tentatively named REORDER.</p>
<pre><code>&gt;&gt; append-value-first: reorder :append [value series]

&gt;&gt; append-value-first &lt;item&gt; [a b c]
== [a b c &lt;item&gt;]
</code></pre>
<p>As with other function derivations, there's a lot of benefit over writing <strong>func [value series] [append series value]</strong> !</p>
<p>First of all, it's nearly as fast as the original function. It adds a little overhead to do the rearrangement, but it places values in the same underlying frame slots...and introduces no new frame of its own.</p>
<p>You keep the HELP, parameter names, and descriptions...as well as keep the refinements:</p>
<pre><code>&gt;&gt; append-value-first/dup &lt;item&gt; [a b c] 3
== [a b c &lt;item&gt; &lt;item&gt; &lt;item&gt;]
</code></pre>
<h2>Usage Notes</h2>
<p><em>You need to provide all the required arguments</em>.  It won't guess where you want parameters to go.</p>
<pre><code>&gt;&gt; reorder :append [value]
** Script Error: append is missing its series argument
</code></pre>
<p>However... <strong>you can position optional arguments in the ordering if you like!</strong></p>
<pre><code>&gt;&gt; append-val-dup-ser: reorder :append [value dup series]

&gt;&gt; append-val-dup-ser &lt;item&gt; 3 [a b c]
== [a b c &lt;item&gt; &lt;item&gt; &lt;item&gt;]
</code></pre>
<p>As usual, I will plead for the submission of more tests:</p>
<p><strong><a href="https://github.com/metaeducation/ren-c/blob/master/tests/functions/reorder.test.reb">%tests/functions/reorder.test.reb</a></strong></p>
<p>I point out that this is based on a more foundational ability, to specify non-refinement arguments in paths...which pushes them to the end of the pending arguments:</p>
<pre><code>&gt;&gt; append/series &lt;item&gt; [a b c]
== [a b c &lt;item&gt;]
</code></pre>
<p>REORDER gives you a more intuitive interface to it, but you can also do it that way if you feel like it!</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/can-functions-you-now-reorder/1458">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/can-functions-you-now-reorder/1458</link>
          <pubDate>Wed, 06 Jan 2021 02:46:42 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1458</guid>
          <source url="https://forum.rebol.info/t/can-functions-you-now-reorder/1458.rss">Can Functions You âž¤ Now REORDER</source>
        </item>
        <item>
          <title>iframe in replpad-js</title>
          <dc:creator><![CDATA[okram]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>I was thinking about using rebol to automate some tasks on web applications  have to use regularly. Obviously, replpad-js can leverage the browser (which can take care of cookies, etc.). I want the <code>IFRAME</code> to be resizable and I do not want to use any JS for that.</p>
<pre><code class="lang-auto">inline-css: function [
    {Provide default CSS for resizing inline frame}
][
    css-do {.replpad-resizer { display:flex; margin:0; padding:0; resize:both; overflow:hidden }
            .replpad-resizer &gt; .replpad-resized { flex-grow:1; margin:0; padding:0; border:0 }
            .replpad-border { background:gray; border:1px dashed black; }}
]
</code></pre>
<p>The <code>inline</code> function takes the URL and an id and inserts the <code>IFRAME</code> (maybe it should use the original URL as the id?).</p>
<pre><code class="lang-auto">inline: function [
    {Provide a browsing context in the replpad}
    url [url!]
    name [text!]
][
    replpad-write/html unspaced [
        &lt;div class="replpad-resizer replpad-border"&gt;
        {&lt;iframe class="replpad-resized" src="} url {" id="} name {"&gt;&lt;/iframe&gt;}
        &lt;/div&gt;
    ]
]
</code></pre>
            <p><small>8 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/iframe-in-replpad-js/1449">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/iframe-in-replpad-js/1449</link>
          <pubDate>Thu, 31 Dec 2020 19:21:46 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1449</guid>
          <source url="https://forum.rebol.info/t/iframe-in-replpad-js/1449.rss">iframe in replpad-js</source>
        </item>
        <item>
          <title>The simple things matter the most</title>
          <dc:creator><![CDATA[iArnold]]></dc:creator>
          <category>First Steps</category>
          <description><![CDATA[
            <p>Perhaps this needs to be in a (sub)category of its own.</p>
<p>You know the feeling that you want to do something that looks really simple but how to do this in Rebol/Ren-C</p>
<p>Case:<br>
A. Transforming the content of a block into a string</p>
<p>B. Transforming the content of a string to become a block</p>
<p>First try:<br>
A.</p>
<pre><code>&gt;&gt; blk: [What becomes of a block when turned into a {} value?]
== [What becomes of a block when turned into a "" value?]
&gt;&gt; mold blk
== {[What becomes of a block when turned into a "" value?]}
</code></pre>
<p>B.</p>
<pre><code>&gt;&gt; txt: "What becomes of a string when turned into a [] value?"
== {What becomes of a string when turned into a [] value?}
&gt;&gt; to block! txt
== [{What becomes of a string when turned into a [] value?}]
</code></pre>
<p>So clearly not what was intended!</p>
<p>After some tinkering:<br>
A.</p>
<pre><code>block-to-text: function [blk [block!]][
    result: copy ""
    spacer: copy ""
    for-each b blk [
        append append result spacer mold b
        spacer: copy " "
    ]
    result
]
block-to-text blk
== {What becomes of a block when turned into a "" value?}
</code></pre>
<p>B.</p>
<pre><code>&gt;&gt; blk: load append append "[" txt "]"       
== [What becomes of a string when turned into a [] value?]
</code></pre>
<p>To be improved?</p>
            <p><small>11 posts - 4 participants</small></p>
            <p><a href="https://forum.rebol.info/t/the-simple-things-matter-the-most/1428">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-simple-things-matter-the-most/1428</link>
          <pubDate>Thu, 10 Dec 2020 14:35:01 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1428</guid>
          <source url="https://forum.rebol.info/t/the-simple-things-matter-the-most/1428.rss">The simple things matter the most</source>
        </item>
  </channel>
</rss>
