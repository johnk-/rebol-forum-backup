<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Language Bridging - AltRebol</title>
    <link>https://forum.rebol.info/c/development/language-bridging/35</link>
    <description>Topics in the &#39;Language Bridging&#39; category Interfacing Rebol with other languages discussed here.</description>
    
      <lastBuildDate>Sun, 23 May 2021 09:51:12 +0000</lastBuildDate>
      <atom:link href="https://forum.rebol.info/c/development/language-bridging/35.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>Returning a Rebol void value</title>
          <dc:creator><![CDATA[iArnold]]></dc:creator>
          <category>Language Bridging</category>
          <description><![CDATA[
            <p>When I created the MySQL extension, the way to return a void value from a function was to do a simple</p>
<pre><code>return rebVoid();
</code></pre>
<p>Now I am dealing with the GTK3 extension and I suspect something about this has changed. Multiple occasions where I return a void like this appear to be resulting in a segfault and quitting the console as a result as well.</p>
<p>Was this method indeed changed? Or  could it be that it is just unintentionally broken?</p>
<p>Should the</p>
<pre><code>return rebVoid();
</code></pre>
<p>be replaced by</p>
<pre><code>return Init_Void(D_OUT, SYM_VOID);
</code></pre>
<p>now?</p>
<pre><code>grep -r "rebVoid()" .
./extensions/stdio/readline-posix.c:            return rebVoid();  // signal a HALT
./extensions/stdio/readline-posix.c:                    return rebVoid();  // signal a HALT
./extensions/stdio/readline-windows.c:            return rebVoid();  // signal a HALT
./extensions/stdio/p-stdio.c:            line = rebVoid();
./extensions/stdio/p-stdio.c:                return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/viewgtk3/mod-viewgtk3.c:    return rebVoid();
./extensions/crypt/mod-crypt.c:    return rebVoid();
./extensions/crypt/mod-crypt.c:        return rebVoid();
./extensions/crypt/mod-crypt.c:        return rebVoid();
./extensions/odbc/mod-odbc.c:    return rebVoid();
./extensions/mysql/mod-mysql.c:        return rebVoid();
./extensions/mysql/mod-mysql.c:        return rebVoid();
./extensions/mysql/mod-mysql.c:    return rebVoid();
./extensions/mysql/mod-mysql.c:        return rebVoid(); 
./extensions/mysql/mod-mysql.c:    return rebVoid();
./src/core/a-lib.c:        result = rebVoid();
./src/core/t-bitset.c:            action = rebVoid();

grep -r "Init_Void(" .
./extensions/process/mod-process.c:    return Init_Void(D_OUT, SYM_VOID);
./extensions/process/mod-process.c:    return Init_Void(D_OUT, SYM_VOID);
./extensions/event/mod-event.c:    return Init_Void(D_OUT, SYM_VOID);
./extensions/event/mod-event.c:    return Init_Void(D_OUT, SYM_VOID);
./extensions/event/p-event.c:        return Init_Void(D_OUT, SYM_VOID);
./extensions/gob/mod-gob.c:    return Init_Void(D_OUT, SYM_VOID);
./extensions/gob/mod-gob.c:    return Init_Void(D_OUT, SYM_VOID);
./extensions/network/mod-network.c:        return Init_Void(D_OUT, SYM_VOID); }
./extensions/network/mod-network.c:    return Init_Void(D_OUT, SYM_VOID);
./extensions/stdio/mod-stdio.c:    return Init_Void(D_OUT, SYM_VOID);
./extensions/stdio/mod-stdio.c:    return Init_Void(D_OUT, SYM_VOID);
./extensions/signal/mod-signal.c:        return Init_Void(D_OUT, SYM_VOID); }
./extensions/crypt/mod-crypt.c:    return Init_Void(D_OUT, SYM_VOID);
./extensions/library/mod-library.c:    return Init_Void(D_OUT, SYM_VOID);
./extensions/library/mod-library.c:    return Init_Void(D_OUT, SYM_VOID);
./extensions/vector/mod-vector.c:    return Init_Void(D_OUT, SYM_VOID);
./extensions/vector/mod-vector.c:    return Init_Void(D_OUT, SYM_VOID);
./extensions/debugger/mod-debugger.c:        Init_Void(out, SYM_VOID);
./extensions/image/mod-image.c:    return Init_Void(D_OUT, SYM_VOID);
./extensions/image/mod-image.c:    return Init_Void(D_OUT, SYM_VOID);
./extensions/javascript/mod-javascript.c:        return Init_Void(D_OUT, SYM_VOID);
./extensions/javascript/mod-javascript.c:    return Init_Void(D_OUT, SYM_VOID);
./extensions/javascript/mod-javascript.c:    return Init_Void(D_OUT, SYM_VOID);
./extensions/dns/mod-dns.c:        return Init_Void(D_OUT, SYM_VOID);
./src/boot/words.r:; more communicative.  These are standard symbols passed to Init_Void().
./src/include/datatypes/sys-void.h:#define Init_Void(out,sym) \
./src/core/t-typeset.c:                Init_Void(DS_PUSH(), SYM_CUSTOM_X);
./src/core/d-test.c:    return Init_Void(D_OUT, SYM_VOID);
./src/core/d-test.c:    return Init_Void(D_OUT, SYM_VOID);
./src/core/l-scan.c:                Init_Void(DS_PUSH(), SYM_VOID);
./src/core/t-string.c:            return Init_Void(D_OUT, SYM_VOID);
./src/core/c-bind.c:    Init_Void(ARR_SINGLE(patch), SYM_UNSET);  // start variable off as unset
./src/core/c-bind.c:    return Init_Void(D_OUT, REB_VOID);
./src/core/c-bind.c:            Init_Void(var, SYM_VOID);
./src/core/functionals/c-augment.c:    Init_Void(DS_PUSH(), SYM_VOID);  // key slot (signal for no pushes)
./src/core/functionals/c-specialize.c:            Init_Void(arg, SYM_UNSET);  // *not* VAR_MARKED_HIDDEN
./src/core/functionals/n-function.c:    return Init_Void(f-&gt;out, SYM_VOID);
./src/core/functionals/n-function.c:    return Init_Void(f-&gt;out, SYM_VOID);
./src/core/functionals/n-function.c:        Init_Void(ARG(result), SYM_VOID);
./src/core/functionals/n-function.c:            Init_Void(v, SYM_VOID); // `do [return]` acts as `return void`
./src/core/functionals/c-lambda.c:    Init_Void(DS_PUSH(), SYM_VOID);  // key slot (signal for no pushes)
./src/core/functionals/c-hijack.c:        out,  // invisibles allow for out to not be Init_Void()'d
./src/core/functionals/c-generic.c:    return Init_Void(D_OUT, SYM_VOID);
./src/core/functionals/c-chain.c:    Init_Void(FRM_SPARE(f), SYM_UNSET);
./src/core/functionals/c-native.c:    // `return: &lt;void&gt;` use `return: [void!]` and `return Init_Void(D_OUT);`
./src/core/c-context.c:    REBVAL *value = Init_Void(ARR_LAST(CTX_VARLIST(context)), SYM_UNSET);
./src/core/c-context.c:                    Init_Void(var, SYM_UNSET);  // not in source context
./src/core/n-control.c:        return Init_Void(D_OUT, SYM_MATCHED);
./src/core/c-function.c:            Init_Void(param, SYM_UNSET);
./src/core/c-function.c:    Init_Void(KEY_SLOT(DSP), SYM_VOID);  // signal for no parameters pushed
./src/core/b-init.c:    Init_Void(Prep_Cell(&amp;PG_Unset_Value), SYM_UNSET);  // symbol never GC'd
./src/core/t-binary.c:            return Init_Void(D_OUT, SYM_VOID);
./src/core/a-lib.c:    return Init_Void(Alloc_Value(), SYM_VOID);
./src/core/n-do.c:        Init_Void(D_OUT, SYM_VOID);
./src/core/t-datatype.c:            Init_Void(value, SYM_VOID);
./src/core/t-datatype.c:            Init_Void(value, SYM_VOID);
./src/core/n-loop.c:                Init_Void(les-&gt;out, SYM_NULLED);  // null signals break only
./src/core/f-series.c:                return Init_Void(D_OUT, SYM_VOID);  // !!! better than error?
./src/core/n-system.c:        Init_Void(ARG(value), SYM_QUIT);
./src/core/n-data.c:            Init_Void(dest, SYM_NULLED);  // blocks can't contain nulls
./src/core/n-data.c:        return Init_Void(D_OUT, SYM_NULLED);
./src/core/n-data.c:    return Init_Void(D_OUT, SYM_VOID); // !!! Could return freed value
./src/core/n-data.c:        return Init_Void(D_OUT, SYM_NULLED);
./src/core/n-io.c:    return Init_Void(D_OUT, SYM_VOID);
./src/core/d-stats.c:    return Init_Void(D_OUT, SYM_VOID);
./src/core/m-pools.c:    return Init_Void(D_OUT, SYM_VOID);
./src/core/t-object.c:            Init_Void(var, SYM_VOID);
./src/core/c-error.c:                    Init_Void(var, SYM_END);
./src/core/c-error.c:                    Init_Void(var, SYM_VOID);
./src/core/u-parse.c:    Init_Void(Prep_Cell(ARG(num_quotes)), SYM_UNSET);
./src/core/u-parse.c:    Init_Void(Prep_Cell(ARG(position)), SYM_UNSET);
./src/core/u-parse.c:    Init_Void(Prep_Cell(ARG(save)), SYM_UNSET);
./src/core/u-parse.c:            Init_Void(D_SPARE, SYM_VOID);</code></pre>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/returning-a-rebol-void-value/1615">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/returning-a-rebol-void-value/1615</link>
          <pubDate>Sun, 23 May 2021 09:51:12 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1615</guid>
          <source url="https://forum.rebol.info/t/returning-a-rebol-void-value/1615.rss">Returning a Rebol void value</source>
        </item>
        <item>
          <title>Printing from inside a C function with rebElide</title>
          <dc:creator><![CDATA[iArnold]]></dc:creator>
          <category>Language Bridging</category>
          <description><![CDATA[
            <p>Not sure this is the right place for this question.</p>
<p>To help myself with the workings of the GTK3 binding, I want to put in some printing statements showing the values of certain items.</p>
<p>I have this working code where I want to print the return value of the C function from within another function</p>
<pre><code>unsigned int result = gtk_main_level();
REBVAL *text = rebValue("{}");
rebElide("append", text , rebI(result));
rebElide("print {after append}");
rebElide("print", text);
rebRelease(text);
</code></pre>
<p>The thing is I was expecting the fifth line replaced by:</p>
<pre><code>rebElide("print {The value of gtk_main_level equals", text, "}");
</code></pre>
<p>also to work, but this results in the exiting of the program with a segfault.<br>
Why is this?</p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/printing-from-inside-a-c-function-with-rebelide/1613">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/printing-from-inside-a-c-function-with-rebelide/1613</link>
          <pubDate>Fri, 21 May 2021 08:32:47 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1613</guid>
          <source url="https://forum.rebol.info/t/printing-from-inside-a-c-function-with-rebelide/1613.rss">Printing from inside a C function with rebElide</source>
        </item>
        <item>
          <title>Loading Blazor and Ren-C Wasm in the Same Page</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Language Bridging</category>
          <description><![CDATA[
            <p>So I'm cleaning some files off of a laptop that I'm giving my mom (in preparation for the moment when I get around to picking a new one to buy, whenever that happens).</p>
<p>One file I had just on this laptop pertained to getting Blazor to load a Ren-C interpreter.  The only big deal was that some programs built with emscripten (like Blazor itself) do not play friendly with other emscripten programs loaded in the same page.  The Wasm build is now done so that it moves itself out of the way.  As a consequence, the loading just works about like any other "calling JS from Blazor" works.</p>
<p>There's really nothing to see in loading the two into the same page.  There's a Blazor-related <code>&lt;script&gt;</code> tag and a Ren-C-related <code>&lt;script&gt;</code> tag.  I didn't publish it because I didn't put together a meaningful demo once the two were loaded, but I wanted to put this somewhere before letting go of the laptop.</p>
<p><strong>The more unique level of integration would be to be able to call Ren-C directly from C# / .NET built for Wasm without needing to go through a JavaScript bridge.</strong>  But, getting them loading in the same page was a necessary but sufficient precondition for that.</p>
<p>For whatever it is worth, here is an index.html that loads both libraries, which you can call from JS (and you can call Ren-C from the JS bridge inside Blazor, and Blazor from Ren-C via the Blazor API exposed as JS):</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;

&lt;head&gt;
    &lt;meta charset="utf-8" /&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" /&gt;
    &lt;title&gt;Test Ren-C Integration&lt;/title&gt;
    &lt;base href="/" /&gt;
    &lt;link href="css/bootstrap/bootstrap.min.css" rel="stylesheet" /&gt;
    &lt;link href="css/app.css" rel="stylesheet" /&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;app&gt;Loading...&lt;/app&gt;

    &lt;div id="blazor-error-ui"&gt;
        An unhandled error has occurred.
        &lt;a href="" class="reload"&gt;Reload&lt;/a&gt;
        &lt;a class="dismiss"&gt;🗙&lt;/a&gt;
    &lt;/div&gt;

    &lt;!-- Disable "autostart" so we can put a .then() on Blazor.start() --&gt;
    &lt;!-- https://github.com/dotnet/aspnetcore/issues/17504 --&gt;
    &lt;script src="_framework/blazor.webassembly.js" autostart="false"&gt;&lt;/script&gt;

    &lt;!-- The Ren-C interpreter loader for WebAssembly --&gt;
    &lt;script src="https://metaeducation.s3.amazonaws.com/travis-builds/load-r3.js"&gt;&lt;/script&gt;
    &lt;script&gt;
        Blazor.start({}).then(() =&gt; {
            alert("blazor says its loaded?")

            reb.Startup({tracing_on: true}).then(() =&gt; {
                alert("Rebol says its loaded?")
            })
        });
    &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;</code></pre>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/loading-blazor-and-ren-c-wasm-in-the-same-page/1611">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/loading-blazor-and-ren-c-wasm-in-the-same-page/1611</link>
          <pubDate>Tue, 18 May 2021 13:05:23 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1611</guid>
          <source url="https://forum.rebol.info/t/loading-blazor-and-ren-c-wasm-in-the-same-page/1611.rss">Loading Blazor and Ren-C Wasm in the Same Page</source>
        </item>
        <item>
          <title>Doubling-Down on TCC Bootstrap: Conference Demo Expanded!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Language Bridging</category>
          <description><![CDATA[
            <p><em>cc: interested irregular forum readers, or, at least irregular posters... (e.g. <span class="mention">@MarkI</span>, <span class="mention">@giluiolunati</span>)</em></p>
<p>In doing some prioritization, I posted about putting aside FFI, ZeroMQ, and the Serial port...since none of those are particularly mission-critical.  They did exercise some code, but they no longer represented any particular exercise that wasn't already covered elsewhere.  Limited efforts are better focused on things that will matter to more people (e.g. the web build).</p>
<p><strong>But one effort that is a big deal that I wanted to preserve is the TCC Extension, as well as the concept of being able to build the interpreter itself with TCC.</strong>  As I demonstrated in July 2019, those two things add up to being able to download the source code and bootstrap a new interpreter with no build tools on your system besides a single "r3-with-tcc" executable<sup><strong>1</strong></sup>.</p>
<p><em>(1) Well, you need the libc headers and include files and libs for your OS.  Things we require like <code>&lt;string.h&gt;</code>.  If we wanted to be masochistic, we could get into the business of zipping those up and either pulling them off the web via TLS/HTTPS/Unzip.reb or encapping them into the executable.  If we were to do this, we should look into doing it with <a href="https://musl.libc.org/about.html">musl</a> and not the likes of GNU's glibc.</em></p>
<p>So I slogged through to make a turnkey version of <a href="https://youtu.be/PT3GOe1pj9I?t=163">the conference demo</a>.  It's new and improved, and you can run it right from your Linux desktop, if you feel like it.</p>
<h2>Single-EXE Bootstrap...Now Reproduced As A GitHub Action!</h2>
<p>It's now more streamlined...automated, reproducible, and broken into sections.  You can see these sections in the GitHub continuous integration run:</p>
<p><strong><a href="https://github.com/metaeducation/ren-c/runs/2044725810">https://github.com/metaeducation/ren-c/runs/2044725810</a></strong></p>
<p>The script behind this is really just doing a few basic steps, which I will paraphrase here:</p>
<pre><code> # Install TCC and the libraries for embedding TCC services into C programs
 sudo apt install tcc libtcc-dev

 # Use TCC (and prebuilt R3 as make tool) to build a TCC-capable interpreter
 $R3_MAKE make.r config=configs/tcc.r extensions="TCC +"

 # Keep just the executable we made (call it r3-with-tcc for clarity)
 cp build/r3 ./r3-with-tcc

 # Now, you can throw away the prebuilt R3_MAKE tool and TCC executable
 rm $R3_MAKE
 sudo apt remove tcc  # keep the `libtcc-dev` for embedding TCC in C programs

 # Delete the source code that was cloned via git
 rm &lt;all the sources&gt;

 # Now use the sole executable to bootstrap itself, pulling the source code
 # down from GitHub over HTTPS as a .ZIP, unzipping it with the embedded
 # unzip.r, and rigging up the r3-with-tcc executable to act as an impromptu
 # interpreter of C99 command lines.
 ./r3-with-tcc "bootstrap"
</code></pre>
<p>After doing basically just that, your build/r3 is now a newly minted r3-with-tcc...which could continue doing this bootstrap process indefinitely!</p>
<p>You can read the actual workflow script here: <a href="https://github.com/metaeducation/ren-c/blob/master/.github/workflows/tcc-build.yml">%tcc-build.yml</a></p>
<p>It does a few more things, including using the "build matrix" to do one run with <code>debug=none</code> and another with <code>debug=normal</code>.  It runs a few tests, but the real big test here is just the build in and of itself!  That exercises an insane amount of code.</p>
<h2>More Rigorous Than The Conference Demo</h2>
<p>This took a couple days of pretty intense work.  I'd sort of hacked the demo together the day before the conference, so it needed to be made less ad-hoc.  But also, there have been some changes which needed to be worked through...mbedTLS wasn't being used in 2019, so it hadn't been run through this.  There are little issues that come up with new things.</p>
<p>Plus, I started the presentation with a prebuilt r3-with-tcc that I used...but I had built that using GCC (not TCC).  And I didn't build the TCC extension into the bootstrapped executable, so it would not be capable of continuing the process.  There wasn't any demo of this being a "sustainable" bootstrap.</p>
<p>But here it is, done legit.</p>
<h2>Lots Still To Do...</h2>
<p>We're well aware that Rebmake is a beast, <a href="https://forum.rebol.info/t/new-build-executables-new-build-strategy/1432">and something needs to be done about that</a>.  But seeing one make tool written entirely in Ren-C points to the idea that it could be improved.  It sets a baseline and we can just keep aiming for it.</p>
<p>Performance is getting pretty bad, due to virtual binding and LET and other things that are still getting hammered out.  And that needs to be attacked, but the user experience has to be reasoned through completely first.  Once we decide something is simply not the way things should work--like FUNCTION auto-gathering SET-WORD!s deeply through the body--then trying other approaches is the only sane response.  <em>(If there's advantages to plunging forward with known broken things just for the sake of being first-to-market, Rebol2 would have found them...or Red will be finding them... <span class="hashtag">#goodluckwiththat</span>)</em>.  Outside of the performance issues, LET is looking mostly promising.</p>
<p>But the more we can hone this experience, I think the better the system coheres on its message, and so I'm comfortable with pushing this through and taking the time to do it.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/doubling-down-on-tcc-bootstrap-conference-demo-expanded/1542">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/doubling-down-on-tcc-bootstrap-conference-demo-expanded/1542</link>
          <pubDate>Sat, 06 Mar 2021 04:34:42 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1542</guid>
          <source url="https://forum.rebol.info/t/doubling-down-on-tcc-bootstrap-conference-demo-expanded/1542.rss">Doubling-Down on TCC Bootstrap: Conference Demo Expanded!</source>
        </item>
        <item>
          <title>Putting Aside the FFI...for now</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Language Bridging</category>
          <description><![CDATA[
            <p>R3-Alpha never had an FFI interface.  So Shixin had to add one, and it was one of the first things he did.</p>
<p>We were all new to the R3-Alpha codebase at that time.  And there wasn't a very obvious way to add such a feature, without hacking a lot of code into the core.  New data structures were given to the GC, and all kinds of strange hooks needed to be added in the invocation of functions.  There was no map for how to do it or way of judging right from wrong.  So brittle things were tacked in everywhere.</p>
<p>Trying to break out the FFI into its own separate codebase motivated the design of the "dispatcher-based" actions we know today...where a single ACTION! datatype can provide the interface for any kind of function that one wanted.  The methods of putting action description information into a "details" array also strongly shaped the system.</p>
<p>It's pretty accurate to say that the complexity of the FFI and its invasive reach meant that the design had to improve enough that the core could be insulated from it.  It was basically the first "extension", and a particularly pathological case.</p>
<h2>But the FFI is Not a Priority At The Moment</h2>
<p>Several reasons:</p>
<ul>
<li>
<p><strong>Mixing a GC-based language with unmanaged code through FFI is notoriously brittle.</strong>  Several of the techniques used in the FFI interface--such as giving out raw pointers to BINARY! or TEXT! data--were accidents waiting to happen.</p>
</li>
<li>
<p><strong>libRebol has gotten <em>very</em> easy to use.</strong>  Writing an extension with libRebol and linking it to a C library is generally a much cleaner way to make sure you're using the library correctly.  It has the downside of needing to compile the extension, but the plus side of then being able to step through the bridging code with a debugger...as well as use things like address sanitizer.</p>
</li>
<li>
<p><strong>Atronix is not doing new Rebol-oriented development at this time.</strong>  The main reason it existed was their interests, and without that interest I can't afford to maintain it along with everything else.</p>
</li>
</ul>
<h2>Not Worrying About The FFI Will Help Rewriting Rebmake</h2>
<p>Beyond being the most pathological extension code, the FFI was some of the most pathological build code.  There were crazy build dependencies for 32-bit Windows cross compilation from Linux that were a total nightmare.</p>
<p>Being able to write and test Rebmake without that will ease that load.</p>
<h2>The Code Won't Be Lost</h2>
<p>If I were to approach the FFI today, I would do so much more from the idea that the natives exposed by the C had the sole job of exposing the libffi low-level functionality.  All the higher-level analysis of the structures would be done in usermode code.</p>
<p>But the basic pattern is there if we needed it.  Also, there's <a href="https://www.youtube.com/watch?v=fMeTqPyrNF4">Shixin's video</a>, which lays out the design and its motivations...so that gives a real leg up.  Doing something a second time is always much easier.</p>
<p>In any case, the most important contribution of the FFI to the system design will stick around...that is to have an extension model that is capable of doing such complex things when they are needed.  That framework is why we could do things like the TCC extension or the JavaScript extension.  It's why we'll continue to be able to tackle similar problems without needing a major redesign.</p>
<p>So for now, we'll say the right way to interface with C libraries is as an extension.  Solving problems in that domain with libRebol helps everything...both the web build and the desktop build.</p>
<hr>
<p><strong>UPDATE:</strong> Deed is done, separate repository (archived, read-only): <a href="https://github.com/metaeducation/rebol-ffi">github.com/metaeducation/rebol-ffi</a></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/putting-aside-the-ffi-for-now/1537">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/putting-aside-the-ffi-for-now/1537</link>
          <pubDate>Thu, 04 Mar 2021 02:42:55 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1537</guid>
          <source url="https://forum.rebol.info/t/putting-aside-the-ffi-for-now/1537.rss">Putting Aside the FFI...for now</source>
        </item>
        <item>
          <title>Simplicity When Combinatorics Aren&#39;t Less Dangerous</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Language Bridging</category>
          <description><![CDATA[
            <p>In case I haven't said it enough (mostly to myself), I'll say it one (?) more time: <strong>calling API functions which splice in values is very much like DO COMPOSE</strong>.</p>
<pre><code> REBVAL *result = rebValue("some code", value1, "more code", value2);
</code></pre>
<p>acts like:</p>
<pre><code> result: do compose [some code (value1) more code (value2)]
</code></pre>
<p>This sets you up for pain when value1/value2 are evaluative types and you did not intend them to be evaluated.</p>
<p>When using COMPOSE in the language, we're lucky these days to have nice generic quoting.  If value1 is an ACTION! you want to run, and value2 is a WORD! you want to pass by value... you can apply the quotes where you want them:</p>
<pre><code> result: do compose [some code (value1) more code '(value2)]
</code></pre>
<p>Writing this in the API, you can use <code>rebQ()</code>:</p>
<pre><code> REBVAL *result = rebValue("some code", value1, "more code", rebQ(value2));
</code></pre>
<h2>Do We Need both rebValue and rebValueQ?</h2>
<p>The most foundational and pure API to give people is one that does what they asked.  If you wanted a quote, you ask for it.  If you don't, the value is left as-is.  If it's in a context where you didn't want it to be evaluative and it evaluates...that's just a bug and you need to fix it.</p>
<p><a href="https://forum.rebol.info/t/beta-one-quoting-in-the-api-decision-rebvalue-and-rebvalueq/1095/">I resolved</a> to make operations like <strong>rebValue</strong>, <strong>rebElide</strong>, <strong>rebUnboxInteger</strong> etc. not add quotes for this reason.  But to try and be "helpful", I thought to introduce auto-quoting versions like <strong>rebValueQ</strong>, <strong>rebElideQ</strong>, and <strong>rebUnboxIntegerQ</strong> that quote unless you explicitly ask for the quote to be removed with <strong>rebU()</strong>.</p>
<p>If you had a lot of rebQ() calls in a given invocation, there was a performance advantage to making the Q-version of the call.  And visually you weren't taking up as much space on a line.</p>
<p>But I'm on the fence looking at it in practice.  This doubles a lot of the API interface, and now it doubles the doubling because there's C++ wrappers and C wrappers.  <em>In an API that was designed to be minimal and elegant, it undermines that elegance by <strong>appearing</strong> redundant.</em></p>
<p><strong>One problem is that it adds an element of choice, which is a tax.</strong>  Every time you make a call you wonder if you used the right one.  And when you're in the middle of looking at a line of arguments you always have to scan back and wonder "is this in a Q call or a non-Q call".</p>
<h2>Is removing rebValueQ and friends the right move?</h2>
<p>There's a perceptual cost to making the API look larger and more cryptic.  There's already a lot to learn, and then this cost is something anyone looking at the API or code samples will have to pay.</p>
<p>The performance advantage is fairly negligible compared to the overall cost of scanning/binding an API call.  In cases that have no text portions to scan or bind, there's nearly zero advantage (for esoteric technical reasons I won't go into).</p>
<p>I'm not convinced the pain is reduced by <em>that</em> much by offering the alternatives.  The main pain you are saved from is that when you have a lot of parameters you want to quote, you're saving characters.</p>
<p>If it seems too verbose to use Q a lot, there's always even more abbreviated shorthands:</p>
<pre><code>#define Q rebQ

REBVAL *result = rebValue("some code", value1, "more code", Q(value2));
</code></pre>
<p>And the function of rebQ() actually is not to quote a single item, but to be able to enter "quoting mode" for an arbitrary number of items.  It applies to splices, not loaded code from c strings.  So if you need it rarely, you could say:</p>
<pre><code>REBVAL *result = rebValue(rebQ("some code", value1, "more code", value2));
</code></pre>
<p>Obviously I have some conflicted feelings about this, or they wouldn't exist.  <strong>But I'm leaning toward killing off the rebValueQ, rebElideQ, etc. variants.</strong>  Mostly because I think it will make the API and callsites appear more orthogonal to those reading it.</p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/simplicity-when-combinatorics-arent-less-dangerous/1324">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/simplicity-when-combinatorics-arent-less-dangerous/1324</link>
          <pubDate>Sun, 30 Aug 2020 07:33:56 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1324</guid>
          <source url="https://forum.rebol.info/t/simplicity-when-combinatorics-arent-less-dangerous/1324.rss">Simplicity When Combinatorics Aren&#39;t Less Dangerous</source>
        </item>
        <item>
          <title>C++ Interface Reinvented</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Language Bridging</category>
          <description><![CDATA[
            <p>I believe libRebol to be one of the most interesting pure C language bindings out there.  However, when you have a C++ compiler on hand it seems it should be able to compile something like:</p>
<pre><code>REBVAL *ten = rebValue("add", 4, 6);
</code></pre>
<p>But <code>rebValue</code> has been based on "sniffing" items in C's <strong><a href="https://en.cppreference.com/w/c/variadic/va_arg" rel="nofollow noopener">va_list</a></strong>, so it has required everything passed to conform to a bit-pattern of something it could "sniff".  They all had to be <em>pointers</em> to something with a compatible layout ("add" is a pointer to UTF-8, leaving room for alternatives in the illegal UTF-8 space).  So in the above code, 4 and 6 would get interpreted as pointers, and dereferencing memory location 4 or 6 would crash.</p>
<p>To get around this in C, you <em>must</em> use helpers that allocate detectable things, like <code>rebI()</code> for making a "transient integer" (e.g. one that would be freed by rebValue as it processed it):</p>
<pre><code>REBVAL *ten = rebValue("add", rebI(4), rebI(6));
</code></pre>
<p>For C++ we expect more!  So <strong>I'm pleased to say that a solution (even better than in RenCpp's) for passing C++ values has been implemented.</strong></p>
<h2>The Very Generic TO_REBARG</h2>
<p>After some acrobatics involving C++'s <strong><a href="https://en.cppreference.com/w/cpp/language/parameter_pack" rel="nofollow noopener"><code>templated variadic parameter packs</code></a></strong>, I've styled a solution for C++ that works by building <em>on top of</em> the mechanics used by the C.</p>
<p>If you want to make a type passable by value, you just write an overload of <strong><code>to_rebarg</code></strong>.  Integer is a simple example:</p>
<pre><code>inline static const void *to_rebarg(int i)
    { return rebI(i); }
</code></pre>
<p>While the C++ template is recursively unpacking the parameters, it calls <code>to_rebarg</code> to process each one.  You can translate things as simply or as complex-ly as you like...and you don't have to edit the library to add support for a new type.  Imagine:</p>
<pre><code>class MyDate {
   friend const void* to_rebarg(const MyDate &amp;date);  // allow access to private
   private:
       int day;
       int month;
       int year;
   public:
      // your C++ class code here
};

const void* to_rebarg(const MyDate &amp;date) {
    return rebR(  // autorelease
        rebValue("make date! [", date-&gt;day, date-&gt;month, date-&gt;year, "]")
    );
} 
</code></pre>
<p>Now all you would have to do if you wanted to pass a date in would be something like:</p>
<pre><code>void OutputDate(const MyDate &amp;date) {
    rebElide("print [{The date is}", date, "]");
}
</code></pre>
<h2>C++ Helping Catch Bugs in C89 Builds</h2>
<p>Being able to build with a C89 compiler is not really <em>that</em> relevant, but we still shoot for it.  Which means we don't take variadic macros for granted, and in the core all API calls have to be explicitly terminated with <code>rebEND</code>.  So if we'd wanted to compile the code from up top, we'd need to say:</p>
<pre><code>REBVAL *ten = rebValue("add", rebI(4), rebI(6), rebEND);
</code></pre>
<p>The way that C++ templates "unpack" variadic parameters is via compile-time recursion, which actually needs to differentiate the last step to terminate it.  So as a special case, when you use the C++ build on a file with REBOL_EXPLICIT_END (e.g. anything from core), it warns you if a rebEND is not in that last slot.</p>
<p>It <a href="https://github.com/metaeducation/ren-c/commit/cbc1f2bffbe781b2384b8f2003dc63c995895584" rel="nofollow noopener">caught a few mistakes</a>, though not all that many--because missing ones cause crashes, and any in active code would have been fixed.  But those crashes take time to investigate.</p>
<blockquote>
<p><strong>UPDATE:</strong> I forgot but rediscovered that there actually is a reason to care about rebEND at some callsites.  This is when you want to use preprocessor macros <em>inside</em> a call.  You can't put macros-inside macros.  So for example, from the FFI:</p>
<pre><code>ffi_abi abi = (ffi_abi)rebUnboxInteger(
  "switch", rebQ(word), "[",

     "'default [", rebI(FFI_DEFAULT_ABI), "]",

  #ifdef X86_WIN64

     "'win64 [", rebI(FFI_WIN64), "]",

  #elif defined(X86_WIN32) \
       || defined(TO_LINUX_X86) || defined(TO_LINUX_X64)

    "'sysv [", rebI(FFI_SYSV), "]",
</code></pre>
<p>...</p>
</blockquote>
<p>You can't do that unless you fall back on the C89-like mechanism.  The way you do this now is:</p>
<pre><code>ffi_abi abi = (ffi_abi)LIBREBOL_NOMACRO(rebUnboxInteger)(
</code></pre>
<p>That gives you a version that in C99+ doesn't offer the convenience of the rebEND.  But the C++ version is not a macro, so it can have <span class="hashtag">#ifdefs</span> inside it <em>and</em> not require a rebEND.</p>
<h2>Still More To Go</h2>
<p>This is a necessary step in making the C++ API pleasant to work with.  The next big question is on how to make a class that wraps up a value pointer and manages its lifetime, so you don't have to worry about <code>rebR()</code> or <code>rebRelease()</code>, <code>rebUnmanage()</code>, and other lifetime-related calls.  But getting this done was a prerequisite to looking at that.</p>
<p>RenCpp explored several other ideas that are a mixed bag.  One thing it tried to do was try to establish a constraint of what type a value was.  Although a superclass of <code>Any_Value</code> existed, the idea was that if you could <code>static_cast</code> to something more narrow you'd get a class that offered specialized methods.</p>
<p>Here's a simple example from that era, showing types like <code>Logic</code>, <code>Block</code>, and <code>Word</code>:</p>
<pre><code>int main(int, char **) {
    std::string data {"Hello [Ren C++ Binding] World!"}; 

    Word variable {"foo"};

    Block rule {
        "thru {[}",
        "copy", variable, "to {]}",
        "to end"
    };

    auto result = static_cast&lt;Logic&gt;(*runtime("parse", data, rule));

    if (result) 
        std::cout &lt;&lt; "Success and target was " &lt;&lt; variable() &lt;&lt; "\n";
    else
        std::cout &lt;&lt; "PARSE failed.";
}
</code></pre>
<p>If you look at <code>variable</code> you see an example of a "weird" idea in action.  It is of type Word, and holds the Rebol WORD! <code>foo</code>.  A plain reference as <strong><code>variable</code></strong> will give the word as-is (like when the <code>rule</code> block is being constructed), while using function application to it as <strong><code>variable()</code></strong> would act like <strong><code>get 'foo</code></strong>.</p>
<p>A lot of things like that were looked at, such as what <strong>block[n]</strong> would do (is that a PICK or a SELECT?), or if <strong>++block</strong> would act like <strong>block: next block</strong>.</p>
<p>Some of this might be interesting, but I don't think it represents a use case anyone has...namely, using C++ to puppeteer a pokey interpreter in an obscure way.  Most of the time you're looking at throwing data over the fence and getting an answer back.</p>
<p><strong>To me, a central idea is that the interpreter you are hooking up to might be styled to act nothing like the default out-of-the-box Rebol.</strong>  This means that giving people APIs like <code>rebAppend()</code> (or the infinite regression of <code>rebAppendDup()</code> and <code>rebAppendOnlyDup()</code>) that are "fast" is of not much use if that isn't what your dialect means by the word <strong><code>append</code></strong>.  The same argument could apply to trying to pin down the behaviors of <strong>block[n]</strong> or similar.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/c-interface-reinvented/1323">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/c-interface-reinvented/1323</link>
          <pubDate>Sun, 30 Aug 2020 06:36:51 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1323</guid>
          <source url="https://forum.rebol.info/t/c-interface-reinvented/1323.rss">C++ Interface Reinvented</source>
        </item>
        <item>
          <title>Stackless Generators and the API</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Language Bridging</category>
          <description><![CDATA[
            <p>Imagine that you have some array you want to iterate over, and do some C processing on each element of that array.  Pseudocode:</p>
<pre><code>void ProcessBlock(REBVAL *block) {
    for-each item block [
        ProcessItem(item);
    ]
}
</code></pre>
<p>You've got a bit of a problem here, because you'd like to express that for-each as Rebol code...but you are in C.  It seems like you can't use the FOR-EACH structure, you've got to write something like:</p>
<pre><code>void ProcessBlock(REBVAL*block) {
    REBVAL *pos = rebValue(block);  // can't rebRelease(block) here, new handle

    while (rebNot("tail?", pos)) {
        REBVAL *item = rebValue("first", pos);
        ProcessItem(item);
        rebRelease(item);

        pos = rebValue("next", rebR(pos));  // release old pos, get new pos
    }
    rebRelease(pos);  // need to release the pos (it's a tail value, not null)
}
</code></pre>
<p>Ouch.  There's certainly more ways to do it; we could get the item count and use a C integer as an index and PICK the items.  But whatever we do, the point is that our iteration state is held in C variables.</p>
<p>Our ideal might look more like:</p>
<pre><code>void ProcessBlock(REBVAL *block) {
    REBVAL *enumerator = rebEnumerator(block);

    REBVAL *item;
    while ((item = rebNext(enumerator)) {
        ProcessItem(item);
        rebRelease(item);
    }

    rebRelease(enumerator);
}
</code></pre>
<p>Yet the goal of the API is not to export every possible thing we would want as a rebXXX() function, rather to make it possible to use a few fixed extractors and value builders to push the burden onto a more flexible interpreter.</p>
<p>How about this, then?</p>
<pre><code>void ProcessBlock(REBVAL *block) {
    REBVAL *generator = rebValue(
        "generator [for-each item", block, "[yield item]]"
    );

    REBVAL *item;
    while ((item = rebValue(generator)) {
        ProcessItem(item);
        rebRelease(item);
    }

    rebRelease(generator);
}
</code></pre>
<p>Ta da!  It might not look like all that much of an advantage for this simple example, but the point is that it generalizes to much more complicated Rebol logic for the enumeration.  Imagine if it were using PARSE and sometimes you want to handle the value with Rebol code (which you do inline) and sometimes you want to hand it back to C for processing (which you do with a yield).</p>
<p>I do want to get around to the C++ wrapper that would do the handle lifetime management implicitly, which if it mirrored RenCpp would look like:</p>
<pre><code>void ProcessBlock(reb::Value &amp;block) {
    auto generator = reb::Value {
        "generator [for-each item", block, "[yield item]]"
    };

    while (auto item = reb::Value { generator })
        ProcessItem(item);
}
</code></pre>
<p>But even the C version looks pretty darn nice for language interop!</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/stackless-generators-and-the-api/1307">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/stackless-generators-and-the-api/1307</link>
          <pubDate>Sun, 19 Jul 2020 16:27:07 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1307</guid>
          <source url="https://forum.rebol.info/t/stackless-generators-and-the-api/1307.rss">Stackless Generators and the API</source>
        </item>
        <item>
          <title>Initial Rust Binding Experiment by Shixin</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Language Bridging</category>
          <description><![CDATA[
            <p>I asked Shixin if he would put a bit of his initial binding experimentation for Rust that he did last year on GitHub so we <sub>(though mostly I, I'll assume)</sub> could look at it.  So he did:</p>
<aside class="onebox allowlistedgeneric">
  <header class="source">
      <img src="https://github.githubassets.com/favicons/favicon.svg" class="site-icon" width="32" height="32">
      <a href="https://github.com/zsx/renc-rs" target="_blank" rel="noopener">GitHub</a>
  </header>
  <article class="onebox-body">
    <img src="https://avatars2.githubusercontent.com/u/1753?s=400&amp;v=4" class="thumbnail onebox-avatar" width="400" height="400">

<h3><a href="https://github.com/zsx/renc-rs" target="_blank" rel="noopener">zsx/renc-rs</a></h3>

<p>Rust binding to Ren-C. Contribute to zsx/renc-rs development by creating an account on GitHub.</p>


  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<p>While I don't know too much about Rust, the people who use it (including Shixin) seem to like it a lot.  I do know that I've seen a lot of activity surrounding it.  The concept is that people targeting WebAssembly would pick something with new safety properties and "friendlier syntax" to compile from than C++.</p>
<p>Looking at the source for the binding <a href="https://github.com/zsx/renc-rs/blob/master/src/lib.rs">lib(r3).rs</a>, you notice the usual suspects.  I note that there's <strong>let</strong>, and the <strong>if/else</strong> patterns that Ren-C has been trying to find ways to be able to bend to (if you want!)</p>
<p>When I get a chance I'll be trying to build it and run <a href="https://github.com/zsx/renc-rs/blob/53195b645eb0d5cc09e7b407bfe5f5dcbecdfa02/src/lib.rs#L452">the Fibonacci test</a> which is living in the lib.rs at the moment.  (It seems he was just focusing on the nuts-and-bolts of "can I call Rebol <em>at all</em>" vs. doing variadic tricks.)  On the off chance that anyone wants to take a crack at seeing if it runs before I do, I thought I'd point it out--though.</p>
<p>As a compiled language without homoiconicity, Rust is not a direct competitor.  But with Ren-C able to build as Wasm too, this is interesting...especially with the <a href="http://utf8everywhere.org/">UTF-8 Everywhere</a> ethos being embraced by both languages.  I've suggested there might be a chance that with good binding, we could play a sort of "JavaScript to Rust's Java" role...being the interpreted and light language which doesn't need a compiler that you call over to, but having a sort of from-scratch redesign that is revolutionary enough in paradigm to oust JavaScript from keeping that title again.</p>
<p>Anyway, I'm posting it here to keep track of it and any follow-ups...</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/initial-rust-binding-experiment-by-shixin/1269">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/initial-rust-binding-experiment-by-shixin/1269</link>
          <pubDate>Wed, 18 Mar 2020 22:04:45 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1269</guid>
          <source url="https://forum.rebol.info/t/initial-rust-binding-experiment-by-shixin/1269.rss">Initial Rust Binding Experiment by Shixin</source>
        </item>
        <item>
          <title>FFI Updates and Notes</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Language Bridging</category>
          <description><![CDATA[
            <p>Due to some complexities that had to do with the build system, the Ren-C FFI extension ceased being buildable somewhere on Dec 8, 2018.</p>
<p>Despite that, it still got some maintenance.  So when things were being searched and replaced in the codebase at large, I would tinker with the code in the FFI a bit to try and make it roughly reflect what had changed.  But even with that, a year's worth of drift without running it means it's going to get out of date.</p>
<p>In the last two days I've been able to get the demos back in running condition...including <a class="mention" href="/u/szeng">@szeng</a>'s GTK demo:</p>
<p><div class="lightbox-wrapper"><a class="lightbox" href="https://i.stack.imgur.com/EqR43.png" title="GTK Demo Screenshot"><img src="https://i.stack.imgur.com/EqR43.png" alt="GTK Demo Screenshot" width="624" height="500"><div class="meta"><svg class="fa d-icon d-icon-far-image svg-icon" aria-hidden="true"><use xlink:href="#far-image"></use></svg><span class="filename">GTK Demo Screenshot</span><span class="informations">2103×1684</span><svg class="fa d-icon d-icon-discourse-expand svg-icon" aria-hidden="true"><use xlink:href="#discourse-expand"></use></svg></div></a></div></p>
<h2>Cool, but the Build Problems Haven't Gone Away...</h2>
<p>There hasn't been a lot of time to focus on making Rebmake better at cross-platform inclusion of libraries that aren't by default available on the platform.  There's no libffi that ships in Visual Studio, so it becomes something of a manual configuration process.  Also, there's a bit of configuring that has to be done to get it working in cross-compilation of 32-bit binaries on a 64-bit Linux host.  Similar difficulties for OS X.</p>
<p>Since no one is currently actively using the FFI (in the Ren-C builds at least), it seems the path of least resistance is to just have it building into the 64-bit Linux builds.  That's where it's easy for the Travis container to install the package with <strong>sudo apt-get libffi</strong> and link with a simple <strong><code>-lffi</code></strong>.  This is enough to keep the code compiling and run a couple of little smoke tests to make sure things haven't gone too far south.</p>
<p><strong>To be clear: if you have the libraries all set up, then a "sufficiently motivated individual" could get the OS X, 32-bit Linux, and Windows versions to build.</strong>  There's nothing about the <em>code</em> that shouldn't work (since it works on Linux 64-bit, it's more or less proven.)  But they'd have to massage Rebmake to get it to spit out the right command lines and find the right files on the right platforms, when they're not around by default.  It shouldn't be too hard, as the package setup code was already on Travis...but Rebmake is a bit of a beast and needs some design work vs. just hacking it up more.</p>
<h2>Speaking of Tests...</h2>
<p>I've been wanting tests that are extension-specific to live in the directory with the extension.  So I'm moving them.  Right now we have:</p>
<ul>
<li>
<strong><code>%printf.r</code></strong> - Very simple demonstration of calling printf</li>
<li>
<strong><code>%varargs.r</code></strong> - More complex examples of calling printf and sprintf</li>
<li>
<strong><code>%qsort.r</code></strong> - Simple callback example of C's <code>qsort()</code> function, where the sorting comparison function used by the C code is actually a Rebol function.</li>
<li>
<strong><code>%qsort_r.r</code></strong> - More complex example of C's <code>qsort_r()</code> function, that allows passing a value through to the internal function that is not a global variable.  Also makes that value a "tunneled" REBVAL*, so you can actually pass a Rebol value to the C as a pointer and then get it back in the Rebol callback as a REBVAL again.</li>
<li>
<strong><code>%gtk.r</code></strong> - Gtk demo with toggle button, push button, font picker, and color picker</li>
</ul>
<p>There was one file hanging around called <code>%varargs_old.r</code>.  In Atronix R3 there were no variadics, so the only way to do something like printf was with a block.  This means you'd have to COMPOSE or REDUCE to get your values in:</p>
<pre><code>printf compose [
    "hello %p%c"
    "ffi" [pointer]
    (to integer! newline) [int8]
]
</code></pre>
<p>With variadics in Ren-C there was the variadic option, so I changed it to try it.  For instance:</p>
<pre><code>(printf "hello %p%c" "ffi" [pointer] to integer! newline [int8])
</code></pre>
<p>You could also use an expression barrier:</p>
<pre><code>printf "hello %p%c" "ffi" [pointer] to integer! newline [int8] |
</code></pre>
<p>I don't know what the "right" answer for calling C variadics is.  Maybe the compose was better?  But it's easy enough to go back and forth that I don't think we need to preserve two copies of the same file to different conventions.  Hence, instead I'm making a note here.</p>
<h2>And as I mentioned in chat...</h2>
<p>The big crazy difference with this FFI from the Atronix R3 is that it's all an extension. If you look closely you'll see a bit of an oddity in that it says  <strong>make custom!</strong>  and not  <strong>make struct!</strong> . :-/ There needs to be some work on that particular ecology point.</p>
<p>The  <em>mechanics</em>  of having an arbitrary number of datatypes is now in place. So the system is no longer limited to the number of types that fit in a byte...only the built-in types use that for optimization to get use out of all 3 platform pointers (besides the pointer-sized bits used for the header). But a REB_CUSTOM type means that it is sacrificing one of those pointers in the cell for the extension type.</p>
<p>So...there's now a bunch of policy and ecology to straighten out on top of that.</p>
<p>But again, the good news of all of this is that it means that we aren't stuck putting a bunch of FFI-specific code in the core; so the WASM build can be lighter. And similarly, we don't have a bunch of JavaScript support in the core. So things are factoring well for using the language in different configurations.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/ffi-updates-and-notes/1201">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/ffi-updates-and-notes/1201</link>
          <pubDate>Thu, 29 Aug 2019 22:05:48 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1201</guid>
          <source url="https://forum.rebol.info/t/ffi-updates-and-notes/1201.rss">FFI Updates and Notes</source>
        </item>
        <item>
          <title>Quoting Decisions In Practice: NULL Refinements</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Language Bridging</category>
          <description><![CDATA[
            <p>I'm moving along with the <a href="https://forum.rebol.info/t/are-nulls-the-best-representation-for-unused-refinements/1140">unused-refinements-are-null concept</a>, and absorbing the consequences.</p>
<p>One thing that it breaks was a way we'd been testing for a refinement being used or not in a JavaScript native.  Previously one could write:</p>
<pre><code>reb.Did(reb.ArgR('refine-no-args'))
</code></pre>
<p>That used "normal <code>reb.Did</code>" which did not quote its splices, as opposed to <code>reb.DidQ</code> which does quote splices.  For a reminder of what that's all about--and why I struggled over not quoting being the default and needing the <code>Q</code> to get the quotes--please review the reasoning here:</p>
<p><a href="https://forum.rebol.info/t/beta-one-quoting-in-the-api-decision-rebrun-and-rebrunq/1095/3">Beta/One Quoting in the API decision: rebValue() and rebValueQ()</a></p>
<p>Despite not using Q, the normal <code>reb.Did</code> worked before because the two possibilities were BLANK! (<strong><code>_</code></strong>) or the refinement itself (<strong><code>/refine-no-args</code></strong>), both of which were inert.  Now they're going to both be active.  Refinement-style-paths are like a GET-WORD! that's null-tolerant...they evaluate.  And nulls actually cannot be seen literally in the evaluator at all: they're considered errors if they ever come up, which is relatively esoteric to do when not using the API (though you can, e.g. <code>eval null</code>)</p>
<p>Long story short: if you're going to use plain <code>reb.Did()</code>, you have to splice quoted:</p>
<pre><code>reb.Did(reb.Q(reb.ArgR('refine-no-args')))
</code></pre>
<p>Or you can use the form of <code>Did</code> that adds a quote level on its splices by default:</p>
<pre><code>reb.DidQ(reb.ArgR('refine-no-args'))
</code></pre>
<h2>Does this suggest refinements with no args should be LOGIC!?</h2>
<p>One potential conclusion we might reach is that refinements which have no argument are forced very particularly to a state of truth or falsehood...that they are a special case.</p>
<p>That doesn't feel as "neat" to me as having their specialness be that when they are used, the truthy value they pick encodes the word of the refinement name itself.  Then when they are unused they are null just like any other type of refinement would be.  This makes chaining easier.</p>
<p>I think my feeling is no, and I like the current direction, where all unused refinements are null.</p>
<h2>Are we starting to need a helper library?</h2>
<p>I really wanted to keep the focus on a small API.  But even with that, should we have some standardized helpers on top of the low level ones?  Something like a <code>rebx</code> namespace?</p>
<pre><code>if (rebx.HasRefineArg('some-refinement')) { ... }
</code></pre>
<p>I'm a bit torn on this question.  I feel like you won't get very far in using the API if you don't understand what it's doing, and such things obscure the mechanics.</p>
<p>While the issues of the Q vs. not might <em>seem</em> like they're artifacts of the API, they are not.  You'd see them anywhere you are trying something like a <strong><code>do compose [...]</code></strong> in plain Rebol.  In R3-Alpha you had to say:</p>
<pre><code>do compose [some-word: quote (expression-that-makes-a-word)]
</code></pre>
<p>Fortunately Ren-C has a lighter notation with generalized quoting:</p>
<pre><code>do compose [some-word: '(expression-that-makes-a-word)]
</code></pre>
<p>This method even works with null, which a function like <code>LIT</code> (aka R3-Alpha's QUOTE) couldn't do...because there'd be no way to hold the null in a BLOCK!.</p>
<pre><code>&gt;&gt; compose [lit (null)]
== [lit]  ; uh oh, the group!'s block slot just vaporized

&gt;&gt; compose ['(null)]
== [']  ; slot didn't completely vaporize, left the quote

&gt;&gt; do [']
; null
</code></pre>
<p>So all that's really happening is that the API is putting you face-to-face with the nuts and bolts of the language.  reb.Q() on each splice site is a bit bulkier than an apostrophe, but that's why it was folded into the operator as <code>reb.DidQ()</code> if you are happy having it applied to all sites.  I've suggested that a certain type of person might tend to be a "Q"-ist and always use the Q forms, then reb.U() to call out the places to unquote.</p>
<p>Anyway, I'm curious what API users think.  <a class="mention" href="/u/brianotto">@BrianOtto</a>, <a class="mention" href="/u/giuliolunati">@giuliolunati</a>, <a class="mention" href="/u/gchiu">@gchiu</a> ?</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/quoting-decisions-in-practice-null-refinements/1166">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/quoting-decisions-in-practice-null-refinements/1166</link>
          <pubDate>Wed, 22 May 2019 23:00:25 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1166</guid>
          <source url="https://forum.rebol.info/t/quoting-decisions-in-practice-null-refinements/1166.rss">Quoting Decisions In Practice: NULL Refinements</source>
        </item>
        <item>
          <title>Managed/Unmanaged Expectations in the JavaScript API</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Language Bridging</category>
          <description><![CDATA[
            <p>JavaScript is terribly non-cooperative in terms of letting anyone participate in its garbage collection model.  <a href="https://stackoverflow.com/questions/11864044/can-javascript-objects-have-an-on-garbage-collect-callback" rel="nofollow noopener">There are <strong>zero</strong> hooks into its GC.</a>  We cannot know how long clients are holding handles to things.</p>
<p>libRebol tries to finesse its way around this as much as possible--and it has been doing an admirable<br>
job.  The idea is to make every "unboxing" routine an alternate interface to the evaluator.  Hence you don't have to deal with getting a complex API handle object back when all you wanted out of a bunch of code was something like an integer or boolean.  It drastically reduces the number of outstanding API handles in play.</p>
<p>Still, people are going to write:</p>
<pre><code>let text = "etaf"
reb.Elide("print [reverse", reb.Text(text), "]")
</code></pre>
<p>Today, that's a leak.  <code>reb.Text()</code> allocates a Rebol API handle.  They didn't store it anywhere...they just passed it in to reb.Elide, so it's impossible to free with <code>reb.Release()</code>.  You have to say:</p>
<pre><code>let text = "etaf"
let handle = reb.Text(text)
reb.Elide("print [reverse", handle, "]")
reb.Release(handle)
</code></pre>
<p>There's a pretty cool trick of <code>reb.R()</code>, shorthand for <code>reb.RELEASING()</code>, e.g. a "releasing reference":</p>
<pre><code>let text = "etaf"
reb.Elide("print [reverse", reb.R(reb.Text(text)), "]")
</code></pre>
<p>This way the evaluator actually releases it as it passes by in the evaluation.</p>
<p>Then there's a shorthand for that combination of reb.R and reb.Text, called simply reb.T:</p>
<pre><code>let text = "etaf"
reb.Elide("print [reverse", reb.T(text), "]")
</code></pre>
<p>A little esoteric, but it's short!  And saves a mouthful in C.</p>
<h2>But let's be real.</h2>
<p>Teaching the differences between reb.Text() and reb.T(), and explaining what the R in ArgR() means, is fighting a losing battle with new users.  And if their programs crash in ways they can't debug, it will make the whole thing seem unreliable.</p>
<p>The good news is things have been set up to rarely need to create durable API handles at all.  When I renamed reb.Run() to reb.Value() I thought I'd find a lot of cases, but there was just <em>one</em> in ReplPad, and zero in UI Builder.  I'm facing a situation right now needing to create persistent API handles that outlast a function scope for the watchlist.  <em>First case that has actually needed it.</em></p>
<p>So I'm thinking we should not be scared to make API handles JS objects, that are tracked in a mapping table from handle number to object.  Things like <code>reb.T()</code> would still return raw heap addresses.  But <code>reb.Text()</code>, <code>reb.Value()</code>, etc. would give JS objects that wrap up those addresses, that go bad at a deterministic time, and give clear errors if used after the point of death...but can GC otherwise.</p>
<h2>Can function call completion be when handles die?</h2>
<p>When a function call completes, the handles could be left alive but marked invalid due to the owning frame expiring--so attempts to use them will notice the expired frame and error.  And when the GC pass goes through to clean up the expired frame, it will remove the object from the table, but tell it directly that it expired (so that if a use comes after the GC, you'll get an error).  So the object lives as long as the user has a reference to it (which if no <code>reb.Release()</code> is used, will be at least as long as the the period of time between the function call ending and a GC happening).  But the GC sweep will pull the system's reference to that object so only the user references (if any) remain.</p>
<p>If you want a libRebol API handle to outlive the JS-AWAITER or JS-NATIVE it was allocated during, then you will have to "unmanage" it somehow, to extend its lifetime indefinitely until you ask to release it.  Since this has turned out to be pretty infrequent, I think it's okay to make it the thing you have to do explicitly.  If you don't, and try to use a handle outside its function, it would give you an error message directing you to <code>reb.Unmanage()</code></p>
<p>Then if this turned out to be inefficient for whatever case, there could be a mode where console messages tell you about places you didn't reb.Release() things.  People who care could turn that feature on as part of a performance audit.</p>
<p><em>(Another possibility would be a simple rule that API handles rtruly can only live as long as the function they're in--with no way to extend it.  So if you want to outlast that, you have to insert the value into some physical Rebol global map or array so you can find it again after your handle goes bad.  The watchlist is in fact doing that right now: the JavaScript isn't holding handle objects to Rebol nodes, but a Rebol <code>watches</code> array holds them and then the JS can retrieve them later by index.  That saves us on the design of any kind of reb.Unmanage() and the potential for leaking "invisibly"...you'd be seeing some physical Rebol map filling up in userspace.  But it means every user would have to come up with their own ID scheme.  There are pros and cons to this...maybe enough of a pro to say it's the way we do it until further notice.)</em></p>
<h2>C will stay more or less how it is.</h2>
<p>It's possible in JavaScript to have a non-heap-address-thing which represents an allocation (a JS object), to act as a safe stub to prevent system crashes if it's used past a time when it bears some marking of expiration.  In C, you just crash.</p>
<p>So there's no real way of doing what I propose above in C.  You can mark a handle you've handed out a pointer to as being invalid.  But then, when do you free() that stub?  If you ever do, you'll run the risk of a client holding onto it crashing.</p>
<p>This means the parallel to the method above--of considering handles expired after the function that was on the stack when it ran ends--would have a crashier outcome.  That's life in C.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/managed-unmanaged-expectations-in-the-javascript-api/1144">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/managed-unmanaged-expectations-in-the-javascript-api/1144</link>
          <pubDate>Sun, 14 Apr 2019 12:02:58 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1144</guid>
          <source url="https://forum.rebol.info/t/managed-unmanaged-expectations-in-the-javascript-api/1144.rss">Managed/Unmanaged Expectations in the JavaScript API</source>
        </item>
        <item>
          <title>Beta/One Quoting in the API decision: rebValue() and rebValueQ()</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Language Bridging</category>
          <description><![CDATA[
            <p>In the question of whether or not APIs should quote spliced values, the answer is...</p>
<h2>
<strong>Only if you ask it to</strong> <em>...but...</em> <em><strong>make it really easy to ask</strong></em>.</h2>
<p>Previously this was considered to be undesirable:</p>
<pre><code>const char *spelling = rebSpell(rebQ(word));
</code></pre>
<p>To mitigate that, instead go ahead and offer a "Q" version of every variadic evaluating API:</p>
<pre><code>const char *spelling = rebSpellQ(word)
</code></pre>
<p>You can choose either way, and you can also switch back and forth with rebQ() to add a quoting level to your splices and rebU() to remove one.</p>
<h2>Looks good enough AND makes people feel in control</h2>
<p>People may grumble when <code>rebValue("append [copy reduce]", word);</code> acts like:</p>
<pre><code>do compose [append [copy reduce] (word)]
</code></pre>
<p>They may have forgotten they were in C (or JavaScript, or whatever), and at runtime in that language the variable names are gone.  There is no "word"...just as "word" is gone after the COMPOSE is finished.</p>
<p>Though they may grumble...at least they'd understand.  On the other hand, they might get pretty mad if they get <strong>['10 '20]</strong> out of the following if x and y are plain INTEGER!</p>
<pre><code>REBVAL *coordinate = rebValue("reduce [", x, y, "]");
</code></pre>
<p>This is why I think the Q is important to have <em>somewhere</em> . If they'd used <code>rebValueQ()</code>, they feel more like <em>"oh, I asked for that...didn't I!"</em></p>
<p>So the way I look at it is that if someone studies the issues and decides they want to use the Q APIs by default and never touch the non-Q ones, then that's their business.  If someone goes the other way, they can do that.  But I think looking at what kind of code you're writing and choosing appropriately makes the most sense...which was the direction I'd been headed in.</p>
<h2>COMPOSE may be able to benefit from this, too</h2>
<p>COMPOSE can use .QUOTE (today, /QUOTE) as a "predicate" to tell it to quote the things it put in slots:</p>
<pre><code> &gt;&gt; word: first [print]
 &gt;&gt; compose .quote [append [copy reduce] (word)]
 == [append [copy reduce] 'print]
</code></pre>
<p>Though it's pretty lightweight as is to say <code>'(...)</code> on your slots instead of just <code>(...)</code>, you still might want a specialization for this if you had a lot of them.  Maybe called <strong>composeQ</strong> to line up with the API (I've wondered about doing mixed-case names like that, as I'm not crazy about <code>compose-q</code> or <code>composeq</code> or <code>qcompose</code>.)</p>
<p>In any case, working with compose lately got me seeing it through the lens of <em>"how much better do you expect a C API to a language to be than the language itself."</em>  I think it's gotten to right about where it can be, and at this point there's more value in having the API stable than in tweaking it more.  So this is what I'm ready to commit to for Beta/One.</p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/beta-one-quoting-in-the-api-decision-rebvalue-and-rebvalueq/1095">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/beta-one-quoting-in-the-api-decision-rebvalue-and-rebvalueq/1095</link>
          <pubDate>Mon, 04 Mar 2019 04:56:30 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1095</guid>
          <source url="https://forum.rebol.info/t/beta-one-quoting-in-the-api-decision-rebvalue-and-rebvalueq/1095.rss">Beta/One Quoting in the API decision: rebValue() and rebValueQ()</source>
        </item>
        <item>
          <title>Quoting Ergonomics in the API -- Solved with Terminology?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Language Bridging</category>
          <description><![CDATA[
            <p>Old questions need to be pinned down.  And a <em>huge</em> one in the API--<a href="https://forum.rebol.info/t/should-word-path-function-be-live-by-default-in-rebdo/371">practically the first question there was</a> about the libRebol model--is what this should do:</p>
<pre><code>rebSpell("mold", print_word);   // print_word is the WORD! for PRINT
</code></pre>
<p>Should it:</p>
<ol>
<li>Give back the UTF-8 C string "print"</li>
<li>Error, and say "PRINT is missing its LINE parameter"</li>
</ol>
<p>If you go with option <span class="hashtag">#1</span>, you have to make evaluation explicit when you want it... e.g. with some kind of EVAL operator:</p>
<pre><code>rebElide(rebEVAL(print_word), "{This only prints if you use rebEVAL}");

rebElide(rebE(print_word), "{rebE offered as shorthand for rebEVAL.}");
</code></pre>
<p>If you go with option <span class="hashtag">#2</span>, you'll be putting a lot of QUOTE operators in:</p>
<pre><code>rebSpell("mold", rebQUOTE(print_word));

rebSpell("mold", rebQ(print_word));
</code></pre>
<p><em>(Note: In all proposals considered thus far, UTF-8 C text like <code>"mold"</code> is scanned and left in place as-is.  It's only the spliced values to which this question applies.)</em></p>
<h2>The API has been defaulting to option <span class="hashtag">#1</span> (no error)</h2>
<p>Which interpretation is most convenient will depend on what you're looking at.  But just going by the numbers, there are a lot more calls just like <strong>rebSpell(print_word);</strong> than there are invocations of functions stored by WORD! or ACTION! in a C variable.  It seems a shame if they have to be written as <strong>rebSpell(rebQ(print_word));</strong></p>
<p>I could give a ton of examples where option <span class="hashtag">#1</span> wins...if you're running code and loops and branches, it's perfect.  Yet it's still very frequent that you get bitten on quoting by default--whenever you've got a construct that's just putting together raw material.  Consider this simple example:</p>
<pre><code>REBVAL *word = ...;  // code generating some WORD!
int i_ten = rebInteger(10);
int i_twenty = rebInteger(20);

REBVAL *result = rebValue(
    "select [ten", i_ten, "twenty", i_twenty, "]", word
);
</code></pre>
<p>Now think about it quoting <em>every</em> splice.  Sure, that's good news for <code>word</code>.  But <code>i_ten</code> and <code>i_twenty</code> aren't getting evaluated to take the quote off.  So your selection product that comes back is going to be either <code>'10</code> or <code>'20</code>... QUOTED! integers.  :-/  Yuck.</p>
<h2>Naming Quote Manipulators Has Been A Point of Confusion</h2>
<p>If you go with the solution described above of rebEVAL() to tell the splice not to quote, you get something that works, but is kind of inelegant:</p>
<pre><code>REBVAL *result = rebValue(
    "select [ten", rebE(i_ten), "twenty", rebE(i_twenty), "]", word
);
</code></pre>
<p>You managed to get the message to rebValue() not to put quotes on.  But you said to do it with...EVAL?  It's not really like EVAL-the-evaluator-ACTION!, and can't substitute for it generically.  Its function is narrower...more like rebU for "unquote":</p>
<pre><code>REBVAL *result = rebRun(
    "select [ten", rebU(i_ten), "twenty", rebU(i_twenty), "]", word
);
</code></pre>
<p>Except...it's not really that either.  If you try to UNQUOTE things that don't have quotes on them you get an error in normal evaluation.  The REBVALs you're talking about--the integers--are unquoted here.</p>
<p>So what you're actually doing is <em>un-asking</em> for a special treatment.  There's not a great word for asking for the absence of something that is implicit.  <em>(It reminds me a bit of the struggle we had trying to find a way to name something to use in PRINT to mean "don't put anything between these components...no space, nothing".)</em></p>
<p>Trying to push the operator out to be something like rebBLOCK() with rebB() and subsuming the brackets loses a nice aspect the brackets offered:</p>
<pre><code>REBVAL *result = rebValue(
    "select", rebB("ten", i_ten, "twenty", i_twenty), word
);
</code></pre>
<p>That's fine if you're trying to optimize--especially if you have no runs of text that would fire up the scanner otherwise.  (It doesn't cost much to process the brackets if you already need the scanner.)  But I think it loses the clarity the brackets gave.</p>
<h2>Better Living Through Terminology</h2>
<p>I propose the rebU() and rebE() operators doing the opposite of what they do today, and having them represent <code>rebUNEVALUATIVE()</code> and <code>rebEVALUATIVE()</code></p>
<p>They are not saying what to do with a splice.  <em>They are describing the environment in which splicing is done.</em>  Hence you'd do the example above as:</p>
<pre><code>REBVAL *result = rebRun(
    "select", rebU("[ten", i_ten, "twenty", i_twenty, "]"), word
);
</code></pre>
<p>You are saying "the contents underneath this are intended to be used in an unevaluative sense, so don't bother trying to quote-escape them".  This is different from rebUNEVAL(), which was previously a quoting operation...the thought was "if you UNEVAL something, then if you EVAL what you get you'll get the original thing back".  It was hacked together in an ugly way that is handled far more elegantly with UNQUOTE and (new) QUOTE.</p>
<p>You can apply rebU() it to a single item or multiple.  You may even be able to apply it across partial spans of arrays:</p>
<pre><code>REBVAL *result = rebRun(
    "select", rebU("[ten", i_ten), "twenty", i_twenty, "]", word
);
</code></pre>
<p>If the "unevaluative" doesn't gel, you can mentally file it under "unquote_splices".  But I've explained why this is misleading, so it's not what the API operation will be called.  (If there was a rebUNQUOTE, it would error if you passed it a plain INTEGER! like the ones above.)</p>
<p>But now the question is...what about this confusing-looking thing?</p>
<pre><code>rebRun(rebU(print_word), "{This prints, but you said 'unevaluative'}");
</code></pre>
<p>Yep.  Well, an "unevaluative" context would still run if you DO it.  You can't somehow magically make things never evaluate.</p>
<p>There's nothing saying rebE() has to be a shorthand for rebEVALUATIVE() just because rebU() is rebUNEVALUATIVE().  Since evaluative is the default you probably don't <em>need</em> a shorthand for it.</p>
<p>What's more, rebEVAL could be broken out as a separate instruction, which folds the parentheses into the macro itself:</p>
<pre><code>rebRun(rebEVAL, print_word, "{It's three characters longer this way...}");
rebRun(rebE(print_word), "{...but likely clearer w.r.t. distinction from rebU()}");
</code></pre>
<p>The extra three characters don't seem so bad, considering EVAL is something that applies to only the thing directly following it.  And as I say, wanting to EVAL is not as common as you think (once you remove the cases that are now covered by rebU(), which were poorly expressed and thought of as being actual EVALs).  This rebEVAL could be nothing but a clever trick that just folds into not quoting if at a non-BLOCK! level, but injects the EVAL native as an ACTION! if it winds up being inside a scanned block!  <em>(yes, details I know few people understand the ramifications of what I'm talking about.)</em></p>
<p>Anyway...when seen through this lens, I think it all makes sense.  You start out in an EVALUATIVE context, which quotes splices by default.  Then you can rest easy knowing that if you're in a situation where it's not what you want, you're just one rebU() away from having what you need...</p>
<h2>Afterthought...should ACTION!s be "special" and auto-evaluate?</h2>
<p>If the concept of the API is to treat the C variable lookup as if it were a WORD! being fetched, and thus give the inert value, there are three notable exceptions in the evaluator:</p>
<ul>
<li>a WORD! looking up to an ACTION! evaluates</li>
<li>a WORD! looking up to a null errors without a special GET-WORD! exception</li>
<li>a WORD! looking up to a VOID! errors without a special GET-WORD! exception</li>
</ul>
<p>Indeed, most of the rebEVAL examples are on ACTION!s, and the cases where you are passing them by value are few and far between.</p>
<p>But...I'd be very wary of making the behavior at the API level take this on.  There are levels at which the API simply will not work the way the evaluator does...<em>because it can't</em>.  You can't say <strong>rebRun("lit", my_word)</strong> and get back the WORD! <code>my_word</code>...as an obvious example.  Do we really want to have to say:</p>
<pre><code>if (rebDid("null?", rebG(maybe_null_or_void_REBVAL)) {
      // rebG() as in rebGET(), but as in EVAL TO GET-WORD!...?
}
</code></pre>
<p>That seems pretty insane, when compared to the comfortable "it gets a quote level in evaluative contexts" or "it gets no quote level in unevaluative contexts".</p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/quoting-ergonomics-in-the-api-solved-with-terminology/1050">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/quoting-ergonomics-in-the-api-solved-with-terminology/1050</link>
          <pubDate>Sat, 02 Feb 2019 11:12:43 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1050</guid>
          <source url="https://forum.rebol.info/t/quoting-ergonomics-in-the-api-solved-with-terminology/1050.rss">Quoting Ergonomics in the API -- Solved with Terminology?</source>
        </item>
        <item>
          <title>Eliminating &quot;Internal&quot; API Support in User Natives</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Language Bridging</category>
          <description><![CDATA[
            <p>I'm tackling the build process for user natives, and trying to figure out how they might actually be used.  One key point is that you don't use the nuanced and complex internal API with them.</p>
<p>From the README I'm writing:</p>
<blockquote>
<p>Symbol linkage to the internal libRebol API is automatically provided by the extension. This is the ergonomic external API (e.g. %rebol.h), not the full internal implementation API (e.g. %sys-core.h).</p>
<p>But the initial implementation of user natives <em>DID</em> make the full internal API available. This involved invoking TCC during the build process to pre-process all of the many files included by %sys-core.h into a single blob, and then pack it into the executable. It also made every API and constant available in the symbol table--with its name, to use with tcc_add_symbol().</p>
<p>This predated libRebol's modern form, so it was the only choice at the time. But now it does not make sense to allow calling %sys-core.h from user natives. If anyone is actually seeking some "optimal efficiency" (with "maximal effort") that the core API can offer, <em>TCC is not an optimizing compiler in the first place</em>. Any serious larger-scale initiative would want to use the extension model, with a "fancier" compiler and debugger on hand.</p>
<p>libRebol also has a drastically smaller footprint for the header (as %rebol.h is a single standalone file). Not having a large table of every internal API and constant in the system--along with its name--saves space as well. So "rebol.h" is what is used, as the most practical option.</p>
</blockquote>
<p>It's a good change, along with several other good changes in that README that should push the feature along (and reign it in so it's not holding the build process hostage to a forked version of TCC that I never quite knew how to build).</p>
<p><strong>Because the forum is kind of a "development notebook", I'm taking some of the code that's getting the axe and putting it here with some commentary.  This makes it easier to link to and talk about, or find later, vs. having it disappear into git archive history without an explanation.</strong></p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/eliminating-internal-api-support-in-user-natives/952">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/eliminating-internal-api-support-in-user-natives/952</link>
          <pubDate>Mon, 10 Dec 2018 01:06:56 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-952</guid>
          <source url="https://forum.rebol.info/t/eliminating-internal-api-support-in-user-natives/952.rss">Eliminating &quot;Internal&quot; API Support in User Natives</source>
        </item>
        <item>
          <title>User natives: what should functions like `printf` actually call?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Language Bridging</category>
          <description><![CDATA[
            <p>When making the original TCC natives, Shixin wanted to make it so that you didn't have to have anything but a single "rebol.exe" on your disk to compile and run code.  That meant making sure that whatever was needed to process <code>malloc()</code> or other functions needed to ship in that executable.</p>
<p>TCC offered a small library called <code>libtcc1.a</code> which implemented a subset of the standard C runtime library.  But when the TCC API is compiling code into memory (and not hitting the disk at all), you can give it pointers to functions in your host executable to run for each symbol.</p>
<p>Presumably in order to give the most "tcc-like" experience, Shixin forked TCC into a variant that could give you a table of everything in libtcc1.a.  This meant when you'd call malloc() or printf() you'd get the same implementation that calling tcc on the command line would get, if you only had tcc installed on your system (no GCC, so no GNU libc).</p>
<p>But this is fairly wasteful.  The running Rebol already has malloc() in it, and several other basic functions you might rely on for math or otherwise in your C code.  Using those is as easy as <code>tcc_add_symbol("malloc", &amp;malloc);</code>   So really we could save a lot of grief (and some redundant memory usage) just by making a little table of C functions from the libc we're already using for Rebol, and add them.  This would mean getting rid of the maintenance and building of forked repositories of TCC--a very desirable objective.</p>
<h2>But Rebol doesn't include printf...</h2>
<p>Rebol doesn't itself include printf in release builds (and if you want a little motivation as to why to stick to this decision and instead develop structured Rebol-powered printing, <a href="http://blog.hostilefork.com/where-printf-rubber-meets-road/" rel="nofollow noopener">here's a little primer on why</a>).</p>
<p>That's not a big deal, as the tcc extension could include it.  Then you only get it in the EXE if you build the extension into the EXE, otherwise you get it in the DLL for TCC.</p>
<p><em>Yet there may be a more interesting option.</em>  Why would we want to use libc's printf, and not a custom printf that targeted the Rebol output device?  As a simplified example of what this might mean:</p>
<pre><code>int tcc_printf( const char* format, ... ) {
    char *buffer = ...
    ... unpack format string and args into buffer ...
    rebElide("write-stdout", rebT(buffer));
    ... free buffer, return num chars printed ...
}

REBNATIVE(compile) {
     ...
     tcc_add_symbol("printf", &amp;tcc_printf);
     ...
}
</code></pre>
<p>It's probably the case, as per my article--that the right place to hook this is actually <code>write</code> to stdout's device--which would be more complex.  And you'd want to intercept read too, so scanf() would work properly.</p>
<p>Basically this would allow you to intercept the I/O from a built TCC executable and use it in whatever GUI console you liked.  If TCC added support for webassembly in-memory targets someday, you could have user natives on the web, too.</p>
<p>Of course people can also use libRebol directly, which is what new code should do...but it's interesting to think about just being able to paste in C routines unmodified and have it integrate directly into whatever your console is.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/user-natives-what-should-functions-like-printf-actually-call/949">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/user-natives-what-should-functions-like-printf-actually-call/949</link>
          <pubDate>Sun, 09 Dec 2018 01:40:23 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-949</guid>
          <source url="https://forum.rebol.info/t/user-natives-what-should-functions-like-printf-actually-call/949.rss">User natives: what should functions like `printf` actually call?</source>
        </item>
        <item>
          <title>New datatype idea: SINK!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Language Bridging</category>
          <description><![CDATA[
            <p>Right now the only way you can get handles back from the API is as return results.  This means if you want to extract N values, you have to make N calls:</p>
<pre><code>REBVAL *a = rebRun("select", obj, "'a");
REBVAL *b = rebRun("select", obj, "'b");
</code></pre>
<p>But what if you could target API handle pointers directly, to get something <em>like</em> a SET-WORD!, except that the evaluator would <em>write into an API handle pointer instead of an ordinary variable</em>:</p>
<pre><code> REBVAL *a;
 REBVAL *b;
 rebRun(
     rebSink(&amp;a), "select", obj, "'a",
     rebSink(&amp;b), "select", obj, "'b"
 );
</code></pre>
<h2>Why would this be useful?</h2>
<p>It's often tricky to tunnel the variable your code wants out of a complex expression.  Take the <a href="https://forum.rebol.info/t/should-trap-and-catch-return-null-if-no-fails-throws/940">upcoming change to TRAP</a>, for example.  The TRAP only gives back an ERROR!, but what if you want to write your error handling code in Rebol...tunneling your value out of the trap?</p>
<pre><code>REBVAL *data = ...;
rebElide("trap [",
    rebSink(&amp;data), "inflate/max", data, "uncompressed-size",
"] then [",
    "info {^- -&gt; failed [deflate]^/}",
    "throw blank",
"]");
</code></pre>
<p>Note how this parallels <code>data: inflate/max data uncompressed-size</code>.  It's a lot easier than what you'd have to do otherwise in the C.</p>
<h3>This is difficult to do safely...</h3>
<p>One risk with something like this what happens if a SINK that's holding onto a pointer gets copied out somewhere and then used after that pointer is no longer valid.  Consider:</p>
<pre><code> REBVAL *Make_Evil_Block() {
      REBVAL *local;
      return rebRun("[", rebSink(&amp;local), "10]");
 }

 rebRun("do", Make_Evil_Block());
</code></pre>
<p>What'll happen there is you get something parallel to <strong>local: 10</strong>, except it's writing to a local variable that's no longer on the stack when Make_Evil_Block() finishes.</p>
<p>A possible way to address this would be to require the variable to already exist so that it could become managed.  So'd you'd pass a pointer to a REBVAL, not a pointer-to-a-pointer to a REBVAL:</p>
<pre><code> REBVAL *Make_Evil_Block() {
      REBVAL *local = rebBlank();
      return rebRun("[", rebSink(local), "10]");
 }
</code></pre>
<p>This would mean the GC would be responsible for making sure the API handle's memory slot remained valid until places it was referenced were gone.  Hence a rebRelease() call wouldn't actually release it.  That would mean the interpreter wouldn't crash if it hit a bad sink, it would just say C was done with that variable so you can't assign it.</p>
<p>Unfortunately this rules out sinking nulls.  You'd have to at least TRY anything you'd sink, because from the API's point of view the only representation of a nulled cell is a nulled pointer.</p>
<p>I think doing it unsafely would be too risky.  It's one thing to have a random C native someone wrote crash, and another to give the evaluator something it crashes on during an evaluation.  So if this were implemented, it would be one of the motivating cases for <a href="https://forum.rebol.info/t/should-values-given-to-c-through-api-handles-be-mutable/345/2">mutable API handles</a>, which has remained an open question.</p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/new-datatype-idea-sink/944">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/new-datatype-idea-sink/944</link>
          <pubDate>Thu, 06 Dec 2018 18:37:35 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-944</guid>
          <source url="https://forum.rebol.info/t/new-datatype-idea-sink/944.rss">New datatype idea: SINK!</source>
        </item>
        <item>
          <title>On Giving libRebol JS more powers than JavaScript</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Language Bridging</category>
          <description><![CDATA[
            <p>It seems modest to imagine adding a function to a browser's JavaScript, which looped through two strings, printed both, and gave you back the second to display in a browser <code>&lt;div&gt;</code>:</p>
<pre><code>var second = rebSpell(
    "loop 2 [data: ask text! | print [{You typed:} data]] data"
)
console.log("Second string entered was" + second)
</code></pre>
<p><em>(Let's say the place it's carrying out the input and printing communication is in some kind of textedit-like control, and that is implicit.)</em></p>
<p>What could be simpler than that?!</p>
<h2>Web browsers aren't designed to work this way <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=9" title=":frowning:" class="emoji" alt=":frowning:">
</h2>
<p>Nothing about <em>"JavaScript-the-language"</em> particularly prohibits it from doing things synchronously.  You find various synchronous APIs here and there... <code>console.log()</code> will write synchronously to the console, and <code>alert()</code> famously (and irritatingly) gives you a modal popup that will freeze everything until it's dismissed.  Historically, you could even ask that an <code>XMLHttpRequest</code> be synchronous (a feature <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Synchronous_and_Asynchronous_Requests#Synchronous_request" rel="nofollow noopener">now disabled on the main thread</a> and thus restricted to web workers).</p>
<p>So it isn't JavaScript with the limit--any more than C or anything else.  It's the browser.  While a JavaScript function is running on the main thread, the painting and mouse events and who-knows-what-else won't happen.</p>
<p>This isn't particularly new in the GUI app world...but it is particularly strict.  Even Windows offered things like <a href="https://msdn.microsoft.com/en-us/library/ms910649.aspx" rel="nofollow noopener">PeekMessage()</a> to let you sneakily look through and process mouse messages without giving up control.</p>
<p>The tightening grip of the browser makers is speaking loud and clear:</p>
<ul>
<li><strong>there are some things only the GUI thread will ever be able to do</strong></li>
<li><strong>none of those things will be synchronous on the GUI thread--you can ask for work to be done, but will always be called back later with any result</strong></li>
</ul>
<h2>So the code above is actually impossible?</h2>
<p>Well, it's <em>almost</em> impossible.  If you use <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/prompt" rel="nofollow noopener">Window.prompt()</a> you can get input in an alert-box style modal dialog.  And if you use <code>console.log</code> or <code>Window.alert()</code> for PRINT, it could "work"...but no one wants that.</p>
<p>Note what the "impossible" part of it is--the expectation that it runs and can output the result synchronously.  If you were willing to instead write something like:</p>
<pre><code>rebSpellCallback(
    "loop 2 [data: ask text! | print [{You typed:} data]] data",
    function (second) {
        console.log("Second string entered was" + second)
    }
)
// any residual code here happens *before* the console.log output
</code></pre>
<p>Then that could be made to work.  And since JavaScript programmers noticed over time that their language was a callback-reductio-ad-absurdum, they tried to address it with something called ASYNC/AWAIT:</p>
<pre><code>async function whatever() {
   var second = await rebSpellPromise(
        "loop 2 [data: ask text! | print [{You typed:} data]] data"
   )
   console.log("Second string entered was" + second)
   // any residual code here happens *after* the console.log output
}
</code></pre>
<p>In most ways this is just a syntax trick for the previous code pattern, so you don't have to write a cascading line of callbacks for every step in a sequence.</p>
<p>It looks good.  <em>BUT</em> since it has to do some amount of "unwinding" to achieve its illusion, it has the unappealing property that if you ever call an async function from one that is <em>not</em> marked async (or if you leave off the AWAIT), the illusion is broken.  You will just get a return object that's a "promise"...and the code after the promise will run before the consequences you were "awaiting" happen...just as if you'd had it trailing outside the place where you passed a callback function.</p>
<h2>Wouldn't JS programmers just <em>accept</em> rebPromise()?</h2>
<p>For larger operations, they probably wouldn't blink.  They'd presumably be upset if JavaScript's addition required a callback to get the sum.  But I can't honestly I say I know where their line is...and wouldn't be shocked if there was a BigNum library where they said the reason you had to wait for a callback for the sum was that it could be a potentially long operation and they didn't want to block the GUI, so it was dispatching it to a worker and would call you back when done.  (?)</p>
<p>As an integral part of its variadic design, libRebol doesn't actually have any dedicated "small" operations.  There's no separate atomic "give me the spelling of this REBVAL that is known to be an ANY-STRING!, and do only that", you can always throw in extra code.  Even just asking to PROBE a string before returning its spelling would count, so long as its based on a DOM-manipulating PRINT:</p>
<pre><code> var sync_possible = rebSpell(some_str)
 console.log("spelling is: " + sync_possible);

 var sync_impossible = rebSpell("probe", some_str)
 // wouldn't be guaranteed that print was done by this line
 // if probe is based on synchronous-seeming print, sequencing lost
</code></pre>
<p>What I've thought of as a compromise would be to add rebPromise(), but still offer all the other APIs.  Then have the other APIs trigger a failure if at runtime they discover they require synchronous operations...and point you to use rebPromise.  If you're using async functions you'd say:</p>
<pre><code>var value = await rebPromise("probe", str);
var sync_illusion = rebSpell(value);
rebRelease(value);
</code></pre>
<p>Simplifyable to:</p>
<pre><code>var sync_illusion = rebSpell(rebR(await rebPromise("probe", str)));
</code></pre>
<p>While you can't abstract away the AWAIT (it's part of the language) I think we could probably get a pre-released promise result with a new API "instruction":</p>
<pre><code>var sync_illusion = rebSpell(await rebP("probe", str));
</code></pre>
<p>So if you're using modern JavaScript and async functions, you could probably just inject <code>await rebP( )</code> into the existing API set of operations, if it turned out what you were doing required it.</p>
<blockquote>
<p>I'll quickly point out that if it seems having to do results with callbacks seems onerous, that the more modern an API in JavaScript is, the more of them they have.  If you look at something like the fetch() API, not only do they have to "wait on" the server to return a response, the response itself then breaks down into more pieces you have to wait on!  From <a href="https://mdn.github.io/fetch-examples/fetch-array-buffer/" rel="nofollow noopener">a fetch example</a></p>
<pre><code>fetch('viper.ogg')
  .then(function(response) { return response.arrayBuffer(); })
  .then(function(buffer) {
    audioCtx.decodeAudioData(buffer, function(decodedData) {
      source.buffer = decodedData;
      source.connect(audioCtx.destination);
    });
  });
};
</code></pre>
</blockquote>
<h2>But not all cases are pathological</h2>
<p>Another angle to look at this is that trying to write an interactive REPL for a language running a synchronous script is actually a really hard example, and may make me worry more than I should.</p>
<p>A lot of projects would probably be fine having their PROBE and DUMP operations output to <code>console.log</code>, and not need synchronous interaction with some control that's part of the DOM.  Many interactions with the DOM are fire-and-forget...expected to just update when they update...a small snippet of code runs, and there's no requirement that the updates be completed before anything else happens.</p>
<p>There may be a number of cases where someone might want to use Rebol as part of their web app and never expect it to do any I/O at all.  I don't really know.  It's all very speculative at the moment!</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/on-giving-librebol-js-more-powers-than-javascript/849">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/on-giving-librebol-js-more-powers-than-javascript/849</link>
          <pubDate>Wed, 10 Oct 2018 01:04:32 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-849</guid>
          <source url="https://forum.rebol.info/t/on-giving-librebol-js-more-powers-than-javascript/849.rss">On Giving libRebol JS more powers than JavaScript</source>
        </item>
        <item>
          <title>The Nuts and Bolts of where API strings are bound</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Language Bridging</category>
          <description><![CDATA[
            <p>In <a href="https://forum.rebol.info/t/limiting-api-entry-points-in-favor-of-exchanging-strings/540/4">Limiting API Entry Points in Favor of Exchanging Strings</a>, I explain the rationale behind Ren-C's choice to gear the "user-friendly" external API around strings.</p>
<p>The huge question this opens up is where the strings are bound <em>(at least, where they start out being bound...BIND operations can further modify that)</em>.</p>
<p>Let's start with a simple yet "pathological" program that mucks up its environment by redefining APPEND:</p>
<pre><code>#include "rebol.h"

int main(int argc, char* argv[]) {
   rebStartup();

   const int ten = 5 + 5;
   rebElide(
       "append:", rebI(ten),
       "print [{APPEND is} append]"
   );

   rebShutdown();
}
</code></pre>
<p>Today, that would print <code>APPEND is 10</code>.  You probably expect this would only affect further code using the API, because this only overwrites APPEND in something like the "user context".  Mezzanine routines that were using APPEND would be bound to lib's variable, which still points to the function they were expecting.</p>
<p><em>(Be sure to read <a href="https://forum.rebol.info/t/the-real-story-about-user-and-lib-contexts/764">"The Real Story About User and Lib Contexts"</a> for background on what's going on there, and the challenges this presents in Rebol's paradigm.)</em></p>
<p>While that sounds a sensible starting point, let's look further.</p>
<h2>Function Args and Locals</h2>
<p>Let's say that your code isn't just in main(), but rather part of the implementation of a body of a function.  When discussing <a href="https://forum.rebol.info/t/how-to-bridge-arguments-to-user-natives-js-natives/817/2">how JavaScript or TCC natives access their arguments</a>, I suggested that the current ACTION! on the stack might influence the binding.</p>
<p>Continuing the study of pathological cases, let's imagine one of those has a refinement called /APPEND:</p>
<pre><code>frobulate: native [x [integer!] /append] {
    int x = rebUnboxInteger("x");
    bool append = rebDid("append"); // e.g. binds to the refinement argument
    int result = some_c_based_frobulator(x, append);
    return rebInteger(result);
}
</code></pre>
<p>This idea seems pretty nice on the surface.  You wouldn't expect APPEND to call the series action in a Rebol function either...since it would be overridden.  You'd have to use <code>lib/append</code>.</p>
<p>But what if the source for the C function <code>some_c_based_frobulator()</code> is something like this:</p>
<pre><code> int some_c_based_frobulator(int value, bool extend) {
     REBVAL *block = rebRun("copy []");
     int n;
     for (n = 0; n &lt; value; ++n)
         rebRun("append", block, rebI(n)); // Uh oh...still the refinement!
     return rebUnboxInteger(extend ? "last" : "first", rebR(block));
 }
</code></pre>
<p>Putting aside that this example is nonsensical (it could have just returned value if extend or 0 if not), the important part is that you called an arbitrary C subroutine, that's now trying to use APPEND.  As far as the Rebol ACTION! stack goes, there's nothing to distinguish this from the body of the <code>frobulator</code> native...so if that stack is used to determine the binding of APPEND, it will still be the refinement.</p>
<p>Hence: <strong>C subroutines which utilize libRebol API code are the Achilles heel of using the ACTION! stack to inform binding</strong>.</p>
<h2>It affects extension MODULE!s too...</h2>
<p>The concept of guiding binding by the currently running ACTION! wasn't just an idea for looking up arguments to the function.  Because when extensions register natives, those natives remember that extension's MODULE!...which (in theory) isolates any redefinitions it needs.  So finding a native meant also finding what context to look up words in--instead of just assuming the user context.</p>
<p>But again we have the problem.  Let's say you're inside a native defined in the ODBC module, where perhaps it has redefined APPEND to be something database related (and it uses LIB/APPEND if it needs the series operation).  But when you're in the Crypto module, it wants APPEND to be something else.</p>
<pre><code> // in a shared library
 int common_c_routine(...)
    { ... rebElide("append", ...); ... }

 // in the ODBC extension
 some-odbc-thing: native [...]
     { ... common_c_routine(...) ... }

 // in the Crypto extension
 some-crypto-thing: native [...]
     { ... common_c_routine(...) ... }
</code></pre>
<h2>Are these different problems?</h2>
<p>Certainly they're problems <em>in the same spirit</em>.  However, the module granularity presents a sort of "worldview", and maybe the burden could be on a shared routine that knows it's going to be shared to establish some kind of context switch.  The scenario of using a shared routine within a module between different ACTION!s seems much more common, and much more likely to cause confusion.</p>
<p>It might be better to separate out the binding to function arguments via special operators like <code>rebArg("name")</code>, rather than have them affect all API calls in any routine while that action happens to be on the stack.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/the-nuts-and-bolts-of-where-api-strings-are-bound/820">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-nuts-and-bolts-of-where-api-strings-are-bound/820</link>
          <pubDate>Mon, 17 Sep 2018 21:18:01 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-820</guid>
          <source url="https://forum.rebol.info/t/the-nuts-and-bolts-of-where-api-strings-are-bound/820.rss">The Nuts and Bolts of where API strings are bound</source>
        </item>
        <item>
          <title>How to bridge arguments to user natives / JS natives</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Language Bridging</category>
          <description><![CDATA[
            <p>The current plan for calling JavaScript from Rebol involves the creation of "JavaScript natives".  These would have specs that are BLOCK!s, which would be familiar as in functions.  Then they would have bodies that were TEXT! strings of JavaScript code.</p>
<p>A seemingly unambitious example which used JavaScript to perform addition might look like:</p>
<pre><code>jadd: js-native [a [integer!] b [integer!]] {
    var a = reb.UnboxInteger("a");
    var b = reb.UnboxInteger("b");
    return reb.Integer(a + b);
}
</code></pre>
<p>So that would mean from Rebol you could say <code>jadd 10 20</code> and it would actually perform that addition in JavaScript.</p>
<p>Let's talk about some axes of potential improvement.</p>
<h2>Generic Unboxing</h2>
<p>Because C lacks dynamic typing, we need separate routines for unboxing integers and strings.  But JavaScript could conceivably do it automatically, calling rebUnbox() instead of rebUnboxInteger()...and then know if it was an integer type, to give back a JavaScript "Number":</p>
<pre><code>jadd: js-native [a [integer!] b [integer!]] {
    var a = reb.Unbox("a");
    var b = reb.Unbox("b");
    return reb.Integer(a + b);
}
</code></pre>
<p>On the downside of this, you don't get an assertion or check that the thing you extracted is an integer...so you might get back a string or other object, if the type isn't what you expect.  It's probably best to offer both and let people decide which they want.</p>
<h2>Auto-conversion of JS Number <em>non</em>-Objects</h2>
<p>It might seem cool if the API could automatically convert JavaScript numbers into Rebol values, and not have to use rebInteger(n) or rebI(n).  For instance, this seems good:</p>
<pre><code> var n = 5;
 var s = reb.Text("Hello World");
 reb.Elide("loop", n, "[print", s, "]");
</code></pre>
<p>But right now, the problem with this is that <code>s</code> is a pointer to a Rebol value on the webassembly heap.  And that's some big random-looking Number.  There's no way to tell that 5 isn't meant to be a pointer too.</p>
<p>One trick I thought of, though, involves realizing that JavaScript has both primitives and <em>primitive objects</em>.  For reference, see this article on <a href="http://adripofjavascript.com/blog/drips/javascripts-primitive-wrapper-objects.html">JavaScript's Primitive Wrapper Objects</a>.  These lightweight objects come into existence as a means of being able to call methods, e.g. <code>n.toString()</code>.</p>
<p>Hence--what if Rebol handles were passed back not as JavaScript numbers, but as number objects?  These would presumably be more lightweight than an ordinary object, so not very costly.  That way, when plain JavaScript numbers were used it could be assumed that they should be automatically treated as if they were numbers.</p>
<p>Our adding example could then simplify to:</p>
<pre><code>jadd: js-native [a [integer!] b [integer!]] {
    var a = reb.Unbox("a");
    var b = reb.Unbox("b");
    return a + b;
}
</code></pre>
<h2>Auto-conversion of JS String objects</h2>
<p>Strings might benefit from the distinction of primitives vs. primitive objects as well.  Today, plain non-object strings are LOAD-ed and executed as code:</p>
<pre><code>REBVAL *v = reb.Value("Hello World");
</code></pre>
<p>What happens there is that it treats that as two WORD!s.  But if you said:</p>
<pre><code>REBVAL *v = reb.Value("{Hello World}");
</code></pre>
<p>That would be a TEXT! string.  You could also use rebText() or rebT() if your string is in a variable.</p>
<p>But string <em>objects</em> could be handled differently, and assumed to be string literals.  So you couldn't say <code>return "hello"</code> from a user native, but you could say <code>return new String("hello");</code></p>
<p>That's more typing than just <code>return reb.Text("hello")</code>.  But where it might come in handy in that you could write a generic JavaScript routine that could return a string to be passed unmodified to either JS or Rebol.</p>
<pre><code>function genericName(...) { ... return new String(...); }
console.log("used direct from JS: " + genericName(...));
reb.Elide("print [{used direct from Rebol:}", genericName(...), "]");
</code></pre>
<h2>Parameter Unpacking as JavaScript</h2>
<p>What I have in mind for both C user natives and JavaScript natives is not to try and give the generated JavaScript function any actual arguments.  So back to the example:</p>
<pre><code>jadd: js-native [a [integer!] b [integer!]] {
    var a = reb.Unbox("a");
    var b = reb.Unbox("b");
    return a + b;
}
</code></pre>
<p>We're generating and running a JavaScript function with no arguments, so if it wants to get the values of <code>a</code> and <code>b</code> it has to go through Rebol code (automatically bound into the function frame) to access them.</p>
<p>It is <em>possible</em> to give that function arguments.  These arguments could be the raw Rebol values, or they could be pre-rebUnbox'd.  At the extreme of pre-unboxing, you could write just:</p>
<pre><code>jadd: js-native [a [integer!] b [integer!]] {
    return a + b;
}
</code></pre>
<p><strong>I think it's better to not have arguments to the function.</strong></p>
<ul>
<li>
<p>The TCC-based C natives don't have the luxury of being able to do things like this in a platform-independent fashion.  Feeding arguments to a C function varies from platform-to-platform based on the Application Binary Interface (ABI).   It's more consistent between C and JavaScript extensions to not do it.</p>
</li>
<li>
<p>There's no support in <a href="https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/Interacting-with-code.html#interacting-with-code-call-javascript-from-native">the EM_ASM() bridge</a> for variadic calls.  Doing it in JavaScript and calling from C involves jumping through a lot of hoops, possibly using eval() when it wouldn't otherwise be necessary, and is less performant.  If the function took zero parameters and returned an integer heap address it would be a lot cleaner.</p>
</li>
<li>
<p>JavaScript variable naming is more limited than Rebol parameter naming.  So there'd have to be some invented mapping between what name you used for the parameters in your spec and the JavaScript names.</p>
</li>
<li>
<p>You don't really know what properties the JavaScript code wants from its parameters, and pre-extracting would be presumptuous.</p>
</li>
</ul>
<p>So I think JavaScript natives should be running 0-arity functions, and have to go through libRebol APIs to get at their arguments.  That will require some new mechanics.</p>
            <p><small>5 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/how-to-bridge-arguments-to-user-natives-js-natives/817">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/how-to-bridge-arguments-to-user-natives-js-natives/817</link>
          <pubDate>Sat, 15 Sep 2018 11:04:22 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-817</guid>
          <source url="https://forum.rebol.info/t/how-to-bridge-arguments-to-user-natives-js-natives/817.rss">How to bridge arguments to user natives / JS natives</source>
        </item>
        <item>
          <title>How are limited API entry points going? Great!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Language Bridging</category>
          <description><![CDATA[
            <p>When I first was going about trying to wrangle the ODBC extension to work in Ren-C, it had some C time and date structures that would come back from the database.  These are DATE_STRUCT, TIME_STRUCT, and TIMESTAMP_STRUCT.  Those have to be turned into TIME! and DATE! values.</p>
<p>But there were no functions in the API yet for making TIME! and DATE! values.</p>
<p>Well, there was rebInteger() for taking a C integer and making an INTEGER!.  So to move things along, I went ahead and made functions for taking multiple C integers and making times and dates:</p>
<pre><code>REBVAL *time = rebTimeHMS(hour, minute, second);
REBVAL *date = rebDateYMD(year, month, day);
REBVAL *datetime = rebDateTime(date, time);
</code></pre>
<p>But the API vision has established clarity about being of limited entry points.  So rather than keep cooking up new C functions taking C arguments, it's better to build on a more limited facility and call Rebol code!</p>
<pre><code>REBVAL *time = rebValue("make time! [",
    rebI(hour), rebI(minute), rebI(second),
"]");

REBVAL *date = rebValue("make date! [",
    rebI(day), rebI(month), rebI(year),
"]");

REBVAL *datetime = rebValue("use [date] [",
    "date:", date,
    "date/time:", time,
"]");
</code></pre>
<p>That third one is a little weird, and anyone who wants to suggest a better way of doing it can chime in on <a href="https://github.com/rebol/rebol-issues#2313" rel="nofollow noopener">issue #2313</a>.  But the point is to keep pushing on Rebol the language, not chasing down an infinitely long cascade of API entry points.</p>
<p>I'm feeling really good about it.  Though I will re-iterate that it does bring up all those questions of where this stuff is getting bound.  You don't want some extension deciding to redefine MAKE, or TIME!, and incidentally wind up breaking the ODBC module's expectations.  There has to be some isolation, very much similar to how modules will be isolated...except (somehow) applying to the C code.</p>
<p>But that's the vision, and if you haven't been reading the interesting usages <a href="https://github.com/hostilefork/rebol/blob/d983fdeb89b40329cf3a570f785fc109e951dc83/src/extensions/zeromq/mod-zeromq.c#L386" rel="nofollow noopener">like in the ZeroMQ extension</a>, please do!  Would be good to hear any thoughts people are having, while watching it materialize...</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/how-are-limited-api-entry-points-going-great/689">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/how-are-limited-api-entry-points-going-great/689</link>
          <pubDate>Fri, 15 Jun 2018 05:16:44 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-689</guid>
          <source url="https://forum.rebol.info/t/how-are-limited-api-entry-points-going-great/689.rss">How are limited API entry points going? Great!</source>
        </item>
        <item>
          <title>NULL in the libRebol API...and VOID? =&gt; NULL?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Language Bridging</category>
          <description><![CDATA[
            <blockquote>
<p><strong>Historical Note:</strong> This post discusses why what was called VOID at one point was ultimately chosen to be renamed as NULL.  To keep the thrust of the point coherent, the terminology has been left as-is.  Just know that for a time, what is known as NULL today was called VOID.</p>
</blockquote>
<hr>
<p>Being meticulous about getting "void" right vs. "UNSET!" <em>has been <a href="https://trello.com/c/rmsTJueg" rel="nofollow noopener">paying off tremendously</a></em>.  The swampy nature of dealing with such issues in Rebol2/R3-Alpha/Red have given way to clarity...and subsequently, enabled great and solid features.</p>
<p>Now a new bonus:</p>
<h3>If voids are always NULL in the API, there's a huge win</h3>
<p>Check out this libRebol pattern, taking advantage of <a href="https://github.com/rebol/rebol-issues/issues/1611#issuecomment-385719133" rel="nofollow noopener">OPT and TRY</a> for conveniently wrangling the void/blank switcheroos:</p>
<pre><code> REBVAL *var = ...;
 REBVAL *obj = rebRun(
      "opt match [object! blank!] try case [",
          var, "= some/value [first foo/baz/bar]",
          "integer?", var, "and (mode = 'widget) [second mumble]",
     "]", END);

 if (!obj) {
    // leverages C's natural "NULL is falsey" property
    // so testing for success requires no extra API call
    // nothing to clean up, no handle to rebRelease()
    //
    ... code for failure ...
    return;
 }

 // Rebol code can do heavy lifting for validation / errors
 // so we can assume the value is good to go
 //
 ... code for success ...
 rebRelease(obj); // if you're done with it...
</code></pre>
<p>You let the embedded Rebol pick things apart to make sure the result is a type you care about or not.  Then your first reaction to the result can be "did I get something in the set of answers I'm interested in processing or not", and that reaction can be decided without any API call...you just take advantage of NULL being "falsey" in C.</p>
<p>Since people who aren't me haven't really been experimenting all that much with how the "voiding" has been working, you might not be as excited about it as I am.  But that's just because you haven't tried it.  <img src="//forum.rebol.info/images/emoji/twitter/slight_smile.png?v=7" title=":slight_smile:" class="emoji" alt=":slight_smile:">  OPT and TRY getting in there with all the new constructs brings a whole new level to "the game", and this idea of having an easy signal channel back to C from those constructs is really compelling.</p>
<h3>"voids" always become NULL, why not call the test NULL?</h3>
<p>Remember: <code>type of (do [])</code> is <code>_</code>.  It's a falsey/blank value to say it has no type. There's no VOID! type, because voids have no unique identity.  You can locate several different unique UNSET! cells in various arrays in R3-Alpha, mutate them to other types like INTEGER!, change them back, etc.  Not so in Ren-C.</p>
<p>No void "type" means that "changing the name of void" is really just "changing the name of the test for void"... from VOID? to NULL?.</p>
<p>This seems like a win to me.  Not only does it reduce the barrier to talking about the C behavior from the Rebol behavior, <code>null</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null" rel="nofollow noopener">can be the JavaScript representation too</a>.  The word isn't taken in Rebol to mean anything else, so why not reduce the cognitive load by using what other languages use?</p>
<p>Same number of letters in VOID and NULL.   NULL? vs VALUE? have different first letters, which may be a plus.</p>
<h3>I talked about this before, so why didn't I do it sooner?</h3>
<p>Ren-C eliminated UNSET!-typed cells in ANY-ARRAY!, but the practical mechanics of voids appearing in various places the evaluator see as "incarnated cells" have lingered.  Solutions to the problems come along one piece at a time, like the just-now-reconcieved definition of UNEVAL:</p>
<pre><code>uneval: func [
    {Make expression that when evaluated, will produce the input cell}
    return: [group!]
        {`()` if void cell, or `(quote ...)` where ... is passed-in cell}
    cell [&lt;opt&gt; any-value!]
][
    either void? :cell [quote ()] [reduce quote ('quote cell)]
]
</code></pre>
<p>So if you <strong>do compose/only [if void? (uneval :some-unset-var) [print "this prints"]]</strong>.  Necessity is the mother of invention for these kinds of things, and so far they've filled in the gaps.  Things are at a technical point where we <em>can</em> do it.</p>
<blockquote>
<p><strong>UPDATE Jan 2019:</strong> UNEVAL--and the reasons it had to be invented--motivated <a href="https://forum.rebol.info/t/quoted-arrives-formerly-known-as-lit-bit/995">Generic Quoting</a>, which has supplanted it.  Interestingly, <strong><code>(foo: ')</code></strong> uses generic quoting to assign the absence of a value to foo--and hence unsets it.</p>
</blockquote>
<p>There's still going to be the tradeoff I mentioned regarding <a href="https://forum.rebol.info/t/should-values-given-to-c-through-api-handles-be-mutable/345/2">the mutability of handles</a>.  If you have a pointer to a <code>REBVAL*</code> now which is INTEGER!, might some operation change it to a STRING! later?  Or if it's a BLOCK!, might its index be changed in place vs. making a new block?</p>
<p>Saves on handle allocations.  But now imagine that you've handed a cell out to the user through the API, and offer them an API for doing evaluations into that cell vs. making a new one.  And that evaluation produces void.  That's a transition they wouldn't be able to do under this model.  This makes an API handle's "slot" more like an array cell than it is like a context variable...it can hold blanks, just not voids.</p>
<p>Having had time to work with matters in practice and looking at the big picture, this is a small price to pay.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/null-in-the-librebol-api-and-void-null/597">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/null-in-the-librebol-api-and-void-null/597</link>
          <pubDate>Wed, 02 May 2018 13:45:45 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-597</guid>
          <source url="https://forum.rebol.info/t/null-in-the-librebol-api-and-void-null/597.rss">NULL in the libRebol API...and VOID? =&gt; NULL?</source>
        </item>
        <item>
          <title>Limiting API Entry Points in Favor of Exchanging Strings</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Language Bridging</category>
          <description><![CDATA[
            <p>When I first saw the <a href="https://doc.red-lang.org/en/libred.html" rel="nofollow noopener">libRed documentation</a>, it struck me as being...a grab-bag.</p>
<p>Why was there a <strong><a href="https://doc.red-lang.org/en/libred.html#_redappend" rel="nofollow noopener">redAppend()</a></strong> with no /PART or /ONLY?  Why no <strong>redInsert()</strong>?  Were these things missing on purpose?  Or was it just in an incomplete state--with the ultimate goal to clone the entire Rebol2 manual as a catalog of C entry points?</p>
<p>Moreover: if one is embedding a "Redbol" module or system into another language, the theory is that the win comes from dialects.  You presumably aren't just loading a raw interpreter so you can program in Rebol as awkwardly as possible--you've got some prep work already and loaded a module of code you want to use.  So who's to say I plan to be doing any APPENDing or INSERTing at all?  Or perhaps I've defined those words to mean something entirely different from the stock series operations...</p>
<p><strong>Hence</strong> though it's certainly necessary for a proper API to be able to reference Rebol values (BLOCK!s, WORD!s, etc.) via some kind of language handle, it crossed my mind that <em>ordinary requests to take action on these items should primarily be made through text strings</em>.  Rather than a <code>rebAppend(block, value)</code> and <code>rebAppendPart(block, value, limit)</code>...the entry points would be collapsed down to the likes of <code>rebDo("append/part", block, value, limit)</code>.</p>
<p><em>(Note: Whether that seems like a good idea to you on first reading or not, such a thing wouldn't typically be on the table at all for a pure C-based API.  Clever bit-twiddling makes it possible--and assuming your C compiler passes through character literal bytes as-is and you saved your file in UTF8, it even works with unicode strings.)</em></p>
<p>This possibly-"radical" idea raises questions about semantics and performance.  Here's a few talking points.</p>
<h3>What if basic operations don't look up to what you meant?</h3>
<p>Taking libRed as an example, if you say <strong>append: does [print "potato"]</strong>, then what does <code>redAppend()</code> do after that?  In their case, it doesn't heed any redefinitions, because the API entry points are fixed at time of compilation.  There's exactly as much stack pushing and popping as necessary for the parameters of the <a href="https://github.com/red/red/blob/c4f8bbf221728ba84d64a95cd9ea4f310b2ffea5/libRed/libRed.red#L894" rel="nofollow noopener">append "action!"</a>.</p>
<p>This may seem like a good thing.  If you were trying to write some code to do series surgery, having the C API keep its semantics more stable means your code will do-what-you-meant, even in the face of change.</p>
<p>But...if you're programming in just plain Rebol, you don't get this guarantee.  If you want that you have to bind directly to lib, or if you've overridden things you have to use <code>lib/append</code>.</p>
<p>What makes coding in C so sacred that it needs special rules or rights?  And as mentioned earlier, what if this is part of the whole <em>point</em> of embedding a Rebol...<em>you want to run in the potentially mutated environment</em>.</p>
<p>I'm reminded somewhat of the story of why airplanes are made out of aluminum instead of a stronger metal, when aluminum will crumple in a crash.  When you consider all the other factors of how bad a plane crash is, slightly stronger metal won't help relative to the big picture of the benefit of the lighter weight.</p>
<p>My opinion is that it's a good thing--not a bad thing--to be beholden to the same mutable universe by hinging on text.  This puts pressure on improving the mechanisms by which Rebol code can be isolated into modules/etc.  It just means the API will need to do things like speak about "which module it wants to run in".</p>
<h3>What about the overhead of scanning/binding strings?</h3>
<p>This is a bit of a nuisance...and doubly so for languages whose string literal representation is not UTF-8.  (Which right now is looking like basically every language except C/C++/Rust.)</p>
<p>Shortcuts are certainly possible; it may not be necessary to kick in the whole scanner to know that "{foo}" should be a string.  And sticking with the idea that source series are read-only, that could mean that each time you scan things they intern to the same pointer...you could loop over <strong>rebDo("print", "{foo}", END)</strong> 10,000 times and yet only create 2 Rebol series backing the WORD! and the STRING!.</p>
<p>But no matter how many shortcuts like that you throw in, there's no getting around that loading and binding repeatedly will cost more than if you did it just once.</p>
<p>Yet I think one has to remember the context of our times--and the problem space for which Rebol is suited.  Compared to a network request to get a task done, how bad is running a few pieces of boilerplate through a scanner in raw C on the local machine?</p>
<p>And following the 80/20 rule, if you really find some hybrid string-and-splicing instruction is taking a lot of time, you can cache that.  Beyond manually constructing reusable blocks or functions "the hard way", the API might be able to help with something like a <a href="https://en.wikipedia.org/wiki/Prepared_statement" rel="nofollow noopener">prepared statement</a> in databases.</p>
<p>So there are plans of attack.  And if you're trying to extend Rebol with new native behavior, the "internal API" can be used instead when performance is at issue.</p>
<h3>If the "official" API scales back the number of entry points, what justifies a new one?</h3>
<p>One aspect I've spoken about is that making a new entry point under this scheme should offer an explicit convenience to the language user.  So if you're looking at something like:</p>
<pre><code>/* result = */ rebDo("spelling of", value, END);
/* result = */ rebSpellingOf(value, END);
</code></pre>
<p>There needs to be something more to it--for instance, the return result of the latter should be an ordinary string class in the language, not a Rebol value that needs further processing and lifetime management before a usable string can be extracted from it.</p>
<p>This is a fuzzy point, and it's a bit easier right now to suggest what shouldn't be an entry point (e.g. <strong>rebAppendPartOnly()</strong>) than what should.  So we'll have to see.</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/limiting-api-entry-points-in-favor-of-exchanging-strings/540">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/limiting-api-entry-points-in-favor-of-exchanging-strings/540</link>
          <pubDate>Wed, 21 Feb 2018 19:40:11 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-540</guid>
          <source url="https://forum.rebol.info/t/limiting-api-entry-points-in-favor-of-exchanging-strings/540.rss">Limiting API Entry Points in Favor of Exchanging Strings</source>
        </item>
        <item>
          <title>Taming Handle Tracking with a Uniform Variadic API</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Language Bridging</category>
          <description><![CDATA[
            <p>In the post about <a href="https://forum.rebol.info/t/lifetime-of-handles-given-back-to-c-code/343/3">lifetime of handles given back to C code</a>, I brought up the tough problem of <em>"who frees a floating <code>REBVAL*</code> that the system has entrusted an API user with?"</em></p>
<p>So every time you run a <strong><code>rebDo()</code></strong> you are getting back a pointer that the system has to count as a "live" reference... if it's a BLOCK!, there's no way to know a-priori how long the caller is going to be picking and poking values around in that block.</p>
<p>For now, all values get cells, and their lifetimes are managed.  That includes INTEGER!.  So let's take a simple example:</p>
<pre><code>int AddOneToSomething(int something) {
    REBVAL *somethingVal = rebInteger(something);
    REBVAL *sum = rebDo("1 +", somethingVal, END);
    int result = rebUnboxInteger(sum);
    rebRelease(somethingVal);
    rebRelease(sum);
    return result;
}
</code></pre>
<p>It's a pain to have to write so many rebRelease()s.  One of the answers is to have a default moment at which such things are GC'd automatically, and that's going to be possible sometimes--<em>but not always</em>, and it will mean leaving things alive longer than they would be freed up otherwise.  Another answer is to use C++, where <code>ren::Value</code> automatically knows when it's out of scope and can release things.</p>
<p>But a wilder cross-language answer came to mind, which applies to C, JavaScript, and anything else.  What if all APIs that could take a single REBVAL* to process it, might also be variadic?  We could see <code>rebUnboxInteger()</code> as being a variant of rebDo(), instead of simply taking one argument:</p>
<pre><code>int AddOneToSomething(int something) {
    REBVAL *somethingVal = rebInteger(something);
    int result = rebUnboxInteger("1 +", somethingVal, END);
    rebRelease(somethingVal);
    return result;
}
</code></pre>
<p>Now the rebDo() is folded into the rebUnboxInteger() call, and we've gotten rid of one userspace handle.  That's one handle that doesn't need to be allocated, tracked, or freed.  I've also proposed the idea of marking certain handles as releasable by the rebDo() mechanics once it sees them in the line of processing, like a rebT() instruction for marking things as "temporary":</p>
<pre><code>int AddOneToSomething(int something) {
    return rebUnboxInteger("1 +", rebT(rebInteger(something)), END);
}
</code></pre>
<p>We might even go so far as to say for something common like this, that <strong><code>rebI(...)</code></strong> could be a shorthand for rebT(rebInteger(...)):</p>
<pre><code>int AddOneToSomething(int something) {
    return rebUnboxInteger("1 +", rebI(something), END);
}
</code></pre>
<p>An interesting point is that this is made more palatable because things like WORD! and FUNCTION! are <a href="https://forum.rebol.info/t/should-word-path-function-be-live-by-default-in-rebdo/371">not "live" by default</a>.  You don't want to instead of saying <strong>rebSpellingOf(someWord)</strong>, rather <code>rebSpellingOf(rebUneval(someWord), END);</code> !</p>
<p><em>(I should also point out that having to have END is something that <a class="mention" href="/u/giuliolunati">@giuliolunati</a> has already avoided in JavaScript, and could be avoided in C++...or <a href="https://stackoverflow.com/a/2124433/211160" rel="nofollow noopener">even in C for C99 builds</a>.)</em></p>
<p>But it seems to me on average, you're looking at enough savings on the total amount of code that even if you have to put END on, it's a win.  If you don't need an END, it's seemingly kind of a slam-dunk win.</p>
<p>So basically any API that would perhaps otherwise have been seen as taking a plain REBVAL* would now take a variadic stream of string, value, and instruction components.</p>
<hr>
<p>Examples:</p>
<ul>
<li>
<p>instead of <code>rebUnboxLogic(REBVAL *logic_value)</code>...what about <code>rebDid(...)</code> and <code>rebNot(...)</code>?  e.g. <code>rebDid("all [", condition1, condition2, "]", END);</code> or <code>rebNot("error?", value, END);</code></p>
</li>
<li>
<p>instead of <code>rebRelease(rebDo(...))</code> what about <code>rebElide(...)</code>?</p>
</li>
</ul>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/taming-handle-tracking-with-a-uniform-variadic-api/535">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/taming-handle-tracking-with-a-uniform-variadic-api/535</link>
          <pubDate>Mon, 19 Feb 2018 01:32:03 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-535</guid>
          <source url="https://forum.rebol.info/t/taming-handle-tracking-with-a-uniform-variadic-api/535.rss">Taming Handle Tracking with a Uniform Variadic API</source>
        </item>
        <item>
          <title>Some questions about FFI (libuv)</title>
          <dc:creator><![CDATA[middayc]]></dc:creator>
          <category>Language Bridging</category>
          <description><![CDATA[
            <p>I have two questions. I'm trying to make a test binding to libuv ... I don't quite understand few things on the rebol and on c side.</p>
<ol>
<li>
<p>When c creates a struct and passes its address to a function that then sets its fields.</p>
<p>static struct sockaddr_in addr4;<br>
uv_ip4_addr(address_ip4, port, &amp;addr4);</p>
</li>
</ol>
<p>What should I do on FFI side to achieve the same? I tried to just allocate some memory (via malloc) and pass a pointer to that instead but it doesn't seem to work. I also tried to create hopefully correct struct! and pass addr-of to func but it doesn't seem to get set. In first case I can't know for sure, since I can't see what the address holds after the call, but the later c function that uses the addr behaves as if it weren't correctly set.</p>
<ol start="2">
<li>
<p>... I have a function that you give pointer to char and it sets the string to it. Is there a way to get to the containing c-string on that address from rebol side after it sets it?</p>
<p>int uv_ip4_name(const struct sockaddr_in* src, char* dst, size_t size)</p>
</li>
</ol>
            <p><small>6 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/some-questions-about-ffi-libuv/440">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/some-questions-about-ffi-libuv/440</link>
          <pubDate>Fri, 29 Dec 2017 21:58:02 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-440</guid>
          <source url="https://forum.rebol.info/t/some-questions-about-ffi-libuv/440.rss">Some questions about FFI (libuv)</source>
        </item>
  </channel>
</rss>
