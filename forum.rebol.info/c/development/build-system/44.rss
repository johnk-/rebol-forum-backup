<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Build System - AltRebol</title>
    <link>https://forum.rebol.info/c/development/build-system/44</link>
    <description>Topics in the &#39;Build System&#39; category Discuss rebol-make and other build systems.</description>
    
      <lastBuildDate>Sat, 02 Oct 2021 07:42:31 +0000</lastBuildDate>
      <atom:link href="https://forum.rebol.info/c/development/build-system/44.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>Android AAB?</title>
          <dc:creator><![CDATA[gchiu]]></dc:creator>
          <category>Build System</category>
          <description><![CDATA[
            <p>Android's APK is now being replaced with AAB.</p>
<aside class="onebox allowlistedgeneric">
  <header class="source">
      <img src="https://www.thurrott.com/wp-content/themes/theme/assets/media/logo-favicon-thurrott.png?v=@@version" class="site-icon" width="128" height="128">
      <a href="https://www.thurrott.com/dev/252614/google-is-replacing-android-apk-with-aab" target="_blank" rel="noopener" title="11:23AM - 30 June 2021">Thurrott.com – 30 Jun 21</a>
  </header>
  <article class="onebox-body">
    <div class="aspect-image" style="--aspect-ratio:690/388;"><img src="https://www.thurrott.com/wp-content/uploads/sites/2/2021/06/google-play-aab.jpg" class="thumbnail" width="690" height="388"></div>

<h3><a href="https://www.thurrott.com/dev/252614/google-is-replacing-android-apk-with-aab" target="_blank" rel="noopener">Google is Replacing Android APK with AAB - Thurrott.com</a></h3>

<p>And if you don’t know what that means, that’s OK, it probably just means that you’re not an Android developer.</p>


  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<p>Is anyone doing any work on this?<br>
And is there an AAB based on Ren-c that I can use to keep the RebolFoundation developer account alive?  Google wants proof we are alive.</p>
<p>Thanks,</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/android-aab/1731">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/android-aab/1731</link>
          <pubDate>Sat, 02 Oct 2021 07:42:31 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1731</guid>
          <source url="https://forum.rebol.info/t/android-aab/1731.rss">Android AAB?</source>
        </item>
        <item>
          <title>Ren-C Builds With 20 Year Old Compiler on Haiku!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Build System</category>
          <description><![CDATA[
            <p>I didn't realize bringing this up to date would take as long to tinker around with as it did (~ 8 hours), but...</p>
<p><div class="lightbox-wrapper"><a class="lightbox" href="https://forum.rebol.info/uploads/default/original/1X/1702f61a03d022ee405643e5defaa1521f3b7dd5.png" data-download-href="https://forum.rebol.info/uploads/default/1702f61a03d022ee405643e5defaa1521f3b7dd5" title="ren-c-haiku-2021"><img src="https://forum.rebol.info/uploads/default/optimized/1X/1702f61a03d022ee405643e5defaa1521f3b7dd5_2_610x500.png" alt="ren-c-haiku-2021" data-base62-sha1="3hzkeScW0sVzoA6Gja01IpM2cT3" width="610" height="500" srcset="https://forum.rebol.info/uploads/default/optimized/1X/1702f61a03d022ee405643e5defaa1521f3b7dd5_2_610x500.png, https://forum.rebol.info/uploads/default/optimized/1X/1702f61a03d022ee405643e5defaa1521f3b7dd5_2_915x750.png 1.5x, https://forum.rebol.info/uploads/default/optimized/1X/1702f61a03d022ee405643e5defaa1521f3b7dd5_2_1220x1000.png 2x" data-small-upload="https://forum.rebol.info/uploads/default/optimized/1X/1702f61a03d022ee405643e5defaa1521f3b7dd5_2_10x10.png"><div class="meta">
<svg class="fa d-icon d-icon-far-image svg-icon" aria-hidden="true"><use xlink:href="#far-image"></use></svg><span class="filename">ren-c-haiku-2021</span><span class="informations">1692×1386 184 KB</span><svg class="fa d-icon d-icon-discourse-expand svg-icon" aria-hidden="true"><use xlink:href="#discourse-expand"></use></svg>
</div></a></div><br>
<strong>Why was it such a pain?...</strong></p>
<h1>GCC 2.95.3 was Released <a href="https://gcc.gnu.org/releases.html">in March 2001</a>
</h1>
<p><strong>Don't let the 2017 build date fool you.</strong>  That's a 20-year old compiler, which we assume has the occasional Haiku patch here and there.</p>
<p>I knew the compiler that came with Haiku had been old.  But when I was making decisions about letting go of C89 support (in the core) I figured that Haiku would be bumping their versions to support C99 at some point...</p>
<p><em>Nope.</em></p>
<p>The reason Haiku is still so far back appears to be because they depend on GCC 2.95 features that enable them to get binary compatibility with old BeOS packages.</p>
<p>You can install a more modern GCC if you like--but then you're off in the concerns of having multiple toolchains on your system.  And presumably it's harder to link up against the HaikuOS C++ platform APIs.  So I thought it would be a good proof of our light dependencies to build on what's there.</p>
<h2>Note: Not Just Us, mbedTLS Dropped Their C89 Support</h2>
<p>Even the most die -hard of low-dependency systems have let go of the 80s.  In 2019, mbedTLS <a href="https://github.com/ARMmbed/mbedtls/issues/1484">ceased supporting C89</a>:</p>
<blockquote>
<p><em>"We've internally decided to drop support for C89 in the development branch. We've removed <code>-Wdeclaration-after-statement</code> to our build options in <code>CMakeLists.txt</code>. We run some builds with <code>gcc -std=c99 -pedantic</code> so we do test C99 compliance to a reasonable extent. Thus this issue is resolved."</em></p>
</blockquote>
<h2>Options Were Either Give Up, Or Revive the C++98 Build</h2>
<p>At one point Ren-C was able to build as C++98.  I stopped seeing the point of maintaining this option...as it was silly to be keeping track of which features I could use from C++11 in which permutations.  So it was either you build as C or you build as C++11 (or higher).</p>
<p>But there really is no other choice with this GCC 2.95.  The code is now styled:</p>
<pre><code>printf("Here's a statement\n");

const char *str = "Here's a declaration after a statement";
</code></pre>
<p>The Haiku C compilation mode requires all your definitions to be before the statements:</p>
<pre><code>const char *str; 

printf("Here's a statement\n");

str = "Here's a declaration after a statement";
</code></pre>
<p><em>(Note: I hate that, because it makes maintenance much harder.  But <a href="https://rdrr.io/cran/httpuv/f/src/libuv/CONTRIBUTING.md">libuv is actually a holdout here</a>...they're carrying the torch for C89 and committers still have to code in that style.)</em></p>
<p>In any case, C++98 was able to do that.  So I revived the setting.  It wasn't too hard...I just made it act like the C build <em>almost all of the time</em>.  Hence no use of inheritance in REBVAL or anything like that.  It deviates only when it has to for compiler semantics.</p>
<h2>Building mbedTLS Was Saved By A --pedantic Quirk</h2>
<p>While Ren-C was designed to compile as C or C++, mbedTLS is plain C.  C++ compilers will choke on some of the permissive treatment of <code>void*</code>.</p>
<p>I thought there'd be no way around this; because C++ compilers have no way to disable these errors.  <em>...or so I thought...</em>!</p>
<p>As it turns out, if you <em>raise</em> the error reporting level with "pedantic" warnings, the warning machinery notices the problems before the error!  And you can ignore warnings!</p>
<p>So oddly enough, I actually could compile the encryption code on Haiku (without having to go in and edit it).</p>
<h2>Small Rewrites Needed To Dodge Compiler Bugs</h2>
<p>Minor changes were required to code that was triggering GCC 2.95 bugs that prevented the build.  I wouldn't be happy if I had to make a dozen changes for it, but it was a few.</p>
<p>I guess even if you write code that is correct, if you notice it triggering a compiler bug that may be a sign that it involves something hard for compilers to get right.  One might be able to balance the annoyance of having to make the change with the potential that maybe fewer compilers would be getting that bit wrong.</p>
<h2>Networking Doesn't Work, But After LibUV Switch, It Might!</h2>
<p>I built the entirety of LibUV into the executable (even though I didn't technically have to).  And the filesystem code--which is now on libuv--seems to be working.</p>
<p>The networking isn't on libuv yet, and isn't seeming to work.  But maybe once it switches over, it will.  I mentioned that Haiku was one of the explicitly supported platforms of libuv.  So if all goes smoothly in that conversion, I imagine this will work!</p>
<h2>No Action Item Here, Just Proving It Could Be Done</h2>
<p>This was a good head-check of what exactly has changed as Ren-C has refactored and evolved.  Letting certain dependencies creep in can make your source less adaptable and agile...and this helps be assured that things are still on track.</p>
<p>What's important here isn't "oh, now we can have millions of HaikuOS users".  Rather it serves as another example of managed dependency control--to lend confidence to the idea that porting to other new ones should be easy enough.</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/ren-c-builds-with-20-year-old-compiler-on-haiku/1710">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/ren-c-builds-with-20-year-old-compiler-on-haiku/1710</link>
          <pubDate>Fri, 10 Sep 2021 17:28:40 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1710</guid>
          <source url="https://forum.rebol.info/t/ren-c-builds-with-20-year-old-compiler-on-haiku/1710.rss">Ren-C Builds With 20 Year Old Compiler on Haiku!</source>
        </item>
        <item>
          <title>Siskin-Builder (Rebol-based build tool by Oldes)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Build System</category>
          <description><![CDATA[
            <p>Oldes apparently has undertaken the task of making a <a href="https://github.com/Siskin-framework/Builder">build dialect/tool for his branch of Rebol3</a>.  This animated GIF makes it seem pretty slick looking in the console:</p>
<p>                    <a href="https://raw.githubusercontent.com/Oldes/media/master/screens/build-siskin.gif" target="_blank" rel="noopener" class="onebox">
            <img src="https://raw.githubusercontent.com/Oldes/media/master/screens/build-siskin.gif" width="690" height="457">
          </a>

</p>
<p>The makefiles are called ".nest" files, and here's the one in his R3 repository:</p>
<p><strong><a href="https://github.com/Oldes/Rebol3/blob/master/make/rebol3.nest" class="inline-onebox">Rebol3/rebol3.nest at master · Oldes/Rebol3 · GitHub</a></strong></p>
<h2>New Ideas?</h2>
<p>Looking past the nice colors and presentation, I don't know if any "big new ideas" jump out at me in terms of a dialect.</p>
<p><strong>Preprocessor Usage</strong></p>
<p>The primary thing that does jump out at me is use of a preprocessor.  He has branches for <strong><span class="hashtag">#if</span> Windows [...]</strong> that let you ask for transformations and selections in the middle of lists that are data.  Less cluttered than going through and COMPOSE-ing everything, and lets you stay in the declarative domain.</p>
<p>Seems he's using a generic preprocessing script--not one that's specific to just this tool--and that's probably a good idea.  Though now that <strong><span class="hashtag">#a</span></strong> is used for characters this gets a bit stickier... even if you were previously willing to sacrifice ISSUE! in your file so you could do preprocessing, you now would be sacrificing your notation for characters too.</p>
<p><em>(I should point out that with generic quoting, you do have <strong><code>'#a</code></strong>, so at least in evaluative circumstances you'd have a way to escape out of the preprocessor.  It might be that if you use a preprocessor on the file, all your #... that you don't want to represent preprocessing instructions are just quoted out?)</em></p>
<p><strong>Requiring the % on File Paths</strong></p>
<p>He does use <strong>%file/path.c</strong> instead of <strong>file/path.c</strong> -- and that's a case where I've pointed out that Carl chose to use the lighter notation without the %.</p>
<p>I think that designing a dialect that is heavily dealing with paths as data, that if you can dodge the % then it makes it nicer to look at and edit.  If you want to allow for evaluations, you would use GROUP!s or <span class="mention">@vars</span> or something else.</p>
<h2>Our Nightmare Build System Is Still Upping My Game</h2>
<p>Oldes's makefile here, and one that Giulio made...as well as Carl's original, are all a far cry from the mind-bending behemoth that is Rebmake.</p>
<p>Not only is Rebmake a beast, we have a bootstrap compatibility layer for morphing a several year old interpreter into a common subset to run it.  It's a mind-bending challenge...the details of which I generally spare you from.  <img src="https://forum.rebol.info/images/emoji/twitter/exploding_head.png?v=9" title=":exploding_head:" class="emoji" alt=":exploding_head:"></p>
<p>It's nice to be reminded that we can do a lot smaller than that.  But oddly enough, the challenges of working with Rebmake and the %bootstrap-shim have been forcing more and more inventions in how to make the bendiest language ever.</p>
<p>And Rebmake isn't overtly unreasonable; its the kind of approach that someone who's thinking in OOP terms would think if they were trying to clone CMake's object model in a 1:1 fashion.  So it has been the mother of invention for complexity-taming tools...and stressing the language in areas that someone with a pure Rebol mindset wouldn't think to stress it in.</p>
<p>Which may explain why I'm not as urgently trying to jettison Rebmake or run on a modern Ren-C as one might think.  Because forcing a new Ren-C to be able to meet an old one in the middle to run a crazy codebase is hardening the system.</p>
<p>But... definitely, yes, someday we're going to pitch the thing and get something lighter.</p>
<p><img src="https://forum.rebol.info/images/emoji/twitter/recycle.png?v=9" title=":recycle:" class="emoji only-emoji" alt=":recycle:"></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/siskin-builder-rebol-based-build-tool-by-oldes/1672">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/siskin-builder-rebol-based-build-tool-by-oldes/1672</link>
          <pubDate>Thu, 19 Aug 2021 06:56:38 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1672</guid>
          <source url="https://forum.rebol.info/t/siskin-builder-rebol-based-build-tool-by-oldes/1672.rss">Siskin-Builder (Rebol-based build tool by Oldes)</source>
        </item>
        <item>
          <title>The New Ren-C GitHub Action: Run Natively, Run on Web!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Build System</category>
          <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1547">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>A GitHub Action can make including the feature as easy as one line for users. And we have the advantage of being able to make single-exe tools that could install on all the container types. <em>(All of them are 64-bit. Sorry, Red...)</em></p>
</blockquote>
</aside>
<p>So I went through the pain and suffering of learning how to do this.</p>
<p><em>It's a small thing in some sense, but very high leverage!</em></p>
<p><strong><a href="https://github.com/metaeducation/ren-c-action">A First Draft of a Quite Useful Ren-C Action</a></strong></p>
<ul>
<li>
<p><strong>It auto-detects your platform (Windows, Linux, MacOS) and downloads an R3 Executable for that platform</strong></p>
</li>
<li>
<p><strong>It uses GitHub Actions caching to remember where it installed itself, so multiple steps can use the executable without doing multiple downloads</strong></p>
</li>
<li>
<p><strong>It adds the r3 executable to your path, so you can use it from bash as well as with inline script code</strong></p>
</li>
<li>
<p>...and as a bonus feature... <strong>It can run script code in the web build via browser automation, so you can use it to test scripts intended to be run on the web as well</strong>.</p>
</li>
</ul>
<p>You can see <a href="https://github.com/metaeducation/ren-c/commit/f6b3411abf367be47d05e5ce58ea2de117255cc5">how much nicer the web build test</a> got by using it.  The Python code that lived in the ReplPad tests directory as well as the shell code for the web build are now both moved into the <code>ren-c-action</code>, and it's generalized. This should make it easy to add the action to a repository that is something like <a class="mention" href="/u/gchiu">@gchiu</a>'s NZPower.</p>
<p>There are <a href="https://github.com/metaeducation/ren-c-action/tree/main/src">a bunch of comments in the source</a> so you should be able to get the idea.  There's a few sticks and glue holding it together, but I think the basic approach is sound.</p>
<p>The main problem it has right now is that we don't have the latest builds getting uploaded.  So the next step for this to be useful will be to restore the uploading for OS X / Linux / Win32 builds.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/the-new-ren-c-github-action-run-natively-run-on-web/1562">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-new-ren-c-github-action-run-natively-run-on-web/1562</link>
          <pubDate>Tue, 16 Mar 2021 06:52:21 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1562</guid>
          <source url="https://forum.rebol.info/t/the-new-ren-c-github-action-run-natively-run-on-web/1562.rss">The New Ren-C GitHub Action: Run Natively, Run on Web!</source>
        </item>
        <item>
          <title>Over 20 Years of C99: Making a Concession</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Build System</category>
          <description><![CDATA[
            <p>In the interest of bragging rights, we've tried to say that Ren-C builds on C89.</p>
<p>Not quite true, since we use <strong><code>//</code></strong> comments instead of just <strong><code>/* */</code></strong> comments.  But a lot of compilers before C99 supported that, and you could just strip them out.</p>
<p>Also not quite true because we don't declare all locals at the top of blocks in a function.  But a lot of compilers before C99 supported that, and if not you could write a preprocessor to do it.</p>
<p>But a big feature that would helps if we permitted using it is C99 variadic macros.  It means we can automatically add terminator signals to API calls:</p>
<p>So instead of writing things like:</p>
<pre><code>if (rebNot("action?", rebQ(main_startup), rebEND))
    rebJumps("panic-value", rebQ(main_startup), rebEND);
</code></pre>
<p>We can say:</p>
<pre><code>if (rebNot("action?", rebQ(main_startup)))
    rebJumps("panic-value", rebQ(main_startup));
</code></pre>
<p>Right now we support both modes, but hold off on using the nicer mode in the internal implementation.</p>
<p>The C++ build checks to make sure that the rebENDs are there if you mark a file as "C89-compatible" and that it should have them.  So that makes it easier to not forget them if you meant them to be there.  But they're still an eyesore.</p>
<h2>I Think It's Time to Adjust The Rule</h2>
<p>The original idea was that "public-facing" code would all use the nice mode, but we would bear the burden of rebEND in the internal code for the sake of making it compile on older systems.</p>
<p>However, the code for the interpreter itself is supposed to be a showcase of its features.  If you are looking at the startup sequence in <code>main.c</code> and are hit with these rebEND-based API calls, that's will prevent appreciating it fully.</p>
<p><strong>We should preserve the ability to call these APIs from C89.</strong>   e.g. you should be able to include libRebol from a C89 compiler.  That API file should have a mode you can use to include it in a C89 program, where you have to provide the rebENDs explicitly.</p>
<p><strong>But the internal implementation should allow the usage of the macro form.</strong>  Not leveraging it makes reading the code for Ren-C itself not as pleasing as it should be.  I want the code for stepping through the boot process and extensions to make the best impression.  And rebEND detracts from an otherwise profoundly distinct experience.</p>
<p>The answer for people who want to build the sources on a very old compiler would be the same answer as for those who want to build it on a system that doesn't have <code>//</code>-comments...run the source through a preprocessor.  Expand the rebXXX() macros to make a new version of the source, <em>and then compile that</em>.</p>
<p>Seems fair.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/over-20-years-of-c99-making-a-concession/1554">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/over-20-years-of-c99-making-a-concession/1554</link>
          <pubDate>Fri, 12 Mar 2021 01:40:31 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1554</guid>
          <source url="https://forum.rebol.info/t/over-20-years-of-c99-making-a-concession/1554.rss">Over 20 Years of C99: Making a Concession</source>
        </item>
        <item>
          <title>Using Ren-C As The Shell In GitHub CI</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Build System</category>
          <description><![CDATA[
            <p><em>(Check this out, <a class="mention" href="/u/giuliolunati">@giuliolunati</a> ...!)</em></p>
<p>There's a feature in GitHub CI which lets you override the shell used in a workflow.  You can do it for the whole workflow, or even on a step-by-step basis.</p>
<p>This got me to wondering what it would be like to use Ren-C as the shell for a step.  It took a little tinkering, but I got it to work!</p>
<p>Here it is using an executable for Windows (that it just built) to test HTTPS reads:</p>
<pre><code>- name: HTTPS Read Test
  shell: r3 --fragment {0}
  run: |
    print {== Hello From R3 HTTPS Read Test! ==}
    parse as text! read https://example.com [
        thru &lt;h1&gt; copy header: to &lt;/h1&gt; to end
    ] else [
        fail "Couldn't Capture Page Title"
    ]
    assert [header = "Example Domain"]
    print ["Succeeded:" header]
</code></pre>
<p><strong><a href="https://github.com/metaeducation/ren-c/runs/2066230493?check_suite_focus=true#step:16:40">And it works!!</a></strong></p>
<p>What GitHub is doing is it's taking the body of what's in the <strong><code>run</code></strong> section and writing it to a temporary file with a random name off in some weird directory.  Then it substitutes that weird name in for the <code>{0}</code> in the shell expression.</p>
<h2>The New <code>--fragment</code> Option</h2>
<p>There were a lot of details on the path to getting that working.  But I'll just focus here on the new feature of saying that a script is a "fragment".</p>
<ul>
<li>
<p><strong>We Don't Want To Change Into the Temporary Directory The Fragment Lives In</strong>.  Rebol has historically switched to the directory a script lives in, and on balance I think that's the right default.  It helps the script find its own resources, where it has the most likely ability to neatly refer to files by short paths.  But this is a lone file...there's nothing to gain by doing that, and it's a disruption.</p>
</li>
<li>
<p><strong>I Don't Think It Should Need A Header, Either</strong>.  It would be a competitive disadvantage in this scenario--compared to other shells--if you had to put a dummy header in there.  By using a special name and a setting for "fragment" we have a way on the command line of saying "hey, this has no header, and I meant that".</p>
</li>
<li>
<p><strong>GitHub CI Threw In CR LF, we need an excuse to tolerate it</strong>.  Even though the YAML for the original code had just LF, the temp file for the run lines got CRs added.  I'm still pretty bullish on saying we need to consider this just like a syntax error or any other illegal sequence of characters.  If a strong stance isn't taken, then it screws everyone forever.  But here the compromise is that you have declared this isn't the kind of file you'd be sharing...not a "full script"...so it makes it a bit more okay to strip the CR LF silently (On Windows only, though!)</p>
</li>
</ul>
<h2>
<img src="https://forum.rebol.info/images/emoji/twitter/bulb.png?v=9" title=":bulb:" class="emoji" alt=":bulb:"> GitHub Action Dialects Might Have A Lot Of Potential <img src="https://forum.rebol.info/images/emoji/twitter/bulb.png?v=9" title=":bulb:" class="emoji" alt=":bulb:">
</h2>
<p>Not everyone has figured out that this is possible, yet.  But I found <a href="https://discourse.julialang.org/t/tip-use-julia-as-custom-shell-in-github-actions/53377">a post on the Julia forum</a> while I was doing it, showing that a few people are catching on to the idea.</p>
<p>But what we can do in customization could potentially go quite a lot farther than "Bash control structures but in a language you are more familiar with".  What the code does can be creatively tailored to the domain being solved.</p>
<p>A GitHub Action can make including the feature as easy as one line for users.  And we have the advantage of being able to make single-exe tools that could install on all the container types.  <em>(All of them are 64-bit.  Sorry, Red...)</em></p>
<p>Could be interesting.  We'll see!</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/using-ren-c-as-the-shell-in-github-ci/1547">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/using-ren-c-as-the-shell-in-github-ci/1547</link>
          <pubDate>Tue, 09 Mar 2021 12:37:07 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1547</guid>
          <source url="https://forum.rebol.info/t/using-ren-c-as-the-shell-in-github-ci/1547.rss">Using Ren-C As The Shell In GitHub CI</source>
        </item>
        <item>
          <title>Android&#39;s Back! Modernized, and With Continuous Integration</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Build System</category>
          <description><![CDATA[
            <p>Since I was on a roll with the TCC Bootstrap and the Windows Builds on GitHub Actions, I decided to take a crack at bringing the Android builds back.</p>
<p>It would be underwhelming if I didn't bring things somewhat up-to-date in the process.  Android NDK versions are numbered by [r]evisions, and we had been on "r13" from October 2016.  Five years ago is basically eternity in cell phone time...and the revisions have counted up steadily since then, currently at "r21" (!)</p>
<p>So I dug in and suffered for another long continuous day-and-night to make it happen.</p>
<p><strong><a href="https://github.com/metaeducation/ren-c/runs/2050208508?check_suite_focus=true">And They're Back!!!</a></strong></p>
<h2>Big Change: Toolchain Switch to Clang</h2>
<p>The Android toolset was originally based on GCC.  But they wound up switching to Clang...starting by making it available in revision r16, and then removing the GCC support altogether in r18.</p>
<p>This may seem like a minor change for us (and it probably would have been easier if I knew more about the NDK to start with).  But cross compilation is never "simple", and Android is a particularly crazy combinatoric monster.  When the .zipped file for installing the SDK is 500MB--with executables for only <em>one</em> of the cross-compiling platforms--you can bet there's a lot in there to trip up.</p>
<p>I'll spare you the details, but you can read <strong><a href="https://github.com/metaeducation/ren-c/blob/master/configs/android-common.r">config/android-common.r</a></strong> if you want to see comments I wrote to document the process.</p>
<h2>Still Supporting The Older NDKs!</h2>
<p>The Google Play store will only accept apps that are built with very recent API Levels!</p>
<p>But I think it's interesting to be in the position that we can still build against older NDKs, perhaps for older hardware.  It's a distinguishing feature.</p>
<p>Anyway, I made the script detect the version and react accordingly.  Maybe there will be a time when it's not worth it to support the older NDKs, but for now it doesn't cost much...and it helps keep a check on making sure that if we use any "newfangled" APIs that only exist on certain modern devices, we do so consciously.</p>
<h2>Next Steps... CI Testing!</h2>
<p>So I said that I wanted anything we thought was important to be rigged up with automated testing.  I did some research into Android emulators that could run "headlessly" with no screen...let you install apps on a virtual phone, and run tests.  Such things do exist, and we could run them on GitHub Actions!</p>
<aside class="onebox githubfolder">
  <header class="source">
      <img src="https://github.githubassets.com/favicons/favicon.svg" class="site-icon" width="32" height="32">
      <a href="https://github.com/marketplace/actions/android-emulator-runner" target="_blank" rel="noopener">github.com</a>
  </header>
  <article class="onebox-body">
    <div class="aspect-image" style="--aspect-ratio:400/400;"><img src="https://avatars.githubusercontent.com/u/51352484?s=400&amp;amp;v=4" class="thumbnail" width="400" height="400"></div>

<h3><a href="https://github.com/marketplace/actions/android-emulator-runner" target="_blank" rel="noopener">Android Emulator Runner - GitHub Marketplace</a></h3>


  <p><span class="label1">Installs, configures and starts an Android Emulator directly on macOS virtual machines</span></p>

  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<p>They say it only runs on Mac hosts.  So that incentivizes hammering on the cross-compile script until it's able to use platforms other than Linux to build for Android.  It may not actually be all that hard to do (will have to find out...)  Of course we could build on Linux and then just send that product to a mac to run the emulator.</p>
<p>Getting that ability to run a simulator that can test the built Android executable is a priority.</p>
<h2>Revive Building the APK</h2>
<p>So we definitely want to have the process from <strong><a href="https://www.youtube.com/watch?v=r5kccBehMMg">@giuliolunati's conference demo</a></strong> be automated and tested.  That means building the .APK file which bundles together both the native interpreter (as a backdoor to phone services) along with a WASM interpreter (to live in a webpage and be able to communicate with the native interpreter).</p>
<p>Maybe Giulio can speak to how far we are from having that work again... or if he's busy, I guess I can just go through the video... that's what it's for!  <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
<h2>Bring Back TCC Extension</h2>
<p>I <a href="https://forum.rebol.info/t/doubling-down-on-tcc-bootstrap-conference-demo-expanded/1542">resurrected the TCC bootstrapping</a> because I think it is an impressive demo, and it speaks to an important spiritual point about the project.</p>
<p>It's pretty easy to get the ball rolling for TCC on Linux.  But a bit more work when you're cross-compiling it, or making it for Windows.</p>
<p>I never tried it, but it seemed like we had TCC working on Android.  It would probably be worth doing it again, and interesting if we could see the TCC bootstrap demo work on a phone too (!)  We'll have to consult the old Travis build script to see how the ARM configuration was done.</p>
<h2>Revisiting This Gives Me More Motivation</h2>
<p>Slogging through the nightmare of the Android NDK reminds me that <em>we are really doing something that almost no one does anymore</em>.  They just sign away their lives to something like Android Studio and are so far away from the actual mechanical levels that they don't know what the dependencies are.  Most people probably wouldn't know <em>how</em> to do any different...and among those who know, it's simply too frustrating to work through the details.</p>
<p>When you add up all the platforms and parts that we have, this is probably a more compelling story than I give it credit for.  So we should definitely not take for granted what we've got...and get the great demos like the AndroidNative+WASM packaging back up and running!</p>
<p><img src="https://forum.rebol.info/images/emoji/twitter/rocket.png?v=9" title=":rocket:" class="emoji only-emoji" alt=":rocket:"></p>
            <p><small>5 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/androids-back-modernized-and-with-continuous-integration/1544">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/androids-back-modernized-and-with-continuous-integration/1544</link>
          <pubDate>Sun, 07 Mar 2021 12:17:53 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1544</guid>
          <source url="https://forum.rebol.info/t/androids-back-modernized-and-with-continuous-integration/1544.rss">Android&#39;s Back! Modernized, and With Continuous Integration</source>
        </item>
        <item>
          <title>New Build Executables, New Build Strategy</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Build System</category>
          <description><![CDATA[
            <p>I mention that it's time to make a new batch of build executables.  I think it can no longer be avoided that we need a simplified build process, and having new and recent executables provides a big bag of tricks for writing a new one.  But first, let's just review a little history.</p>
<p>The story of the build system goes like this:</p>
<h2>R3-Alpha</h2>
<p><strong>R3-Alpha's build was driven by a slightly templated GNU makefile.</strong>  You can see the text of the makefile template in <strong><a href="https://github.com/rebol/rebol/blob/master/src/tools/make-make.r"><code>%make-make.r</code></a></strong>, which you would run with what OS_ID system you wanted to build for.  It pulled together a list of files from <strong><a href="https://github.com/rebol/rebol/blob/master/src/tools/file-base.r"><code>%file-base.r</code></a></strong> and made you a <strong><code>makefile</code></strong>.</p>
<p>It's a simple approach.  It means you have to have GNU make on your platform, which meant it wasn't a workable way to build on Windows.   The README said:</p>
<blockquote>
<p>This first release is intended for non-Windows systems like Linux, Mac, BSD,<br>
Android, etc. However, it will build for Windows, but I've not included the<br>
typical MSVC project files. I'll try to get that added, but it's not that<br>
tough to create one yourself.</p>
</blockquote>
<p><strong>One of the steps run by the makefile was called "prep".</strong>  This ran Rebol script code that generated a bunch of files to support the build.  Responsibilities of this step were:</p>
<ul>
<li>
<p>Pack up all the mezzanine Rebol text sources--with comments removed--into a compressed blob of data in a <code>.c</code> file.  The C array of bytes in that file was effectively an embedded resource, used to bootstrap the system.</p>
</li>
<li>
<p>Look through the C sources of the interpreter and find function definitions.  Then automatically generate an aggregate<code> .h</code> header file with those definitions.  This keeps you from having to update function prototypes in more than one place.  One downside of having everything automatically glommed into one big header is that the architectural lines between files aren't as clear as they would be if the headers were more granular...but overall I'd say it works out as an advantage.</p>
</li>
<li>
<p>Take some Rebol-structured memoizations and transform them into C code.  Plenty of projects have similar steps to convert tabular data in whatever format into <code>.h</code> and <code>.c</code>.  Rebol is a better medium for representing freeform intent than what most people use.</p>
</li>
</ul>
<p>The "prep step" has evolved over time, but all of the "make" processes run it in the same way.  So what we're talking about changing here is really just about how the invocation of the compiler and linker is done.</p>
<h2>Atronix R3</h2>
<p>Atronix builds against a lot of dependencies, and thus uses CMake.  CMake is a beast with a kind of archaic syntax.  But if you have a complex cross-platform C or C++ project...you don't really have much in the way of better options.  It has widely supported plugins for making sure your system pulls together the prerequisites it needs.</p>
<p>They used CMakeLists.txt files...written and maintained by hand.  No generation process, and they did not use the makefile.</p>
<h2>Earl's %build.reb Demo</h2>
<p>The concept of using Rebol to build itself came up, by using CALL to invoke the compiler.  earl made a quick and dirty example of this, called <strong><a href="https://gist.github.com/earl/180d761ce5d27e411a6f">%build.reb</a></strong>.  It showed a promising and brief idea.</p>
<p>A disadvantage it had was that it could only do full builds. GNU make and CMake senses which files change.  Doing full builds on every change is not viable for day to day operation.</p>
<p>Another disadvantage is that this couldn't be used to bootstrap onto a new platform.  You can't have the only way an executable can be made be if you have one already.</p>
<p>But this was a promising idea...and being able to build without needing GNU make, especially on Windows, was an idea that stuck.</p>
<h2>Rebmake</h2>
<p>Shixin didn't care for maintaining the handwritten CMakeLists.txt in parallel to changes with the <code>%make-make.r</code> process.  So he wanted a unified build.</p>
<p>But rather than thinking of the build as abstracting a <code>makefile</code> as R3-Alpha was doing, he thought of it as abstracting a CMake file...which is much more complex.  He wanted something that was "meta" enough that it could build to a <code>CMakeLists.txt</code>, a GNU <code>makefile</code>, a Visual Studio <code>.app</code> file, a command-line MSVC <code>nmake</code> file... or just drive the process through CALL as %build.reb had done.</p>
<p>The result of this ambitious process was the generalized engine of <strong><a href="https://github.com/metaeducation/ren-c/blob/9dc8ca2786ff57f9e4fc579e7a14623b014e4ce2/tools/rebmake.r"><code>%rebmake.r</code></a></strong>.  But that was a generic framework which then needed to be customized specifically to build a project...giving rise to the client script using the library <strong><a href="https://github.com/metaeducation/ren-c/blob/master/make.r"><code>%make.r</code></a></strong> (the names are arguably backwards... that make.r would be the framework, and rebmake.r would be the script for building Rebol).</p>
<p>Additionally, rebmake tried to accommodate two important new features:</p>
<ul>
<li>
<p>Per-OS or build type configuration files (<strong><a href="https://github.com/metaeducation/ren-c/tree/master/configs"><code>%configs/</code></a></strong>) to help with common builds</p>
</li>
<li>
<p>Having make specifications in the folders of extensions, so that their build recipes could be broken out from the main file.  Here's for instance today's Crypt module's <a href="https://github.com/metaeducation/ren-c/blob/9dc8ca2786ff57f9e4fc579e7a14623b014e4ce2/extensions/crypt/make-spec.r"><strong><code>extensions/crypt/%make-spec.r</code></strong></a></p>
</li>
</ul>
<p>To most observers (including myself), Rebmake is way too big.  It makes sense if you think the goal is to generate CMake files or Visual Studio files.  But what you wind up with in this line of thinking is kind the direct opposite of Rebol's goals: <em>instead of making a thing that is significantly less complicated than those systems, you have something that inherits all their complexity and then layers on more</em>.</p>
<h2>Giulio's makefile.reb experiment</h2>
<p>We pretty much all agree Rebmake has to go, but build systems are just naturally difficult...and not a lot of fun.</p>
<p><a class="mention" href="/u/giuliolunati">@giuliolunati</a> recently took a stab at seeing what kind of a minimal direction might be taken, and generated a <strong><a href="https://github.com/metaeducation/ren-c/blob/5e56c3b946807f70fcfe6c1c190b6aa49c5b0cd7/makefile.reb">%makefile.reb</a></strong> that steered back closer to the ideas of R3-Alpha.  But there's a complicated set of requirements in this problem, so it's easy to see it stalled.</p>
<p>His file is a good reminder of the kind of scale we're looking for the build solution to be on.  To think smaller and simpler, and cut things back.</p>
<h2>Pulling Together A New Design</h2>
<p>So taking all this experience into account, I'm ready to take a stab at starting anew.  I want to back off from thinking of this as building a generic make system you'd use for other C projects...I think that's a bad idea.</p>
<p>Here's my rough strategy:</p>
<ul>
<li>
<p><strong>Make the main build system we use day-to-day driven by Ren-C using CALL.</strong>  That means it needs to check object file time stamps vs. the source files, and be incremental.</p>
</li>
<li>
<p><strong>Forget about makefiles or Visual Studio projects or otherwise.</strong>  For bootstrap, just have a way that the list of command lines which would be run by CALL can be output to a <code>.bat</code> or <code>.sh</code> file.  A full build is good enough...then once you're bootstrapped, use the executable from then on.</p>
</li>
<li>
<p><strong>Use a circa 2021 Ren-C to do the builds, unlocking more superpower in the make script design.</strong>  Hopefully <a class="mention" href="/u/rgchris">@rgchris</a> and I can <a href="https://forum.rebol.info/t/the-r3c-branch-chriss-rebol-or-rebol-3-conservative/1284/4">coordinate that this is "R3C"</a>...with a maintenance contract and quality control.  That's something that the haphazard build-picking process hasn't done before in the history of Rebol, and would in itself be refreshing.</p>
</li>
<li>
<p><strong>Make Building as a C library the Main Mission</strong>.  Strangely enough, the web build has been made available as a library with no included "main()" before offering a similar static library for C.  That's kind of silly.  If a C library were enabled, we could break out the console into its own repository...or put together things like demo projects on GitHub that offered desktop GUIs.  This was the original concept and it just never happened.  If not now, when?</p>
</li>
<li>
<p><strong>Revive Granular Extensions, in Particular Wasm Side-Modules ("the DLLs of Wasm")</strong>.  There was a nice concept in Rebmake that extensions could be not built (<code>-</code>), included statically in the executable (<code>+</code>), or made as a DLL/shared-library (<code>*</code>).  The DLL option did not really get tested and hasn't worked for a while.  It needs to...and with the primacy of the web build, we have to get that working for loading extensions as little Wasm fragments.  We also need to make it easier for extensions to live in their own git projects, vs. in the interpreter master git.</p>
</li>
<li>
<p><strong>Try building using the TCC extension in a web browser.</strong> This isn't necessarily as far fetched as it sounds.  Ren-C running in wasm in the browser could pull a .ZIP of the sources, let you click some customizations, and using the person's own CPU power in the browser build an x86 executable that you could then download.  It's really just a recycling of <a href="https://youtu.be/PT3GOe1pj9I?t=182">the conference demo</a>.</p>
</li>
</ul>
<p>As usual, this is all daunting stuff, but with some focus it may be realistically doable.  There's a lot of experience here to draw from...at least to know what NOT to do...!</p>
            <p><small>4 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/new-build-executables-new-build-strategy/1432">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/new-build-executables-new-build-strategy/1432</link>
          <pubDate>Sat, 12 Dec 2020 12:11:42 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1432</guid>
          <source url="https://forum.rebol.info/t/new-build-executables-new-build-strategy/1432.rss">New Build Executables, New Build Strategy</source>
        </item>
        <item>
          <title>How to set a compile variable?</title>
          <dc:creator><![CDATA[iArnold]]></dc:creator>
          <category>Build System</category>
          <description><![CDATA[
            <p>I want to set a variable so I can compile C code depending on if this variable is defined or not.</p>
            <p><small>8 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/how-to-set-a-compile-variable/1366">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/how-to-set-a-compile-variable/1366</link>
          <pubDate>Wed, 14 Oct 2020 20:34:34 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1366</guid>
          <source url="https://forum.rebol.info/t/how-to-set-a-compile-variable/1366.rss">How to set a compile variable?</source>
        </item>
        <item>
          <title>A Separate and Simpler C89 Build</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Build System</category>
          <description><![CDATA[
            <p>Now and again the idea comes up to switch to take C99 features for granted, given that standard is now... over 20 years old.</p>
<p><strong>The principal benefit of stepping up from C89 to C99 is in libRebol, so that it automatically terminates the variadic APIs.  It is a <em>SIGNIFICANT</em> benefit!</strong></p>
<p>As libRebol usage is on the rise, I'm finding my productivity adversely affected by the usability factors of not having termination be implicit.  It's easy to make mistakes, kind of like messing up a printf()'s arguments...but a worse version of that, because of how nested libRebol expressions often are.</p>
<p>But even more importantly: <em>I don't think the <em>truly innovative</em> aspects of the API show off as well when they are contaminated with the rebEND "tics" and other workarounds.</em>  That makes me sad.  <img src="https://forum.rebol.info/images/emoji/twitter/crying_cat_face.png?v=9" title=":crying_cat_face:" class="emoji" alt=":crying_cat_face:"></p>
<h2>Is it Time for a Compromise?</h2>
<p>As the system has become more granular with ~30 extensions, it gets easier to pick some of those as "C99 and above only".  For instance: what C89-only system can run ZeroMQ...which presumably can't be built for such a system in the first place?</p>
<p>But some extensions are mandatory to get a baseline usable system.  You can't do much without file I/O.  So if a system supports C89 and POSIX it seems disingenuous to say "There's no FILESYSTEM extension, but you can still compile the core..."</p>
<p>Right now I'm dealing with the suboptimal situation of expressing the C portion of the "rich console" in C89.  And it makes me wonder:</p>
<p><strong>Could we say that C89 platforms <em>work</em>, but just don't have a rich console?</strong>  e.g. they would read one line at a time with scanf(), run it, and print the result out with printf().</p>
<p>Hence in a C89 build, you would un-include the "modern" CONSOLE extension and use the CONSOLE-C89 extension, or somesuch.  This would have the advantage of keeping us from making the modern codebase look like it's contaminated with archaic concerns.  We don't at this point have any platforms or clients that are "real" that only have C89...and I gather if we did, people would be happy to have scripts run on them at all.</p>
<p><strong>In the near term, the odds are we're only going to be seeing these C89 build modes on Travis or wherever we force the issue... as a matter of principle.</strong>  We could also say "to heck with it, don't waste the time up front...let someone else do it if and when it comes up".  But I think I'd rather keep it going.</p>
<p>I just want us to be putting our best face forward with the code most people see and hack on. And it's pretty clear that C89 isn't giving us that (due to fundamentally missing the feature of variadic macros).</p>
<p><em>(FWIW, pre-C99 compilers did often support variadic macros... but with a gnarly non-standard syntax that only worked in their compiler.  So it's not unlikely that someone could hack in a way to make libRebol work on their older compilers without rebEND, if they were motivated...or just do a little custom preprocessing step of their own.)</em></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/a-separate-and-simpler-c89-build/1268">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/a-separate-and-simpler-c89-build/1268</link>
          <pubDate>Thu, 05 Mar 2020 22:09:51 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1268</guid>
          <source url="https://forum.rebol.info/t/a-separate-and-simpler-c89-build/1268.rss">A Separate and Simpler C89 Build</source>
        </item>
        <item>
          <title>command line options as `target: makefile` vs `target=makefile`</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Build System</category>
          <description><![CDATA[
            <p>It is traditional for programs that take command-line options in one of the following ways:</p>
<pre><code>my-program optionname=option
my-program --optionname option
my-program --optionname=option
my-program /optionname option
</code></pre>
<p>R3-Alpha's %make-make.r had code for the first case, so you would say <code>make-make OS_ID=1.2.3</code>, or whatever.  This was presumably just going with the flow of how options to GNU make were specified.</p>
<p><a class="mention" href="/u/giuliolunati">@giuliolunati</a> had an interesting idea of using a more Rebol-like syntax:</p>
<pre><code>my-program optionname: option
</code></pre>
<p>This not only is "more Rebolish", but you get filename completion on your options in most shells (because it's not trying to do the completion with <code>optionname=</code> glued to the front of it).</p>
<p>At the moment, you can use either <code>--optionname=</code> or <code>optionname:</code> with %make.r.  I've been using the colon form for a while, and like it.  For the sake of simplicity, I'm wondering if it should be the <em>only</em> option format that <code>make.r</code> supports.</p>
<p>I can't think of any <em>technical</em> reason not to do it.  One could argue that it will look unfamiliar.  But I think it's easier to read this way.</p>
<p>Is there any reason not to standardize to this?</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/command-line-options-as-target-makefile-vs-target-makefile/1132">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/command-line-options-as-target-makefile-vs-target-makefile/1132</link>
          <pubDate>Mon, 25 Mar 2019 16:25:34 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1132</guid>
          <source url="https://forum.rebol.info/t/command-line-options-as-target-makefile-vs-target-makefile/1132.rss">command line options as `target: makefile` vs `target=makefile`</source>
        </item>
        <item>
          <title>About the Build System category</title>
          <dc:creator><![CDATA[gchiu]]></dc:creator>
          <category>Build System</category>
          <description><![CDATA[
            <p>Discuss rebol-make and other build systems.</p>
            <p><small>6 posts - 4 participants</small></p>
            <p><a href="https://forum.rebol.info/t/about-the-build-system-category/1131">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/about-the-build-system-category/1131</link>
          <pubDate>Mon, 25 Mar 2019 16:11:05 +0000</pubDate>
          <discourse:topicPinned>Yes</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1131</guid>
          <source url="https://forum.rebol.info/t/about-the-build-system-category/1131.rss">About the Build System category</source>
        </item>
        <item>
          <title>Ownership of GitHub by Microsoft - risk assessment</title>
          <dc:creator><![CDATA[gchiu]]></dc:creator>
          <category>Build System</category>
          <description><![CDATA[
            <p>Currently the whole project and all ancillary projects are hosted on GitHub, the proverbial eggs all in one basket scenario.  This is something we should consider even without the change of ownership.</p>
<p>Should we consider mirroring to GitLab?<br>
Or is the sky never falling?</p>
            <p><small>6 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/ownership-of-github-by-microsoft-risk-assessment/672">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/ownership-of-github-by-microsoft-risk-assessment/672</link>
          <pubDate>Sat, 09 Jun 2018 01:34:39 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-672</guid>
          <source url="https://forum.rebol.info/t/ownership-of-github-by-microsoft-risk-assessment/672.rss">Ownership of GitHub by Microsoft - risk assessment</source>
        </item>
        <item>
          <title>Obtaining a static url for the latest builds?</title>
          <dc:creator><![CDATA[gchiu]]></dc:creator>
          <category>Build System</category>
          <description><![CDATA[
            <p>Just wondering how feasible it is for Travis to also upload the latest build in a latest folder so that the URL remains fixed</p>
<p>So, instead of going, for example, to</p>
<pre><code>http://metaeducation.s3.amazonaws.com/travis-builds/0.3.40/r3-4f44c19-debug-cpp.exe
</code></pre>
<p>for the current latest build, we can go to</p>
<pre><code>http://metaeducation.s3.amazonaws.com/travis-builds/latest/0.3.40/r3.exe
</code></pre>
<p>This would make things easier to publish documents in case people need to use <code>wget</code> etc.</p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/obtaining-a-static-url-for-the-latest-builds/245">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/obtaining-a-static-url-for-the-latest-builds/245</link>
          <pubDate>Tue, 08 Aug 2017 07:09:24 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-245</guid>
          <source url="https://forum.rebol.info/t/obtaining-a-static-url-for-the-latest-builds/245.rss">Obtaining a static url for the latest builds?</source>
        </item>
  </channel>
</rss>
