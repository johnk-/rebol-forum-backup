<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Foreign Inspiration - AltRebol</title>
    <link>https://forum.rebol.info/c/development/foreign-inspiration/42</link>
    <description>Topics in the &#39;Foreign Inspiration&#39; category Take inspiration from other languages to create the same functionality in rebol.</description>
    
      <lastBuildDate>Sun, 05 Dec 2021 16:21:46 +0000</lastBuildDate>
      <atom:link href="https://forum.rebol.info/c/development/foreign-inspiration/42.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>Rye Language (?)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>So here's another language which doesn't look very Rebol-like but is by Refaktor who is Rebol-inspired:</p>
<aside class="onebox githubfolder">
  <header class="source">
      <img src="https://github.githubassets.com/favicons/favicon.svg" class="site-icon" width="32" height="32">
      <a href="https://github.com/refaktor/rye" target="_blank" rel="noopener">github.com</a>
  </header>
  <article class="onebox-body">
    <div class="aspect-image" style="--aspect-ratio:690/345;"><img src="https://opengraph.githubassets.com/122f981b955a64e477a664f1404312f7b4587117bc60742da6aea9e4d871023a/refaktor/rye" class="thumbnail" width="690" height="345"></div>

<h3><a href="https://github.com/refaktor/rye" target="_blank" rel="noopener">GitHub - refaktor/rye: work in progress rebol+factor+shell inspired language</a></h3>


  <p><span class="label1">work in progress rebol+factor+shell inspired language</span></p>

  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<p>Notably, it is written in Go.  <em>(I've mentioned that increasingly I have been leaning toward modeling things after Go for a runtime.  It would of course be easier to do by actually writing the runtime in Go, vs. trying to reproduce the effect in low-level C code.  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=9" title=":frowning:" class="emoji" alt=":frowning:"> )</em></p>
<p>It's probably very interesting, but I don't really feel like looking at it right at this moment.  Maybe someone else can study it and explain what it's about in a reply here.</p>
<p>The main carry-away I'll take for the moment is the 1:1 language-designer:user ratio that Rebol users are inevitably converging toward.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/rye-language/1768">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/rye-language/1768</link>
          <pubDate>Sun, 05 Dec 2021 16:21:46 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1768</guid>
          <source url="https://forum.rebol.info/t/rye-language/1768.rss">Rye Language (?)</source>
        </item>
        <item>
          <title>Kaj Gets on the Meta Train</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>So Kaj is still out there somewhere, working on a spiritual competitor to Red he is calling "Meta". <img src="https://forum.rebol.info/images/emoji/twitter/roll_eyes.png?v=9" title=":roll_eyes:" class="emoji" alt=":roll_eyes:"></p>
<p><a href="https://language.metaproject.frl/">https://language.metaproject.frl/</a></p>
<p>His first target is the Atari 2600 <img src="https://forum.rebol.info/images/emoji/twitter/joystick.png?v=9" title=":joystick:" class="emoji" alt=":joystick:"><img src="https://forum.rebol.info/images/emoji/twitter/space_invader.png?v=9" title=":space_invader:" class="emoji" alt=":space_invader:">  so he's certainly starting from... the basics.</p>
<p><em>(For whatever it's worth, I actually am interested in things like Atari 2600 programming and seeing what you can do with modern tools.  e.g. there's a neat <a href="https://youtu.be/4X1NdKvNCYQ?t=459">reboot of PAC-MAN</a> and I think a lot of people would like to know what <strong>could</strong> have been done, theoretically.)</em></p>
<p>There's no source code by which to measure the amount of investment the project represents so far.  He's only giving out binaries, and says:</p>
<blockquote>
<p>"There will always be a free version of <em>Meta</em>. We will build a business on top of it, by offering paid premium versions and other products built with <em>Meta</em>."</p>
</blockquote>
<h2>What's The Mission Difference From Red?</h2>
<p>Seemingly not much.  But inevitably, one angle is going to be "faster":</p>
<blockquote>
<p>"Red/System is the wrong abstraction level and the wrong format for an intermediate language, certainly for a REBOL language. The abstraction level is that of C, which is too low for the intermediate layer. The format is that of REBOL, which is free form for human use. Red is parsed from free form to something more suitable for machine processing, then a lot of Red/System is generated, then all of that needs to be reparsed. The compiler is painfully slow."</p>
</blockquote>
<p>But he's willing to build on LLVM to start with.  I'd said that Red should aim for a LLVM-subset IR, that could then be built with either a simple/small custom emitter or the full "bloated" toolchain if one really wanted to.  That would have provided a fallback; but Nenad wasn't a fan of the LLVM instruction set for some reason, and had ideas about exposing lower-level CPU features (maybe that was why).</p>
<p>So at least in this sense Kaj's approach seems more pragmatic to me.</p>
<p>Also inevitably: having people to work with was slowing him down.  He'll make much more progress on his own, <a href="https://atariage.com/forums/topic/315558-a-new-language-for-the-atari/?tab=comments#comment-4719124">as we find from his Atari Forum post</a>:</p>
<blockquote>
<p>Red was launched on a REBOL conference of mine in the Netherlands. I helped launch the language and contributed to it for half a decade. After that I left the project, because I am disappointed that it hasn't fulfilled its promises.</p>
<p>Before all that, I contributed to the latest version of REBOL and lobbied its creator Carl Sassenrath to open-source it. It eventually was, and REBOL could have done most of what Red promised, but Carl abandoned it when his funding ran out. After the leader left, the project was torn apart by competing interests.</p>
<p>My language is meant to succeed both REBOL and Red.</p>
</blockquote>
<h2>There's only ONE Download for Windows, Linux, Mac...?</h2>
<p>On the surface this seems interesting: he's using something called the <a href="https://justine.lol/ape.html">"APE: Actually Portable Executable"</a> format.  You can use a single download for all platforms--the same single file.  It puts x86 code into a container that can run as either a Windows .COM file or a unix shell script.</p>
<p>It's a stunt which isn't really all <em>that</em> profound--though I'll admit I'd wondered if there was some polyglot trick that could do exactly this.  Turns out the answer is yes...so that's cool.  I'm glad someone did it.</p>
<p>But it has more relevance to writing viruses than it does to practical cross-platform development.  Launching the code is a drop in the bucket compared to all the other things you need to worry about in a useful platform abstraction layer.  Not to mention that obviously Macs are now on ARM, so the binaries would have to be emulated or include both instruction sets.</p>
<p>At this juncture, running WebAssembly in a browser is far more compelling a story...because you have the whole web runtime available.</p>
<p>Anyway I doubt he's married to the APE format and is just trying it out because it seems cool.  It's not something I want to worry over.  And for what it's worth, it doesn't work for me on Windows 11.  YMMV.</p>
<h2>Source Comparison?</h2>
<p>Not much is available to compare.  His examples don't have headers, which is one of the more defining historical properties of Rebol programs.  The word "header" is not mentioned in his manifesto, so it's not clear if that's temporary or permanent.</p>
<p>Here's a Fibonacci example:</p>
<pre><code>; Maximum 24 for natural16! result
; Max 47 for natural32! result
parameter= 24
 
print "Fibonacci "  print parameter  print ": "
 
natural! [Fibonacci previous]
; natural32! [Fibonacci previous]
 
either parameter &lt;= 1 [
    Fibonacci: parameter  ; Fibonacci 0 ... 1
][
    Fibonacci: previous: 1  ; Fibonacci 2

    loop parameter - 2 [
        previous: also
            Fibonacci
            Fibonacci: Fibonacci + previous
     ]
]
 
print/line Fibonacci 
</code></pre>
<p>So...</p>
<ul>
<li>
<p>It seems he wants PRINT to not include a newline, so you have to say PRINT/LINE to get it.</p>
<ul>
<li>I prefer the solution of asking those who really want partial line output (e.g. console prompts) to WRITE STDOUT directly...and that PRINT COLLECT be used as a pattern when your code is piecing together a full line from parts generated by distinct bits of code, KEEP-ing each part.</li>
</ul>
</li>
<li>
<p>Working on Atari means he's getting involved in things like INTEGER16!, and you optimize based on annotating datatypes like that.  I'm more of the "bignum by default" philosophy, so different indeed.</p>
<ul>
<li>Putting <strong>natural! [Fibonacci previous]</strong> in the middle of the code to constrain the type--not in a function spec--suggests this is really rather far afield from the evaluator-driven Rebol.</li>
</ul>
</li>
<li>
<p>He's trotting out historical ALSO in a first example.  No one in the Atari forum clapped with amazement at the genius several Rebolers seem to think it represents.  (So I feel pretty comfortable with <strong><a href="https://forum.rebol.info/t/enfixing-also-stylizing-it-after-then-and-else/402">Ren-C's ALSO and ELIDE</a></strong>.)</p>
</li>
</ul>
<p>Without more to look at I can't have more to say.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/kaj-gets-on-the-meta-train/1753">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/kaj-gets-on-the-meta-train/1753</link>
          <pubDate>Sat, 20 Nov 2021 23:44:58 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1753</guid>
          <source url="https://forum.rebol.info/t/kaj-gets-on-the-meta-train/1753.rss">Kaj Gets on the Meta Train</source>
        </item>
        <item>
          <title>Python&#39;s Ideas for Dropping the &quot;Global Interpreter Lock&quot;</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>Python's C implementation (CPython) parallels the classical Redbol world in many ways.  So some of what they talk about here may be applicable:</p>
<aside class="onebox googledocs">
  <header class="source">
      <a href="https://docs.google.com/document/d/18CXhDb1ygxg-YXNBJNzfzZsDFosB5e6BfnXLlejd9l0/edit#" target="_blank" rel="noopener">docs.google.com</a>
  </header>
  <article class="onebox-body">
    <a href="https://docs.google.com/document/d/18CXhDb1ygxg-YXNBJNzfzZsDFosB5e6BfnXLlejd9l0/edit#" target="_blank" rel="noopener"><span class="googledocs-onebox-logo g-docs-logo"></span></a>

<h3><a href="https://docs.google.com/document/d/18CXhDb1ygxg-YXNBJNzfzZsDFosB5e6BfnXLlejd9l0/edit#" target="_blank" rel="noopener">Python Multithreading without GIL</a></h3>

<p>Multithreaded Python without the GIL  Sam Gross colesbury@gmail.com / sgross@fb.com   Source code: https://github.com/colesbury/nogil   The goal of this project is to remove the global interpreter lock (GIL) from CPython to enable multiple threads to...</p>

  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/pythons-ideas-for-dropping-the-global-interpreter-lock/1746">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/pythons-ideas-for-dropping-the-global-interpreter-lock/1746</link>
          <pubDate>Mon, 18 Oct 2021 10:06:37 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1746</guid>
          <source url="https://forum.rebol.info/t/pythons-ideas-for-dropping-the-global-interpreter-lock/1746.rss">Python&#39;s Ideas for Dropping the &quot;Global Interpreter Lock&quot;</source>
        </item>
        <item>
          <title>&quot;Streaming&quot; Survey from Other Languages</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>While PORT!s were ambiguous beasts, one objective we can see was that it should be possible to pipe them together.</p>
<p>This can be seen in the HTTP port.  It was written to (supposedly) not care what kind of port it was reading from, so long as it could supply a stream of bytes.</p>
<ul>
<li>
<p>If you feed HTTP from a TCP port, you get plain old http</p>
</li>
<li>
<p>If you feed HTTP from a TLS port, you get https</p>
<ul>
<li>The TLS port is, in turn, fed from TCP</li>
</ul>
</li>
</ul>
<p>I've written about how this was pretty convoluted...but is approaching a less tangled state.  So now we can look at it in a comparative light and redesign it.</p>
<p><strong>We'd really hope that something about Redbol nature can make this more interesting than what more performance-oriented languages offer.</strong></p>
<p><strong>But if nothing unique can be offered, it hopefully isn't any worse...then it's both <em>slower</em> and <em>worse</em> (which is what it has historically been).</strong></p>
<p>Comparisons follow...</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/streaming-survey-from-other-languages/1739">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/streaming-survey-from-other-languages/1739</link>
          <pubDate>Tue, 05 Oct 2021 08:25:31 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1739</guid>
          <source url="https://forum.rebol.info/t/streaming-survey-from-other-languages/1739.rss">&quot;Streaming&quot; Survey from Other Languages</source>
        </item>
        <item>
          <title>Carl&#39;s New Projects (?) AltScript, AltOS</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>This is apparently something Carl is working on...</p>
<p><strong><a href="https://altscript.com/?p=116">ASON AltScript Format</a></strong></p>
<p>Going through the bullet points:</p>
<blockquote>
<p><strong>Braces {} are used to denote objects</strong>. They are lexical and may be used directly without evaluation (the <code>make</code> constructor is not necessary).<br>
<strong>Braces {} are not used for multi-line strings</strong>. A single+double quote format is used for multi-line strings.</p>
</blockquote>
<p>At times I've certainly had my doubts about whether the language tradeoff of braces for strings is a good one.  I go back and forth on this.</p>
<p>Today the biggest justification for it is that it mixes well with putting portions of code in quotes, for strings and characters and filenames:</p>
<pre><code> REBVAL *v = rebValue("... {a string} #{c} %{spaced filename.txt}...")`.  
</code></pre>
<p>The escaping you get if you don't have that is annoying.  Single quotes aren't an option due to ambiguity with quoting.  It's a distinguishing feature, and I'd hate to drop it.</p>
<blockquote>
<p><strong>All loaded values are constant by default</strong>. This includes strings, blocks, and objects. They are all protected from modification. However, they can be copied and modified. In addition, they can be loaded as modifiable by using a load option.</p>
</blockquote>
<p>We tried this and I don't think it's as palatable or interesting as the current Ren-C behavior:</p>
<p><strong><a href="https://forum.rebol.info/t/the-beta-one-mutability-manifesto/1062">Mutability Manifesto</a></strong></p>
<p>It's been working well enough that I don't think anyone's found much fault with it.</p>
<p>Also, if Carl is working from the R3-Alpha codebase enforcement of mutability, there are countless bugs.</p>
<blockquote>
<p><strong>Zero-based indexing is used for blocks</strong> (arrays). This is consistent with many other languages.</p>
</blockquote>
<p>I've gotten used to FIRST and 1 going together.</p>
<blockquote>
<p><strong>Dots are used for field selection</strong>. For example, “person.name” refers to the name field of the person object. Slashes are not used for selection. Use of a dot for selection is common in many other languages.</p>
</blockquote>
<p>I favor dots, we have TUPLE! and the option to say that PATH! points are only for refinements.</p>
<blockquote>
<p><strong>The at sign “@” denotes literal values</strong> for none, true, false, data-types, and special values like NAN (not a number).</p>
</blockquote>
<p>This is interesting, because <a>I've suggested @ may play a role in datatypes</a>, with @ more broadly referring to a value category that is inert in the evaluator.</p>
<p>But there's still a lot to think about.</p>
<blockquote>
<p><strong>Short strings are stored directly</strong> in value cells, not in separate storage. This is an space-saving optimization.<br>
<strong>Characters are expressed as strings</strong>. The above storage optimization makes this possible.</p>
</blockquote>
<p>The TOKEN! unification (ISSUE! + CHAR!) does this.</p>
<blockquote>
<p><strong>Binary (byte arrays)</strong> use #”…” for hex and ##”…” for base-64.<br>
<strong>Base-2 binary</strong> is not directly expressible in source format.</p>
</blockquote>
<p>My current thinking is that ${...} and $"..." are used for binaries.</p>
<p>I don't know that I'm particularly concerned about special representations of base64 or base2.  It seems to me that TOKEN! can serve well enough and then you convert it if you need to.  The cases where you involve base64 binaries are few and far between...usually compressed payloads, and you know where they are so you don't need metadata saying "this information is binary, and this information is base64" because all you're going to do with it is decompress it.</p>
<blockquote>
<p><strong>Arithmetic operators</strong> can be used on series data-types (strings and blocks) for various useful results. For example “+” can be used to join strings and blocks.</p>
</blockquote>
<p><img src="https://forum.rebol.info/images/emoji/twitter/man_shrugging.png?v=9" title=":man_shrugging:" class="emoji only-emoji" alt=":man_shrugging:"></p>
<blockquote>
<p><strong>String character escapes use C notation</strong>. They use backslash notation, for example “\n” for newline and “\t” for tab.</p>
</blockquote>
<p>Giulio has asked for this.  It's a question worth revisiting.</p>
<blockquote>
<p><strong>The #{ and #[ sequences are reserved</strong> for future use. Currently they are undefined.</p>
</blockquote>
<p>I do like #{ as an alternative to #" for TOKEN!...it helps passing characters to APIs inside quoted strings.</p>
<blockquote>
<p><strong>For JSON compatiblity</strong>:</p>
<ul>
<li>Keys (word definitions) can be written with quotes (<code>“field”:</code>)</li>
<li>A lone colon (<code>:</code>) will automatically associate to the word/string immediately before it.</li>
<li>Commas as element separators are allowed as long as they are not directly followed by a non-digit character (to avoid confusion with comma-based decimal values.)</li>
</ul>
</blockquote>
<p>COMMA! has become a favorite feature of mine, so I like how it's done.</p>
<p>I don't know particularly what to say about the broader question of JSON compatibility.</p>
<p>Seems to touch upon a few points...in particular embracing dots and leaning more toward immutability/constness.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/carls-new-projects-altscript-altos/1571">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/carls-new-projects-altscript-altos/1571</link>
          <pubDate>Mon, 22 Mar 2021 17:02:18 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1571</guid>
          <source url="https://forum.rebol.info/t/carls-new-projects-altscript-altos/1571.rss">Carl&#39;s New Projects (?) AltScript, AltOS</source>
        </item>
        <item>
          <title>How Does Lisp Deal With Types?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>So I thought to look at how Lisp handles types.  (You'd think I'd have looked earlier.)</p>
<ul>
<li>Overview: <strong><a href="https://lispcookbook.github.io/cl-cookbook/type.html">Common Lisp Cookbook: Types</a></strong>
</li>
<li>Lengthier Survey: <strong><a href="https://alhassy.github.io/TypedLisp">"Typed Lisp, A Primer"</a></strong>
</li>
</ul>
<h2>Function Argument Type Checking (not there)</h2>
<p>First thing to note, they <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Type-Predicates.html">don't have function argument type checking</a>.</p>
<blockquote>
<p><em>"function arguments in Lisp do not have declared data types, as they do in other programming languages. It is therefore up to the individual function to test whether each actual argument belongs to a type that the function can use."</em></p>
</blockquote>
<p>While Rebol does have type checking, it's extremely limited.  It's a frustrating design point...because it's so limited, and because it is poked into a strange compacted place.  When people ask <em>"why only 64 data types?"</em> that gets at some of the strangeness of this feature.</p>
<p>When you try to build reflective abilities for the built-in type checking feature, you get into questions of how to expose these 64 bits.  That's done via TYPESET!, which isn't very easy to process, and doesn't seem like the foundation of a broader answer.  See <a href="https://forum.rebol.info/t/the-typeset-representation-problem/1300">"the TYPESET! representation problem"</a></p>
<h2>Lisp Type Representation</h2>
<p>They seem basically comfortable with the idea of using "WORD!" to name types, e.g. <strong>ensure 'integer 1</strong>.  <em>(Although their version of ENSURE is called THE, as a type annotation.  <strong>the 'integer 1</strong>  That's shorter...same length as "non", and would free ENSURE for other uses.  I can't tell if it makes total sense or not.)</em></p>
<blockquote>
<p><em>"Types are not objects in Common Lisp. There is no object that corresponds to the type <code>integer</code> , for example. What we get from a function like <code>type-of</code> , and give as an argument to a function like <code>typep</code> , is not a type, but a type specifier. A type specifier is the name of a type."</em></p>
</blockquote>
<p>They don't use the equality operator to check the result of "TYPE OF" against anything, because they get back additional "stuff, and I gather that "stuff" can vary from one implementation to another:</p>
<pre><code>* (type-of 1234)
(INTEGER 0 4611686018427387903)
</code></pre>
<p>So it seems they lean toward using functions to ask if types match.  They call these "predicates" and end them in P.  If we were to do a similar thing, it might look like:</p>
<pre><code>&gt;&gt; type? 10 'integer
== #[true]  ; knew to disregard stuff that `'integer = type of 1` wouldn't
</code></pre>
<p>Their notion of typeclasses is somewhat concretized.  Their ANY-VALUE! is just <strong><code>t</code></strong>.  So they do not try and express the notion of "anything" as an explicit union of all known types, the way that Rebol has.  It's inherently not extensible if you say <strong><code>any-value!: make typeset! [integer! text! ...]</code></strong> and then add a new datatype later.</p>
<p>If you scroll down a bit you get to some examples:</p>
<pre><code>;; The universal type “t”, has everything as its value.
(typep 'x 't) ;; ⇒ true
(typep 12 't) ;; ⇒ true

;; The empty type: nil
(typep 'x 'nil) ;; ⇒ false; nil has no values.

;; The type “null” contains the one value “nil”.
(typep nil 'null) ;; ⇒ true
(typep () 'null)  ;; ⇒ true

;; “(eql x)” is the singelton type consisting of only x.
(typep 3 '(eql 3)) ;; ⇒ true
(typep 4 '(eql 3)) ;; ⇒ false

;; “(member x₀ … xₙ)” denotes the enumerated type consisting of only the xᵢ.
(typep 3 '(member 3 x "c"))  ;; ⇒ true
(typep 'x '(member 3 x "c")) ;; ⇒ true
(typep 'y '(member 3 x "c")) ;; ⇒ false

;; “(satisfies p)” is the type of values that satisfy predicate p.
(typep 12 '(satisfies (lambda (x) (oddp x)))) ;; ⇒ false
(typep 12 '(satisfies evenp) )                ;; ⇒ true

;; Computation rule for comprehension types.
;; (typep x '(satisfies p)) ≈ (if (p x) t nil)
</code></pre>
<h2>Why Isn't Everything Just a Function?</h2>
<p>It seems like SATISFIES is the sort of generic way to hook up any function as a type check.  Like you could do arbitrary calculation to check to see if a number was prime...or something like that.</p>
<p>So why isn't this the <em>only</em> kind of type check?  Maybe something to do with the limits of what can be checked at compile time.</p>
<p>It seems that SBCL requires you to go through a symbol to use SATISFIES.  Whether that's on purpose or not, that it forces you to name your predicate is helpful as documentation.</p>
<h2>Stipulating Variables Match A Type</h2>
<p>There is a feature of saying that a word is only assigned particular types (declaim)...and though it didn't work for me in <code>"clisp"</code> it did in <code>"sbcl"</code>.</p>
<p>Were we to have such a feature, we'd presumably give it a better name, but:</p>
<pre><code>&gt;&gt; declaim 'x text!

&gt;&gt; x: 10
** Error: you said that x had to be TEXT!
</code></pre>
<p>When you think about languages arising like TypeScript, being able to annotate a variable to say that it has a certain type is a popular feature.   It's not clear how to do this inexpensively with complex type checks.</p>
<h2>Does This Point To Any Answers?</h2>
<p>The main thing to notice here is that the process isn't driven by "typesets", but rather by a kind of "type matching dialect"...that covers a few kinds of combining operations (including AND, OR), and if you can't get exactly what you want from the built-in bits, you can supply an open-ended function.</p>
<p>It goes in the direction I've been thinking about, where the core function application code doesn't really know what type checking is.  So it's layers above (like FUNC/FUNCTION) that provide the type checking, and define the type checking language.</p>
<p>Nothing particularly new, just thought I'd look.</p>
            <p><small>5 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/how-does-lisp-deal-with-types/1436">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/how-does-lisp-deal-with-types/1436</link>
          <pubDate>Thu, 17 Dec 2020 03:31:42 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1436</guid>
          <source url="https://forum.rebol.info/t/how-does-lisp-deal-with-types/1436.rss">How Does Lisp Deal With Types?</source>
        </item>
        <item>
          <title>Arturo: &quot;Rebol-inspired&quot; Language</title>
          <dc:creator><![CDATA[johnk]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>"Arturo is a modern programming language, vaguely inspired by various other ones - including but not limited to Rebol, Forth, Ruby, Haskell, D, SmallTalk, Tcl and Lisp."<br>
<aside class="onebox allowlistedgeneric">
  <header class="source">
      <img src="https://github.githubassets.com/favicons/favicon.svg" class="site-icon" width="32" height="32">
      <a href="https://github.com/arturo-lang/arturo" target="_blank" rel="noopener">GitHub</a>
  </header>
  <article class="onebox-body">
    <div class="aspect-image" style="--aspect-ratio:690/345;"><img src="https://repository-images.githubusercontent.com/210142708/e520ca00-070e-11eb-8bc9-0ebde05fef30" class="thumbnail" width="690" height="345"></div>

<h3><a href="https://github.com/arturo-lang/arturo" target="_blank" rel="noopener">arturo-lang/arturo</a></h3>

<p>Simple, modern and powerful interpreted programming language for efficient scripting. - arturo-lang/arturo</p>


  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>
</p>
            <p><small>15 posts - 4 participants</small></p>
            <p><a href="https://forum.rebol.info/t/arturo-rebol-inspired-language/1370">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/arturo-rebol-inspired-language/1370</link>
          <pubDate>Thu, 22 Oct 2020 02:37:11 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1370</guid>
          <source url="https://forum.rebol.info/t/arturo-rebol-inspired-language/1370.rss">Arturo: &quot;Rebol-inspired&quot; Language</source>
        </item>
        <item>
          <title>Spry language: rebol + smalltalk experimental language</title>
          <dc:creator><![CDATA[salotz]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>Here is an interesting Rebol inspired experimental language that combines ideas from Rebol and Smalltalk. Its Implemented in Nim. <a href="http://sprylang.se/index.html" rel="nofollow noopener">http://sprylang.se/index.html</a></p>
            <p><small>7 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/spry-language-rebol-smalltalk-experimental-language/1235">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/spry-language-rebol-smalltalk-experimental-language/1235</link>
          <pubDate>Mon, 21 Oct 2019 16:03:31 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1235</guid>
          <source url="https://forum.rebol.info/t/spry-language-rebol-smalltalk-experimental-language/1235.rss">Spry language: rebol + smalltalk experimental language</source>
        </item>
        <item>
          <title>Lively Web - a Javascript distributed Web Wiki</title>
          <dc:creator><![CDATA[IngoHohmann]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>Lively web, said to be inspired by Smalltalk, but implemented in Javascript.</p>
<p><a href="https://lively-web.org/" class="onebox" target="_blank" rel="nofollow noopener">https://lively-web.org/</a><br>
<a href="https://lively-kernel.org/" class="onebox" target="_blank" rel="nofollow noopener">https://lively-kernel.org/</a><br>
<a href="https://lively-next.org/projects.html" class="onebox" target="_blank" rel="nofollow noopener">https://lively-next.org/projects.html</a><br>
<a href="https://lively-kernel.org/lively4/lively4-core/start.html?load=https://lively-kernel.org/lively4/lively4-core/README.md" class="onebox" target="_blank" rel="nofollow noopener">https://lively-kernel.org/lively4/lively4-core/start.html?load=https://lively-kernel.org/lively4/lively4-core/README.md</a></p>
<p>Ren-C should be able to be much better than that.<br>
(Just some ideas for the future.)</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/lively-web-a-javascript-distributed-web-wiki/1218">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/lively-web-a-javascript-distributed-web-wiki/1218</link>
          <pubDate>Sun, 29 Sep 2019 22:04:08 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1218</guid>
          <source url="https://forum.rebol.info/t/lively-web-a-javascript-distributed-web-wiki/1218.rss">Lively Web - a Javascript distributed Web Wiki</source>
        </item>
        <item>
          <title>Should the C sources say `++foo` or `++ foo` ?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>Generally speaking, the Ren-C sources try to adhere to the same kind of rules that Rebol uses.  So instead of writing <code>(x+y)</code> the code uses <code>(x + y)</code>, believing this is more legible.</p>
<p>It also embraces the idea of macros that define <code>and</code> for <code>&amp;&amp;</code>, and <code>not</code> for <code>!</code>.  In addition to these being defined in C++ since the original C++98 standard as "alternative tokens", the C track has an ISO standard header for it, so you can <code>#include &lt;iso646.h&gt;</code> if you like:</p>
<p><a href="https://en.wikipedia.org/wiki/C_alternative_tokens">https://en.wikipedia.org/wiki/C_alternative_tokens</a></p>
<p>In the C++ world, there are good reasons for preferring pre-increment and pre-decrement to post (all things being equal).  While it doesn't matter in C it's good to stay in a good habit:</p>
<aside class="onebox stackexchange">
  <header class="source">
      <a href="https://stackoverflow.com/questions/30036749/is-it-still-better-to-prefer-pre-increment-over-post-increment" target="_blank" rel="noopener">stackoverflow.com</a>
  </header>
  <article class="onebox-body">
      <a href="https://stackoverflow.com/users/315052/jxh" target="_blank" rel="noopener">
    <img alt="jxh" src="https://i.stack.imgur.com/AB5ST.png?s=128&amp;g=1" class="thumbnail onebox-avatar" width="128" height="128">
  </a>
<h4>
  <a href="https://stackoverflow.com/questions/30036749/is-it-still-better-to-prefer-pre-increment-over-post-increment" target="_blank" rel="noopener">Is it still better to prefer pre-increment over post-increment?</a>
</h4>

<div class="tags">
  <strong>c++, optimization</strong>
</div>

<div class="date">
  asked by
  
  <a href="https://stackoverflow.com/users/315052/jxh" target="_blank" rel="noopener">
    jxh
  </a>
  on <a href="https://stackoverflow.com/questions/30036749/is-it-still-better-to-prefer-pre-increment-over-post-increment" target="_blank" rel="noopener">05:59PM - 04 May 15 UTC</a>
</div>

  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<p>So I've habitually changed <code>foo++</code> to <code>++foo</code> when I see it, assuming it doesn't change the semantics.</p>
<p>But another maybe-seemingly-frivolous question arises, of if it would be better to put a space there?  <code>++ foo</code>?  Is it a readability advantage that C programmers have been missing out on?  Or is it wasteful and out of touch?</p>
<p>Hard to tell, as many people do like to say <code>x=y+1020;</code>, where we say <code>x = y + 1020;</code>.  It seems natural that the sources for a language that believes in space significance would do so, I'm just curious what the operating rule for why this wouldn't apply to <code>++</code> and <code>--</code> would come from.</p>
            <p><small>5 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/should-the-c-sources-say-foo-or-foo/1200">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-the-c-sources-say-foo-or-foo/1200</link>
          <pubDate>Thu, 29 Aug 2019 08:53:54 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1200</guid>
          <source url="https://forum.rebol.info/t/should-the-c-sources-say-foo-or-foo/1200.rss">Should the C sources say `++foo` or `++ foo` ?</source>
        </item>
        <item>
          <title>PARTIAL specialization (...maybe with GET-GROUP?)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>Haskell has something called "currying" and it lets them write stuff like:</p>
<pre><code>map (add 2) [1, 2, 3]
</code></pre>
<p>That results in [3, 4, 5].  So it meant the same thing as what Rebol would say as <code>map-each x [1 2 3] [add 2 x]</code>.  Effectively, it's as if it noticed ADD didn't have enough parameters...but instead of erroring it assumed you wanted to create a function that would just be taking the 3 later.  <em>(Technically speaking all functions in Haskell take only take one parameter, <a href="https://softwareengineering.stackexchange.com/questions/185585/what-is-the-advantage-of-currying" rel="nofollow noopener">and that's related to the "currying"</a>, so it's not like it had to do something special to "notice".)</em></p>
<p>If we imagine MAP as a function in Ren-C that did the same thing (take a function and apply it for each member of a series, return a series of the results) you'd have to do this as:</p>
<pre><code>map (specialize 'add [value1: 2]) [1 2 3]
</code></pre>
<p>That's wordy.  It also forces you to remember the name of add's parameters, when you may not care (and parameter names may tend to change).</p>
<p>So imagine we have a variant of specialization that doesn't make you name arguments, it just kind of grabs as many as you supply...in this case one.  Let's call this PARTIAL for a moment:</p>
<pre><code>map (partial 'add [2]) [1 2 3]
</code></pre>
<p>That's brief, but still kind of wordy.  Might it be nice if there were a way to do this that was briefer, like...say...</p>
<pre><code>map :(add 2) [1 2 3]
</code></pre>
<p>In such a world, plain <strong>(add 2)</strong> would still be an error, since there was no colon.</p>
<p>One place this would be handy is because I've been trying to think about how to modify things like SHOVE and MATCH to operate on things other than the first argument.  Right now you can say:</p>
<pre><code> &gt;&gt; obj: make object! [dv: enfix :divide]
 &gt;&gt; 8 -&gt; obj/dv 2
 == 4
</code></pre>
<p>That lets you shove 8 as the left hand parameter of an enfix parameter dispatched via path.  But what if you wanted it the other way around, to make it the second parameter, so you were <em>dividing by 8</em>.  It might be nice to be able to say:</p>
<pre><code>&gt;&gt; 8 -&gt; :(obj/dv 2)
== 0.25
</code></pre>
<p>So that would "shove" the parameter to be after the 2.  As another example, today's MATCH works on the first argument:</p>
<pre><code>&gt;&gt; match parse "aab" [some "a"]
// null

&gt;&gt; match parse "aaa" [some "a"]
== "aaa"
</code></pre>
<p>But what if instead of getting the data when the expression succeeded, you wanted the rule?</p>
<pre><code>&gt;&gt; match :(parse "aab") [some "a"]
// null

&gt;&gt; match :(parse "aaa") [some "a"]
== [some "a"]
</code></pre>
<p>So MATCH is still grabbing the "first argument" of the function you give it on a match.  You just made a partial function whose first parameter was the rule, since the data was specialized into the partial.</p>
<p>I had considered making this the natural syntax of <strong>match (...) ...</strong> but that just feels like it is getting in the way of when you want to use GROUP! just for grouping.  This feels like a different operation, and one that's useful enough to build in.</p>
            <p><small>5 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/partial-specialization-maybe-with-get-group/931">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/partial-specialization-maybe-with-get-group/931</link>
          <pubDate>Wed, 28 Nov 2018 14:41:05 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-931</guid>
          <source url="https://forum.rebol.info/t/partial-specialization-maybe-with-get-group/931.rss">PARTIAL specialization (...maybe with GET-GROUP?)</source>
        </item>
        <item>
          <title>Syntactically Significant Newlines</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>JSON came from a Rebol heritage, yet people found it weak weak in a couple of areas.  So odd-little YAML has come in to pick up some of that slack:</p>
<p><a href="https://learnxinyminutes.com/docs/yaml/" class="onebox" target="_blank" rel="nofollow noopener">https://learnxinyminutes.com/docs/yaml/</a></p>
<p>One of the key features is syntactically significant newlines.  Rebol already ascribes syntactic significance to newlines in some constructs (comments, multi-line strings) so you can't just take an input Rebol file and smoosh all the newlines together and have it mean the same thing.</p>
<p>So why not add some way to get arbitrary string data based on a significant newline?  What if <strong>#</strong> followed by a space didn't make an empty ISSUE!, but rather cued the issue to just read to the end of the line...uninterpreted?</p>
<pre><code>&gt;&gt; issue: #   ))) Write 4nything you $want$ here  (((
&gt;&gt; as text! issue
== "   ))) Write 4nything you $want$ here  ((("
</code></pre>
<p>There'd be a light annoyance in the sense that the leading space becomes part of the content, and would need to be for accurate molding.  But with Rebol's model, you can always NEXT that out if you need to pass it to some routine.</p>
<pre><code>&gt;&gt; issue: # foo bar
&gt;&gt; as text! next issue
== "foo bar"
</code></pre>
<p>What you'd use this for are things like UNIX command lines, as in .travis.yml</p>
<pre><code># echo "Generating the cross-compiler"
# ${TOP_DIR}/external/tcc/configure --enable-cross --extra-cflags="-DEMBEDDED_IN_R3"
# make -j ${MAKE_JOBS}

// Could throw in comments, which wouldn't get tied up as part of the string content
// (they would be if you tried doing this with a multi-line string literal)
# mkdir bin
# cp *tcc bin #save cross-compilers
</code></pre>
<p>FILE! could follow the same rule:</p>
<pre><code>% echo "Generating the cross-compiler"
% ${TOP_DIR}/external/tcc/configure --enable-cross --extra-cflags="-DEMBEDDED_IN_R3"
% make -j ${MAKE_JOBS}

// This probably looks a bit better to the average UNIXer
% mkdir bin
% cp *tcc bin #save cross-compilers
</code></pre>
<p>But if you did read an issue and NEXT'd out its leading space, you'd have to mold it somehow.  Not a new problem, as you can create issues with embedded spaces today.</p>
<p>It's a bit unfortunate that #{} is used for BINARY!, as #{} would be good for empty issue (and would permit multi-line issues as well).  Due to that, I might suggest ${..} for BINARY!, with #{...} gradually phased out and ultimately repurposed.  (Curiously, any binary would be loadable as an ISSUE! since an issue can hold anything--including hex characters, so old files would still LOAD and be able to be converted under this change, perhaps at LOAD time in the legacy emulation.)</p>
<h2>Interestingly, you could kind of use # for comments</h2>
<p>Today you can write:</p>
<pre><code>sum: function [x y] [ #the-summation-function
    return x + y #return-them-added-together
]
</code></pre>
<p>It works because ISSUE!s are inert.  But with this change, you'd be able to now say:</p>
<pre><code>sum: function [x y] [ # the summation function
    return x + y # return them added together
]
</code></pre>
<p>Still only two ISSUE!s.</p>
<p>Because the values are actually <em>there</em>, it would screw up some things.  For instance, since RETURN detects no argument and then gives back void, this would return an ISSUE!:</p>
<pre><code>sum: function [x y] [ # the summation function
    return # now we're returning an ISSUE!
]
</code></pre>
<p>Of course, that consequence is small potatoes for why it wouldn't be a good general substitute for comments.  It's fairly relevant that they're not stripped out of your file but just left there.</p>
<p>But what it could mean is it could give dialects that wanted to do something creative with # that was <em>comment-like</em> could do so.</p>
<h2>It could be used with the DUMP abbreviations</h2>
<p>Instead of writing:</p>
<pre><code>-- "got to part 3a"
</code></pre>
<p>You could write:</p>
<pre><code>-- # got to part 3a
</code></pre>
<p>It's the same number of characters, but it stands out a little more while at the same time looking less cluttered.  Plus it swaps out a shift-to-type quote for a space, so you only hit one shifted character.</p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/syntactically-significant-newlines/918">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/syntactically-significant-newlines/918</link>
          <pubDate>Wed, 21 Nov 2018 07:29:19 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-918</guid>
          <source url="https://forum.rebol.info/t/syntactically-significant-newlines/918.rss">Syntactically Significant Newlines</source>
        </item>
        <item>
          <title>Promises, Promises: Should THEN and ELSE be used for them?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>Tinkering with JavaScript again after some years of being blissfully ignorant, I notice that a style of programming which used to be popular there has caught on even more.  These are "Promises"--which I've seen under other names like "Futures".</p>
<p>They've become so ingrained that they're now in the JavaScript language itself:</p>
<aside class="onebox allowlistedgeneric">
  <header class="source">
      <img src="https://developer.mozilla.org/static/img/favicon32.7f3da72dcea1.png" class="site-icon" width="32" height="32">
      <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">MDN Web Docs</a>
  </header>
  <article class="onebox-body">
    <img src="https://developer.mozilla.org/static/img/opengraph-logo.72382e605ce3.png" class="thumbnail onebox-avatar" width="500" height="500">

<h3><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">Promise</a></h3>

<p>The Promise object represents the eventual completion (or failure) of an asynchronous operation and its resulting value.</p>


  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<p><em>(Note: Worth pointing out is that there's a fundamental feature missing from the built-in promises, namely <a href="https://stackoverflow.com/a/30235261/211160">cancellation</a>.  Kind of makes you roll your eyes when you see someone deploy a major language feature to a worldwide audience--as if it's "the future of asynchronous programming and network requests"--when there's no way to cancel.)</em></p>
<p>When you have a promise in your hand, you can hook it up to clauses that will run if it succeeds, and clauses to run if it fails.  You hook them together with successive function calls...where the THEN clauses are the successes, and the CATCH clauses are the failures:</p>
<pre><code>some_promise.then(
    function(val) {
        log.insertAdjacentHTML('beforeend', val +
            ') Promise fulfilled (&lt;small&gt;Async code terminated&lt;/small&gt;)&lt;br/&gt;');
    }).catch(
    // Log the rejection reason
   (reason) =&gt; {
        console.log('Handle rejected promise ('+reason+') here.');
    });
</code></pre>
<p>You can make loooong chains out of these.  Steps can be triggered by callbacks, or even by just an ordinary non-promise value falling through immediately from the previous step.  It may help to look at a big example <em>(from <a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-promise-27fc71e77261">this article</a>, if it looks weird with <code>const</code> and <code>=&gt;</code> remember that JavaScript has changed a bit, and this stuff is in it now)</em>:</p>
<pre><code>const wait = time =&gt; new Promise(
   res =&gt; setTimeout(() =&gt; res(), time)
);

wait(200)
   // onFulfilled() can return a new promise, `x`
  .then(() =&gt; new Promise(res =&gt; res('foo')))
  // the next promise will assume the state of `x`
  .then(a =&gt; a)
  // Above we returned the unwrapped value of `x`
  // so `.then()` above returns a fulfilled promise
  // with that value:
  .then(b =&gt; console.log(b)) // 'foo'
  // Note that `null` is a valid promise value:
  .then(() =&gt; null)
  .then(c =&gt; console.log(c)) // null
  // The following error is not reported yet:
  .then(() =&gt; {throw new Error('foo');})
  // Instead, the returned promise is rejected
  // with the error as the reason:
  .then(
    // Nothing is logged here due to the error above:
    d =&gt; console.log(`d: ${ d }`),
    // Now we handle the error (rejection reason)
    e =&gt; console.log(e)) // [Error: foo]
  // With the previous exception handled, we can continue:
  .then(f =&gt; console.log(`f: ${ f }`)) // f: undefined
  // The following doesn't log. e was already handled,
  // so this handler doesn't get called:
  .catch(e =&gt; console.log(e))
  .then(() =&gt; { throw new Error('bar'); })
  // When a promise is rejected, success handlers get skipped.
  // Nothing logs here because of the 'bar' exception:
  .then(g =&gt; console.log(`g: ${ g }`))
  .catch(h =&gt; console.log(h)) // [Error: bar]
;
</code></pre>
<p>This resembles the kind of chaining done with enfix, so...</p>
<h2>...might THEN and ELSE be promise-aware?</h2>
<p>JavaScript uses the name THEN here to mean "do this thing on the right <em>if the left happens</em>" or "<em>if the left is fulfilled</em>".  You can get a "false" result back from a promise:</p>
<pre><code>var falsify = new Promise(
   resolve =&gt; {
       resolve(false) // calling resolve will fulfill the promise
   }
);

falsify.then(x =&gt; console.log(x)) // this will print out false
</code></pre>
<p>Seeing that concept as a meaning for THEN helped provoke me into pushing things around to <a href="https://forum.rebol.info/t/taking-then-back-as-the-rightful-complement-to-else/731">change THEN back to <em>not</em> being an enfix form of IF</a>.  It was a no-brainer to do that, once I realized that the blocking issue of <strong>all [...] then [...]</strong> was no longer blocking.</p>
<p>But here we have to ask a question about what the rules are for the system.  If you see something like:</p>
<pre><code>all [...] then [print "done with all that stuff"]
print "moving on..."
</code></pre>
<p>Would you want the system to be based on a worldview where that could output:</p>
<pre><code>"moving on..."
"done with all that stuff"
</code></pre>
<p>If you have a PROMISE! datatype in the picture, then programs which use them will become asynchronous even if they don't appear to be written in an asynchronous style.  The more automatic it is, the greater the risks become.</p>
<p>JavaScript's promises involve very little system support.  Not only were most promise library designs done before the language supported them at all, one of the most popular implementations <a href="http://bluebirdjs.com/docs/getting-started.html">doesn't even use the new JS built-in promises</a>...but cooks up its own using functions and objects.</p>
<p>So this is different from what Gabriele was suggesting when he brought up promises <a href="https://forum.rebol.info/t/places-to-look-for-port-prior-art/621/3">as a likely path forward for PORT!s</a> in his Topaz design notes.  He's suggesting that a PROMISE! would be an active datatype, where if you merely said <strong>data: read url</strong> and got a promise back, then <strong>length of data</strong>, it would automatically wait until the length was known.  You wouldn't have to explicitly WAIT on it (or have a THEN, as suggested above).</p>
<p>It's trying to suggest a synchronous client of READ could go on their merry way using it just as if they got bytes back, or tactically drill in with promise-aware constructs on an as-needed basis.  As nice as that sounds it's <em>not realistic</em>.  What you'd need to accomplish such a goal more or less asks the runtime support for lazy evaluation, and the restrictions that brings in would push back to where the user's style of programming would have to morph into something much more like Haskell than like Rebol/JavaScript/etc.</p>
<p>JavaScript's answer is to quarantine down the promise-aware constructs of the language to more or less <em>zero</em>.  Their if() treats them as truthy, not "wait on them asynchronously and see if the result was truthy, or falsey if an error".  Things like .then() are methods on the promise itself, not generic language operators.</p>
<p>As I've pointed out that people aren't even necessarily with the built-in promises of JavaScript--enough to continue using libraries that cobble the protocols together out of objects and functions--it may suggest that zero is not a good sweet spot for language support.  To really be compelling enough for pervasive use there may need to be some special sauce you don't get elsewhere (including, I'd have to say, cancellation).</p>
<p>I do wonder if conditionals could be a place where it might be good to synchronize a promise.  Or if ANY and ALL could imply WAITs.  But certainly it seems like it would be appealing if THEN and ELSE could be used...so I guess that's what I'll put out there for a starting thought.</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/promises-promises-should-then-and-else-be-used-for-them/734">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/promises-promises-should-then-and-else-be-used-for-them/734</link>
          <pubDate>Thu, 12 Jul 2018 08:34:53 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-734</guid>
          <source url="https://forum.rebol.info/t/promises-promises-should-then-and-else-be-used-for-them/734.rss">Promises, Promises: Should THEN and ELSE be used for them?</source>
        </item>
        <item>
          <title>Each versus for-each and for-all</title>
          <dc:creator><![CDATA[gchiu]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>In 8th, they have the *:each as a higher order function.</p>
<p>So, depending on whether it's being applied to a map, array, buffer, string it works like this:</p>
<pre><code>Buffer lambda b:each
</code></pre>
<p>So, here the buffer is iterated over and the index and value are placed on the stack for lambda to consume.</p>
<p>For-each neesd to create words, and for-all needs to reference the series by name which creates more visual clutter.</p>
<p>In VID lambdas had access to a similar functionality where <em>value</em> was available.</p>
<p>We could do the same:</p>
<pre><code>Each series [ code ] 
</code></pre>
<p>Where code has access to the words index and value of the series being traversed.</p>
            <p><small>5 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/each-versus-for-each-and-for-all/678">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/each-versus-for-each-and-for-all/678</link>
          <pubDate>Sat, 09 Jun 2018 23:47:28 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-678</guid>
          <source url="https://forum.rebol.info/t/each-versus-for-each-and-for-all/678.rss">Each versus for-each and for-all</source>
        </item>
        <item>
          <title>New version of loop</title>
          <dc:creator><![CDATA[gchiu]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>In 8th I see this construct:</p>
<pre><code>Function n times
</code></pre>
<p>Which is the same as Rebol's</p>
<pre><code>Loop n [ ... ]
</code></pre>
<p>But doesn't this look less busy?</p>
<pre><code>Times n :function
</code></pre>
<p>Loop could be changed to look to see if its parameter is a function to do this automatically, but currently it's a native and not in user space.</p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/new-version-of-loop/677">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/new-version-of-loop/677</link>
          <pubDate>Sat, 09 Jun 2018 23:29:05 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-677</guid>
          <source url="https://forum.rebol.info/t/new-version-of-loop/677.rss">New version of loop</source>
        </item>
        <item>
          <title>About the Foreign Inspiration category</title>
          <dc:creator><![CDATA[gchiu]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>Take inspiration from other languages to create the same functionality in rebol.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/about-the-foreign-inspiration-category/676">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/about-the-foreign-inspiration-category/676</link>
          <pubDate>Sat, 09 Jun 2018 23:22:45 +0000</pubDate>
          <discourse:topicPinned>Yes</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-676</guid>
          <source url="https://forum.rebol.info/t/about-the-foreign-inspiration-category/676.rss">About the Foreign Inspiration category</source>
        </item>
  </channel>
</rss>
