<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>PARSE on PORT! and avoiding generic behavior w.r.t. ANY-SERIES!</title>
    <link>https://forum.rebol.info/t/parse-on-port-and-avoiding-generic-behavior-w-r-t-any-series/1276</link>
    <description>If you look at Rebol2, R3-Alpha, and Red they all do the same thing with FILE! that they would with text (STRING!) when you pass as the first argument to PARSE:

    rebol2&gt;&gt; parse %aaa.txt [some &quot;a&quot; &quot;.txt&quot;]
    == true

    r3-alpha&gt;&gt; parse %aaa.txt [some &quot;a&quot; &quot;.txt&quot;]
    == true

    red&gt;&gt; parse %aaa.txt [some &quot;a&quot; &quot;.txt&quot;]
    == true

I&#39;ve always had the ambition that you be able to PARSE a PORT!.  If that&#39;s possible, it seems that you should be able to shortcut actually opening and closing the port yourself by saying something like:

    parse %some-200-megabyte-file.txt [
         some &quot;a&quot; end (print &quot;Your giant file was all the letter A&quot;)
    ]

    parse http://example.com/some-net-data/ [
        thru &lt;title&gt; copy title to &lt;/title&gt; (print [&quot;Title was&quot; title])
    ]

The vision would be that PARSE would assume when you gave it a FILE! or URL! that you meant to operate on that as a PORT!...opening it, parsing it, and closing it.  If you gave it a regular PORT! it would assume you would take care of closing it yourself.

Furthermore, it would be efficient so that it didn&#39;t need to load all of it into memory at once.  (There could be some heuristic on a &quot;chunk size&quot; it picked automatically, paging in only as much of the file as it needed at a time.  But you could perhaps tweak that manually by opening the port yourself and doing some settings.  This seems to be a property of the PORT! and not of PARSE, though there may be PARSE-specific settings.  Perhaps those settings would be looked for on the port itself as an extensible set of headers, vs. being some strange refinement you&#39;d pass.)

In any case, the appeal of having that work for FILE! and URL! certainly seems to suggest that it&#39;s a much better use of the type variety than as a synonym for:

    &gt;&gt; did parse as text! %aaa.txt [some &quot;a&quot; &quot;.txt&quot; end]
    == #[true]

There&#39;s clear need for PARSE to run on TEXT!, BINARY!, and BLOCK! input.  I&#39;m not sure how this applies to INTO.  There also might be a **parse/only** (or **parse/into**? which would be type-preserving?)

## Not just for PARSE: a General Philosophy of ANY-SERIES!

This ties into what I think should be a very restrained tendency to use ANY-STRING! types in ways that make them equivalent to the behavior on TEXT!.

I&#39;ve said similar things about why **type of first [&#39;&#39;&#39;a]** should not be conflated with plain WORD!.  There should be a default of discernment; leaving the room open for distinct meanings.

So be on the lookout for cases where a datatype is being underused, even if it&#39;s not able to do the ideal magic today.  Seeing PARSE run on PORT! is a pretty big wishlist item for me, so maybe it&#39;s not impossible that it could happen... (!)</description>
    
    <lastBuildDate>Mon, 29 Nov 2021 01:44:32 +0000</lastBuildDate>
    <category>Ports</category>
    <atom:link href="https://forum.rebol.info/t/parse-on-port-and-avoiding-generic-behavior-w-r-t-any-series/1276.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>PARSE on PORT! and avoiding generic behavior w.r.t. ANY-SERIES!</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>In terms of questions of <strong>"what has worked and what hasn't"</strong>, I think read-only URLs (for example) have worked out okay for me.</p>
<p>If you want to mutate a URL!, turn it into a string and mutate that.  If you can turn it back into a URL! then great.  If you can't then it's probably good we don't have to come up with some weird way of representing URL!s that aren't URLs.</p>
<p>Or this kind of garbage:</p>
<pre><code>red&gt;&gt; code: reduce [reverse http://hostilefork.com]
== [moc.krofelitsoh://ptth]

red&gt;&gt; type? first code
== #[datatype! url!]  ; doesn't look like one, and wouldn't LOAD as one

red&gt;&gt; clear first code

red&gt;&gt; code
== [
;  ^-- yup, it's just one left bracket

red&gt;&gt; type? first code
== #[datatype! url!]
</code></pre>
<p>But regarding this other behavior I talk about in the thread above:</p>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1276">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I've always had the ambition that you be able to PARSE a PORT!. If that's possible, it seems that you should be able to shortcut actually opening and closing the port yourself by saying something like:</p>
<pre><code>parse %some-200-megabyte-file.txt [
    some "a" end (print "Your giant file was all the letter A")
]

parse http://example.com/some-net-data/ [
    thru &lt;title&gt; copy title to &lt;/title&gt; (print ["Title was" title])
]
</code></pre>
</blockquote>
</aside>
<p>That may not be working out.  I guess I can understand saying that if you want a PARSE on a PORT! that auto opens and closes you'd use something else.  Python has a <a href="https://www.python.org/dev/peps/pep-0343/">"WITH" construct</a> that takes care of the open and close, so:</p>
<pre><code>with port: http://example.com/some-net-data [
    parse port [
        thru &lt;title&gt; copy title to &lt;/title&gt; (print ["Title was" title])
    ]
]

; ... or maybe like LET, scoped without a code block

(with port: http://example.com/some-net-data
parse port [
    thru &lt;title&gt; copy title to &lt;/title&gt; (print ["Title was" title])
])  ; close happens when scope ends?
</code></pre>
<p>Having taken PARSE of URL! away I'm seeing enough use cases to be empathetic that having to turn things into strings yourself is a hassle if you want to extract some data from a URL.</p>
<p><strong>But I think what should happen when you PARSE/UPARSE a URL! is you get a read-only string alias.</strong>  If you really feel the need to do mutations, <em>then</em> you need to make a string out of it (a full copy, not just a string alias of the bytes)...and then if you really want a URL back you have to prove the thing is still a URL and coerce it.</p>
<p>So no CHANGE etc. on a plain URL! parse.  And when you copy segments out of it you're getting string segments...not little bits of text that are flavored URL!.</p>
<p>Fair enough?</p>
          <p><a href="https://forum.rebol.info/t/parse-on-port-and-avoiding-generic-behavior-w-r-t-any-series/1276/16">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/parse-on-port-and-avoiding-generic-behavior-w-r-t-any-series/1276/16</link>
        <pubDate>Sun, 28 Nov 2021 01:46:04 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1276-16</guid>
        <source url="https://forum.rebol.info/t/parse-on-port-and-avoiding-generic-behavior-w-r-t-any-series/1276.rss">PARSE on PORT! and avoiding generic behavior w.r.t. ANY-SERIES!</source>
      </item>
      <item>
        <title>PARSE on PORT! and avoiding generic behavior w.r.t. ANY-SERIES!</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="1" data-topic="1276">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>...it seems that you should be able to shortcut actually opening and closing the port yourself by saying something like:</p>
<pre><code>parse %some-200-megabyte-file.txt [
    some "a" end (print "Your giant file was all the letter A")
]
</code></pre>
</blockquote>
</aside>
<p>This is the direction I've decided to take things in.  However I do think (maybe) that what's happening is that some of the ideas behind PORT! and user-defined types are kind of merging.  This means that if someone wanted to take this in another direction they might be able to...by saying that a FILE! is a container for a TEXT!... and instead of operating "portishly" it would respond "stringishly" to things like APPEND.</p>
<p>We'll see.</p>
<p>But since these are shorthands for ports, getting at the actual filename could come by way of something like <strong>name of</strong>:</p>
<pre><code>parse path of %some-200-megabyte-file.txt [
    thru "-" 200 "-" thru ".txt"
]
</code></pre>
<p>Which might also have other offerings:</p>
<pre><code>&gt;&gt; directory of %foo/bar.txt
== %foo/

&gt;&gt; path of %foo/bar.txt
== %foo/bar.txt

&gt;&gt; filename of %foo/bar.txt  ; would just "name of" be clear?
== %bar.txt
</code></pre>
<p>But the more fundamental offerings that don't talk to the PORT! would be available, and faster.  If people find writing AS TEXT! to be laborious there will be a cleaner shorthand when the name is what you think is important:</p>
<pre><code>parse spell %some-200-megabyte-file.txt [
    thru "-" 200 "-" thru ".txt"
]</code></pre>
          <p><a href="https://forum.rebol.info/t/parse-on-port-and-avoiding-generic-behavior-w-r-t-any-series/1276/15">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/parse-on-port-and-avoiding-generic-behavior-w-r-t-any-series/1276/15</link>
        <pubDate>Thu, 02 Sep 2021 10:34:22 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1276-15</guid>
        <source url="https://forum.rebol.info/t/parse-on-port-and-avoiding-generic-behavior-w-r-t-any-series/1276.rss">PARSE on PORT! and avoiding generic behavior w.r.t. ANY-SERIES!</source>
      </item>
      <item>
        <title>PARSE on PORT! and avoiding generic behavior w.r.t. ANY-SERIES!</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="13" data-topic="1276">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I did encounter a case of wanting to PARSE a FILE! and I felt in doing so that it was useful to not have to convert it to a string first. So there's a bit of ambivalence here.</p>
</blockquote>
</aside>
<p>I'm trying to straighten out some of the semantics of the file operations while standardizing on libuv.</p>
<p>I found the behavior that <strong>append</strong> on a <strong>port!</strong> will act like <strong>write/append</strong>.  The mechanism that R3-Alpha used to implement the retriggering of APPEND was bad and dangerous.  So I'd done it a different hacky way that was less dangerous.</p>
<p>But in the comments I had remarked about the difference between:</p>
<pre><code>write/append %foo.txt "data"  ; appends "data" to the foo.txt disk file
</code></pre>
<p>and</p>
<pre><code>&gt;&gt; append %foo.txt "data"
== %foo.txtdata
</code></pre>
<p>One conclusion to draw from this is that trying to make the PORT! accept the APPEND verb is misguided, because it doesn't work equally well in the "implicit port" style.</p>
<p><strong>But my inclination is that this supports my thesis that FILE!'s true purpose in life is as the signal for implicit ports <em>(and whatever use you want in your dialects, though more often than not probably relating to files)</em>.</strong></p>
<p>I don't know what's so special about a language that just has one more "flavor" of string, that just acts like a string.  That's weak magic.  But implicit ports are stronger magic.</p>
<p><em><strong>We can actually cook that magic into the evaluator...</strong></em> so that if a function takes PORT! but does not take FILE!, the call itself does the coercion to do the OPEN and then the CLOSE when that particular function call is over.</p>
<p>This would mean taking FILE! and URL! out of the ANY-STRING! category.  As <a class="mention" href="/u/blackattr">@BlackATTR</a> suggests, we'd want JOIN to still work as expected...e.g. it would not try to "join the contents of files together".</p>
<p>I'm kind of getting certain about this as the true way.  I also think that the true way may be immutability of these strings, so that URL!s in particular can have a moment of validation after which they are not allowed to be twisted into going "bad".</p>
<p><em>(I'll also point out that this gives FILE! a bit more of a legitimacy for owning the term FILE!...as opposed to FILENAME!.  Because it really does turn into a case where it is a stand-in for the file itself.)</em></p>
<h2>Lots of Questions to Answer, Though...</h2>
<pre><code>write %file1.txt %file2.txt
</code></pre>
<p>What did you mean there?  did you mean:</p>
<pre><code>port1: open %file1.txt
port2: open %file2.txt
write port1 read port2
close port2
close port1
</code></pre>
<p>It might seem you can do so easily enough like this:</p>
<pre><code>write %file1.txt read %file2.txt
</code></pre>
<p>But that misses an opportunity for a <em>streaming</em> mechanism inside of write. You'd have to READ the entire contents of file2 before the write even got a chance to start, and if it was 100mb file then you'd have to read all 100mb into memory.</p>
<p>There'd be the <em>opportunity</em> with the syntax of <strong><code>write %file.txt %file2.txt</code></strong> to make the decision to use a streaming implementation, since it's leaving the decisions until later.</p>
<p>But maybe there's some other mechanics possible, like <strong><code>read %something.txt</code></strong> doesn't synchronously read the data, but creates a one-off port that knows to close when it's used.  And writing into a BINARY! of a variable counts as a "use".</p>
<p><img src="https://forum.rebol.info/images/emoji/twitter/thinking.png?v=9" title=":thinking:" class="emoji only-emoji" alt=":thinking:"></p>
<p>I don't know, but I'm making my intent known that I don't think FILE! and URL! are destined to remain in the ANY-STRING! category...</p>
          <p><a href="https://forum.rebol.info/t/parse-on-port-and-avoiding-generic-behavior-w-r-t-any-series/1276/14">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/parse-on-port-and-avoiding-generic-behavior-w-r-t-any-series/1276/14</link>
        <pubDate>Mon, 30 Aug 2021 02:26:53 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1276-14</guid>
        <source url="https://forum.rebol.info/t/parse-on-port-and-avoiding-generic-behavior-w-r-t-any-series/1276.rss">PARSE on PORT! and avoiding generic behavior w.r.t. ANY-SERIES!</source>
      </item>
      <item>
        <title>PARSE on PORT! and avoiding generic behavior w.r.t. ANY-SERIES!</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-post="1" data-topic="1276">
<div class="title">
<div class="quote-controls"></div>
<img alt width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>This ties into what I think should be a very restrained tendency to use ANY-STRING! types in ways that make them equivalent to the behavior on TEXT!.</p>
</blockquote>
</aside>
<p>I wanted to point out two things.</p>
<p>One is something Red did, which is to <a href="https://github.com/metaeducation/rebol-issues/issues/1262#issuecomment-489451278" rel="nofollow noopener">make the CHECKSUM function accept FILE!</a>.  Ultimately one would hope this would use a PORT! and streaming method to checksum a very large file and not read it all into memory.</p>
<p>(I've mentioned that by using the mbedTLS functions, we have streaming abilities in the ciphers and hashes themselves.  It's just a matter of wiring that up to some kind of progressive streaming PORT! model for the ciphers and hashes that needs to be figured out.)</p>
<p>This is a good example of a case where it is likely more useful to do this than to get the hash of the UTF-8 filename...even though both are potential usages.  But the parallels to the PARSE case come up... what if you get in the habit of passing string variables, and then one day the string you pass is in the form of a FILE!, and it is obscured behind the <strong>checksum var</strong>?  Is it bad to have it non-obvious that files were opened in the process?</p>
<p>The second thing I wanted to mention is that I did encounter a case of wanting to PARSE a FILE! and I felt in doing so that it was useful to not have to convert it to a string first.  So there's a bit of ambivalence here.  I just wanted to mention these things and keep the topic open.</p>
          <p><a href="https://forum.rebol.info/t/parse-on-port-and-avoiding-generic-behavior-w-r-t-any-series/1276/13">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/parse-on-port-and-avoiding-generic-behavior-w-r-t-any-series/1276/13</link>
        <pubDate>Thu, 23 Jul 2020 17:26:04 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1276-13</guid>
        <source url="https://forum.rebol.info/t/parse-on-port-and-avoiding-generic-behavior-w-r-t-any-series/1276.rss">PARSE on PORT! and avoiding generic behavior w.r.t. ANY-SERIES!</source>
      </item>
      <item>
        <title>PARSE on PORT! and avoiding generic behavior w.r.t. ANY-SERIES!</title>
        <dc:creator><![CDATA[BlackATTR]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-post="11" data-topic="1276">
<div class="title">
<div class="quote-controls"></div>
<img alt width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>There might be something that GET-GROUP! could help with there, e.g. <strong>:(my-url)</strong> could act as <strong><code>:http://example.com/whats/in/my-url</code></strong> .</p>
</blockquote>
</aside>
<p>Yes, my reply is a tangent from your original topic. I was talking more about code-golf stuff, since there isn't much you can do with a URL! or a FILE! <em>except</em> READ, WRITE or simply RENAME its handle (which is a superficial property/metadata of the data). The majority of the time you're going to READ the file, and often the READ just adds line noise -- the READ isn't the interesting thing you do with the FILE!, the interesting thing is whatever you do after the obligitory READ. Anyway, the GET-GROUP! is a viable pathway for this very low priority idea.</p>
          <p><a href="https://forum.rebol.info/t/parse-on-port-and-avoiding-generic-behavior-w-r-t-any-series/1276/12">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/parse-on-port-and-avoiding-generic-behavior-w-r-t-any-series/1276/12</link>
        <pubDate>Thu, 18 Jun 2020 01:15:21 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1276-12</guid>
        <source url="https://forum.rebol.info/t/parse-on-port-and-avoiding-generic-behavior-w-r-t-any-series/1276.rss">PARSE on PORT! and avoiding generic behavior w.r.t. ANY-SERIES!</source>
      </item>
      <item>
        <title>PARSE on PORT! and avoiding generic behavior w.r.t. ANY-SERIES!</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-post="9" data-topic="1276">
<div class="title">
<div class="quote-controls"></div>
<img alt width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/blackattr/40/204_2.png" class="avatar"> BlackATTR:</div>
<blockquote>
<p>Just some ideas drifting from the hazy smoke of my crack pipe. I had been thinking of a ::word notation as a kind of first derivative, where you might be able to GET the value of a reference from deeper than one level away, in the way that generalized QUOTING "protects" values at several levels.</p>
</blockquote>
</aside>
<p><a href="https://www.youtube.com/watch?v=iU7MEbOVXbs" rel="nofollow noopener">"Mmm, this is some good crack!"</a></p>
<p>The idea there being a GET-URL! that acts like <strong>read url</strong> isn't necessarily that crazy.  I've looked at similar concepts with <strong>append data :[some items]</strong> acting like <strong>append data reduce [some items]</strong>, e.g. another way of saying <strong>repend data [some items]</strong>.</p>
<p>But for instance: when you look at that being a general replacement for REPEND, you run into the problem of that when the block is in a variable.  <strong>:my-block</strong> gets a BLOCK! from a WORD!... not operate on the block itself.  Similar problems would happen with abstraction of the URL! via variable.</p>
<p>There might be something that GET-GROUP! could help with there, e.g. <strong>:(my-url)</strong> could act as <strong><code>:http://example.com/whats/in/my-url</code></strong>.</p>
<p>But I prefer the emphasis on language mechanics instead of lexical complexity.  I think I would like PARSE on a URL! to not parse the characters of the URL but interpret it as a port.  Maybe that's not the out of the box behavior, but if you want it you just say:</p>
<pre><code> parse: enclose 'lib/parse func [f] [
     let port: null
     if url? f/data [
         f/data: port: open f/data
     ]
     do f
     elide if port [close port]
 ]
</code></pre>
<p>Which isn't something you couldn't do in historical Rebol, though the idea is that the inheritance from the original function saves you on rewriting the interface...and has the potential to be more efficient (in theory).</p>
<p><strong>Anyway... I think my original guidance remains valid... to not make string-based routines to just assume that ANY-STRING! all act the same because they can't think of anything original to do for them they wouldn't do for a plain TEXT!.</strong></p>
<p>It's similar to how I think historical DO was kind of a turkey for saying:</p>
<pre><code>&gt;&gt; do {print "Hello"}
Hello

&gt;&gt; do &lt;print "Hello"&gt;
== &lt;print "Hello"&gt;

&gt;&gt; do 1
== 1
</code></pre>
<p>With a limit of short words, there's a true un-interestingness when the "I don't know" space just gives back the original thing.  I can't think of many situations where such a polymorphism would be interesting (<em>"I don't know if I have a tag or a string or a URL! or an INTEGER!... but I'm going to just DO it anyway and the result is somehow meaningful"</em>).  What use case is that, unless it's DO at an understood operation for <em>finding the <strong>location</strong> containing the thing to DO</em>.</p>
<p>Whether the default behavior is to error and let people pick what fits, or if you fill in a nice default meaning is one of those open questions.</p>
          <p><a href="https://forum.rebol.info/t/parse-on-port-and-avoiding-generic-behavior-w-r-t-any-series/1276/11">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/parse-on-port-and-avoiding-generic-behavior-w-r-t-any-series/1276/11</link>
        <pubDate>Wed, 17 Jun 2020 21:19:52 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1276-11</guid>
        <source url="https://forum.rebol.info/t/parse-on-port-and-avoiding-generic-behavior-w-r-t-any-series/1276.rss">PARSE on PORT! and avoiding generic behavior w.r.t. ANY-SERIES!</source>
      </item>
      <item>
        <title>PARSE on PORT! and avoiding generic behavior w.r.t. ANY-SERIES!</title>
        <dc:creator><![CDATA[BlackATTR]]></dc:creator>
        <description><![CDATA[
            <p>I was assuming the common <strong>join</strong>/<strong>rejoin</strong> approach will continue to work for these operations.</p>
<p>I like the idea of parsing on a port, but I'm also not opposed to require a refinement, keyword or new notation-- although the latter is probably undesired.</p>
<p>On that last aside, for fun I'll throw out a <strong>half-baked</strong> thought:</p>
<p>What if there were a notation for TEXT!, URL! (and values which can be READ), something like the opposite of quoting, i.e. GET'ing:</p>
<p>:<a href="https://example.com" rel="nofollow noopener">https://example.com</a><br>
-- This acts like a WORD! value, where URL! as a unique handle (as all URL! and URI's are) by default does an implicit GET of the streamable bytes/input, e.g.,<br>
== {...<a href="http://Example.com" rel="nofollow noopener">Example.com</a> is provided by...}<br>
-- The antonym of this (for no apparent justification) could involve generalized quoting:<br>
'<a href="https://example.com" rel="nofollow noopener">https://example.com</a></p>
<p>and similar for:<br>
:%/c/files/foo.txt<br>
== {It was a dark and stormy night...}<br>
'%/c/files/foo.txt<br>
== '%/c/files/foo.txt</p>
<p>A related option could be to be able to implicitly QUERY a URL!, the way one might a FILE! today (or the way you used to be able to PROBE an EMAIL! value for user and host) where you'd get an object! back, e.g.,</p>
<blockquote>
<blockquote>
<p>foo: <a href="https://example.com" rel="nofollow noopener">https://example.com</a><br>
:foo<br>
==  <a href="https://example.com" rel="nofollow noopener">https://example.com</a></p>
</blockquote>
<blockquote>
<p>::foo<br>
== make object! [<br>
name: <a href="https://example.com" rel="nofollow noopener">https://example.com</a><br>
headers:..<br>
body:..<br>
size: 64897<br>
]</p>
</blockquote>
<blockquote>
<p>bar: ::foo<br>
== make object! ...</p>
</blockquote>
<blockquote>
<p>bar/body<br>
== {<a href="http://Example.com" rel="nofollow noopener">Example.com</a> is provided by...}</p>
</blockquote>
<blockquote>
<p>bar/headers<br>
== {HTTP2.1... etc.}</p>
</blockquote>
<blockquote>
<p>foo<br>
== <a href="https://example.com" rel="nofollow noopener">https://example.com</a></p>
</blockquote>
</blockquote>
<p>Just some ideas drifting from the hazy smoke of my crack pipe. I had been thinking of a ::word notation as a kind of first derivative, where you might be able to GET the value of a reference from deeper than one level away, in the way that generalized QUOTING "protects" values at several levels.</p>
          <p><a href="https://forum.rebol.info/t/parse-on-port-and-avoiding-generic-behavior-w-r-t-any-series/1276/9">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/parse-on-port-and-avoiding-generic-behavior-w-r-t-any-series/1276/9</link>
        <pubDate>Tue, 09 Jun 2020 23:11:36 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1276-9</guid>
        <source url="https://forum.rebol.info/t/parse-on-port-and-avoiding-generic-behavior-w-r-t-any-series/1276.rss">PARSE on PORT! and avoiding generic behavior w.r.t. ANY-SERIES!</source>
      </item>
      <item>
        <title>PARSE on PORT! and avoiding generic behavior w.r.t. ANY-SERIES!</title>
        <dc:creator><![CDATA[rgchris]]></dc:creator>
        <description><![CDATA[
            <p>Couple of thoughts,</p>
<p>1/ I don't like <strong>THIS</strong>* convention, it looks a little slipshod. I'd rather see a core namespace apart from those types of functions: <strong>core/parse thing [the core way]</strong> — this way documentation/discovery for this class of function is consolidated.</p>
<p>2/ I quite often use PARSE on URL or FILE values. It's one of the perks of the language that they are first class string values.</p>
          <p><a href="https://forum.rebol.info/t/parse-on-port-and-avoiding-generic-behavior-w-r-t-any-series/1276/8">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/parse-on-port-and-avoiding-generic-behavior-w-r-t-any-series/1276/8</link>
        <pubDate>Mon, 08 Jun 2020 19:46:22 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1276-8</guid>
        <source url="https://forum.rebol.info/t/parse-on-port-and-avoiding-generic-behavior-w-r-t-any-series/1276.rss">PARSE on PORT! and avoiding generic behavior w.r.t. ANY-SERIES!</source>
      </item>
      <item>
        <title>PARSE on PORT! and avoiding generic behavior w.r.t. ANY-SERIES!</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>I've been thinking of extending the convention of <strong><code>FOO*</code></strong> being the "foundational tool" for those who want to forego convenience.  While <code>FOO</code> undecorated is the DWIM (Do What I Mean).</p>
<p>I think when most people say <strong><code>parse http://example.com [...]</code></strong> they aren't meaning to look for slashes and suss out the dots.</p>
<p>But perhaps if we offer both alternatives it will be better.  What if <strong><code>PARSE*</code></strong> is foundational and the rest layers above it?</p>
          <p><a href="https://forum.rebol.info/t/parse-on-port-and-avoiding-generic-behavior-w-r-t-any-series/1276/7">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/parse-on-port-and-avoiding-generic-behavior-w-r-t-any-series/1276/7</link>
        <pubDate>Mon, 08 Jun 2020 19:40:21 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1276-7</guid>
        <source url="https://forum.rebol.info/t/parse-on-port-and-avoiding-generic-behavior-w-r-t-any-series/1276.rss">PARSE on PORT! and avoiding generic behavior w.r.t. ANY-SERIES!</source>
      </item>
      <item>
        <title>PARSE on PORT! and avoiding generic behavior w.r.t. ANY-SERIES!</title>
        <dc:creator><![CDATA[rgchris]]></dc:creator>
        <description><![CDATA[
            <p>I agree with <a class="mention" href="/u/mark-hi">@Mark-hi</a>'s assessment. I'd also push back against assuming HTTP(S) scheme-based ports would behave the same way as FILE. Perhaps as it's configured now with its simple read mechanism, but it's more likely from a practical/durable standpoint that one would want the various components of an HTTP response: code/headers/content. It's more likely a scheme would determine whether derived PORT! values are parseable and how chunks—whether characters or values—are procured.</p>
<p>(it's perhaps conceivable that by default the HTTP scheme returns a block <strong><code>[status [integer!] headers [map! or block!] content [binary!]]</code></strong> or <strong><code>[error [error!]]</code></strong> if no connection was established)</p>
<p>If TCP ports were parseable, how would PARSE behave if there were any kind of lag in the response?</p>
          <p><a href="https://forum.rebol.info/t/parse-on-port-and-avoiding-generic-behavior-w-r-t-any-series/1276/6">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/parse-on-port-and-avoiding-generic-behavior-w-r-t-any-series/1276/6</link>
        <pubDate>Mon, 08 Jun 2020 19:32:17 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1276-6</guid>
        <source url="https://forum.rebol.info/t/parse-on-port-and-avoiding-generic-behavior-w-r-t-any-series/1276.rss">PARSE on PORT! and avoiding generic behavior w.r.t. ANY-SERIES!</source>
      </item>
      <item>
        <title>PARSE on PORT! and avoiding generic behavior w.r.t. ANY-SERIES!</title>
        <dc:creator><![CDATA[IngoHohmann]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-post="2" data-topic="1276">
<div class="title">
<div class="quote-controls"></div>
<img alt width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/mark-hi/40/212_2.png" class="avatar"> Mark-hi:</div>
<blockquote>
<p>In fact I even disapprove of DO of a TAG! acting like DO of the contents of the (file? url? which one?) whose name is the string contents of the tag (and whose directory or base url is where exactly?).</p>
</blockquote>
</aside>
<p>You are right, that this feature is somewhat "special", and it would be better, if it were easier to verfy the lookup table. And at the same time  I actually like this shortcut, and it would be great if you could add your own personal links to it.</p>
          <p><a href="https://forum.rebol.info/t/parse-on-port-and-avoiding-generic-behavior-w-r-t-any-series/1276/5">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/parse-on-port-and-avoiding-generic-behavior-w-r-t-any-series/1276/5</link>
        <pubDate>Mon, 25 May 2020 08:31:51 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1276-5</guid>
        <source url="https://forum.rebol.info/t/parse-on-port-and-avoiding-generic-behavior-w-r-t-any-series/1276.rss">PARSE on PORT! and avoiding generic behavior w.r.t. ANY-SERIES!</source>
      </item>
      <item>
        <title>PARSE on PORT! and avoiding generic behavior w.r.t. ANY-SERIES!</title>
        <dc:creator><![CDATA[BlackATTR]]></dc:creator>
        <description><![CDATA[
            <p>This sounds pretty amazing to me, esp the part about managing files larger than available memory.</p>
          <p><a href="https://forum.rebol.info/t/parse-on-port-and-avoiding-generic-behavior-w-r-t-any-series/1276/4">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/parse-on-port-and-avoiding-generic-behavior-w-r-t-any-series/1276/4</link>
        <pubDate>Sun, 26 Apr 2020 17:23:51 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1276-4</guid>
        <source url="https://forum.rebol.info/t/parse-on-port-and-avoiding-generic-behavior-w-r-t-any-series/1276.rss">PARSE on PORT! and avoiding generic behavior w.r.t. ANY-SERIES!</source>
      </item>
      <item>
        <title>PARSE on PORT! and avoiding generic behavior w.r.t. ANY-SERIES!</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-post="2" data-topic="1276">
<div class="title">
<div class="quote-controls"></div>
<img alt width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/mark-hi/40/212_2.png" class="avatar"> Mark-hi:</div>
<blockquote>
<p>I would be against being forced to write <strong>myfilename: as file! append as text! %abc as text! %.txt</strong></p>
</blockquote>
</aside>
<p>If things like <strong>to file! :[base %.txt]</strong> "just worked" like you had written <strong>as file! unspaced [base %.txt]</strong>, we might look at things differently.  Life wouldn't have to be as miserable as the worst case you give.  So we should be a bit circumspect.</p>
<p>It seems desirable to want <strong>append %my-file.txt {Some text}</strong> to write to the file instead of give you <strong>%"my-file.txtSome text"</strong>.  I've pointed out before that PORT! itself faces ambiguity in its dual-life as an ANY-CONTEXT!...and APPEND is a good example.  APPEND to an OBJECT! would add fields in SET-WORD! and data pairs... while APPEND to a PORT! re-triggered as WRITE/APPEND.  Which behaviors qualify for subversion of the underlying type, and which do not?</p>
<p>I don't know what the full answer is...I just don't want to leave the most interesting behaviors off the table to preserve a kind of trivial mechanical consistency.  Though I am a huge fan of mechanical consistency--it's just a matter of where you establish that firm ground.</p>
<aside class="quote no-group" data-post="2" data-topic="1276">
<div class="title">
<div class="quote-controls"></div>
<img alt width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/mark-hi/40/212_2.png" class="avatar"> Mark-hi:</div>
<blockquote>
<p>What if there are other ways of operating on PORT! contents besides parse? Do we add their parameters to the PORT! object? No.</p>
</blockquote>
</aside>
<p>It does make sense to me that if I'm going to make successive calls to PARSE on a PORT! that the persistence of those settings be something on the port <em>if</em> they are not applicable to a parse of a string in memory.</p>
<p>I would offer http headers as an example of a sort of labeling protocol ecology (in fact it's an ecology that PORT! might do well to inherit from or be compatible with).</p>
<p>I've already suggested that if you say <strong>read myport://something</strong> that it run a generic process regardless of port type spiritually akin to:</p>
<pre><code>p: open myport://something
append p/headers [num-reads-to-come: 1]
data: read p
close p
data
</code></pre>
<p>How many reads are to come might default to <code>unknown</code> in order to inform a keepalive on a TCP connection, and other ports might ignore it altogether.  But it would be there to draw from.</p>
<p>It's not just network connections that could have this kind of meta information, and I see no reason why it couldn't be there to draw from for specific clients like PARSE.</p>
          <p><a href="https://forum.rebol.info/t/parse-on-port-and-avoiding-generic-behavior-w-r-t-any-series/1276/3">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/parse-on-port-and-avoiding-generic-behavior-w-r-t-any-series/1276/3</link>
        <pubDate>Sun, 26 Apr 2020 13:30:33 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1276-3</guid>
        <source url="https://forum.rebol.info/t/parse-on-port-and-avoiding-generic-behavior-w-r-t-any-series/1276.rss">PARSE on PORT! and avoiding generic behavior w.r.t. ANY-SERIES!</source>
      </item>
      <item>
        <title>PARSE on PORT! and avoiding generic behavior w.r.t. ANY-SERIES!</title>
        <dc:creator><![CDATA[Mark-hi]]></dc:creator>
        <description><![CDATA[
            <p>But we still need to modify URL!s and FILE!s et cetera without modifying the contents they would point to if they were opened as ports. In other words, I would be against being forced to write <strong>myfilename: as file! append as text! %abc as text! %.txt</strong> in order to create a new FILE! value by appending one old one to another. There's a slippery slope when you treat a string as if its value is the string contents returned by some routine that interprets it.</p>
<p>In my view the need for parsing a PORT! (which I agree is a genuine need) should be met by a routine designed for it, something like say PARSE-CONTENTS, and refinements to it are where the chunk-size parameters and such-like belong, not cluttering up the PORT! object itself. What if there are other ways of operating on PORT! contents besides parse? Do we add their parameters to the PORT! object? No.</p>
<p>In fact I even disapprove of DO of a TAG! acting like DO of the contents of the (file? url? which one?) whose name is the string contents of the tag (and whose directory or base url is where exactly?). It should be DO-CONTENTS, with (exclusive, and possibly in some fashion semi-permanent, needs more thought) BASE and DIR refinements. But at least in that case there is no prior functionality that is being usurped, so I have kept my big mouth shut about it until now.</p>
          <p><a href="https://forum.rebol.info/t/parse-on-port-and-avoiding-generic-behavior-w-r-t-any-series/1276/2">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/parse-on-port-and-avoiding-generic-behavior-w-r-t-any-series/1276/2</link>
        <pubDate>Sun, 26 Apr 2020 01:02:40 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1276-2</guid>
        <source url="https://forum.rebol.info/t/parse-on-port-and-avoiding-generic-behavior-w-r-t-any-series/1276.rss">PARSE on PORT! and avoiding generic behavior w.r.t. ANY-SERIES!</source>
      </item>
      <item>
        <title>PARSE on PORT! and avoiding generic behavior w.r.t. ANY-SERIES!</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>If you look at Rebol2, R3-Alpha, and Red they all do the same thing with FILE! that they would with text (STRING!) when you pass as the first argument to PARSE:</p>
<pre><code>rebol2&gt;&gt; parse %aaa.txt [some "a" ".txt"]
== true

r3-alpha&gt;&gt; parse %aaa.txt [some "a" ".txt"]
== true

red&gt;&gt; parse %aaa.txt [some "a" ".txt"]
== true
</code></pre>
<p>I've always had the ambition that you be able to PARSE a PORT!.  If that's possible, it seems that you should be able to shortcut actually opening and closing the port yourself by saying something like:</p>
<pre><code>parse %some-200-megabyte-file.txt [
     some "a" end (print "Your giant file was all the letter A")
]

parse http://example.com/some-net-data/ [
    thru &lt;title&gt; copy title to &lt;/title&gt; (print ["Title was" title])
]
</code></pre>
<p>The vision would be that PARSE would assume when you gave it a FILE! or URL! that you meant to operate on that as a PORT!...opening it, parsing it, and closing it.  If you gave it a regular PORT! it would assume you would take care of closing it yourself.</p>
<p>Furthermore, it would be efficient so that it didn't need to load all of it into memory at once.  (There could be some heuristic on a "chunk size" it picked automatically, paging in only as much of the file as it needed at a time.  But you could perhaps tweak that manually by opening the port yourself and doing some settings.  This seems to be a property of the PORT! and not of PARSE, though there may be PARSE-specific settings.  Perhaps those settings would be looked for on the port itself as an extensible set of headers, vs. being some strange refinement you'd pass.)</p>
<p>In any case, the appeal of having that work for FILE! and URL! certainly seems to suggest that it's a much better use of the type variety than as a synonym for:</p>
<pre><code>&gt;&gt; did parse as text! %aaa.txt [some "a" ".txt" end]
== #[true]
</code></pre>
<p>There's clear need for PARSE to run on TEXT!, BINARY!, and BLOCK! input.  I'm not sure how this applies to INTO.  There also might be a <strong>parse/only</strong> (or <strong>parse/into</strong>? which would be type-preserving?)</p>
<h2>Not just for PARSE: a General Philosophy of ANY-SERIES!</h2>
<p>This ties into what I think should be a very restrained tendency to use ANY-STRING! types in ways that make them equivalent to the behavior on TEXT!.</p>
<p>I've said similar things about why <strong>type of first ['''a]</strong> should not be conflated with plain WORD!.  There should be a default of discernment; leaving the room open for distinct meanings.</p>
<p>So be on the lookout for cases where a datatype is being underused, even if it's not able to do the ideal magic today.  Seeing PARSE run on PORT! is a pretty big wishlist item for me, so maybe it's not impossible that it could happen... (!)</p>
          <p><a href="https://forum.rebol.info/t/parse-on-port-and-avoiding-generic-behavior-w-r-t-any-series/1276/1">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/parse-on-port-and-avoiding-generic-behavior-w-r-t-any-series/1276/1</link>
        <pubDate>Sun, 26 Apr 2020 00:26:48 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1276-1</guid>
        <source url="https://forum.rebol.info/t/parse-on-port-and-avoiding-generic-behavior-w-r-t-any-series/1276.rss">PARSE on PORT! and avoiding generic behavior w.r.t. ANY-SERIES!</source>
      </item>
  </channel>
</rss>
