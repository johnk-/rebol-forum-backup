<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>BrianH&#39;s Philosophy of Compatibility, circa March 2013</title>
    <link>https://forum.rebol.info/t/brianhs-philosophy-of-compatibility-circa-march-2013/580</link>
    <description>In 2013 there was a bug about a narrow question about FOR semantics in CureCode.  Today I want to fix the bug, and cite the issue.  But the discussion got really complicated and intertwined with alternate proposals, so it&#39;s unusually hard to read.

The biggest offender who made that thread hard to read is *me* :unamused: ... where I dodged the subject of the post entirely and just said (basically) *&quot;who cares, FOR sucks, let&#39;s talk about something else&quot;*.  Ladislav more concretely engaged the topic of the issue with a specific proposal and its ramifications.  By comparison, it&#39;s much more on topic.

What I said prompted Gregg to ask:

&gt; **Author:** Gregg Irwin
&gt; **Date:** `12-Mar-2013 23:41`
&gt;
&gt; Brian(H), just asking, is there a doc somewhere about what we are and aren&#39;t willing to break in R3? I know FOR is probably used by a lot of people, no matter how much we&#39;ve discouraged it, but it may be worth breaking if we can make things much better going forward.

To which BrianH wrote this reply, that Gregg suggested be put in a wiki.  I&#39;m deleting it there and moving it here, so there is some chance at actually reading what the issue is about!!!  The original thread is preserved [on the Internet Archive](https://web.archive.org/web/20180323160404/https://www.curecode.org/rebol3/ticket.rsp?id=1993)

&gt; **Author:** Brian Hawley
&gt; **Date:** `13-Mar-2013 01:04`
&gt;
&gt; The policy is mostly documented in the many places where I&#39;ve mentioned the policy in CC, so many I don&#39;t even have a count. It was set by Carl back at the beginning, so he might have written a blog about it, I don&#39;t remember.
&gt;
&gt; The basic themes are in [#666](https://github.com/rebol/rebol-issues/issues/666) and [#667](https://github.com/rebol/rebol-issues/issues/667). Overall, it&#39;s a matter of having to justify breaking things, and in many cases we can, especially when the old function was so broken that noone really uses it ([#1973](https://github.com/rebol/rebol-issues/issues/1973) for instance, [#1972](https://github.com/rebol/rebol-issues/issues/1972) maybe). In other cases, we change the name of the function when it was the name itself that was seriously broken ([#1971](https://github.com/rebol/rebol-issues/issues/1971)). In most cases though, we just fix the internal semantics so that the external API will pretty much work the same, but better (like this one). In just a few cases, the API of the old function was so broken or so tied into the old R2 system model that we just had to revamp it even knowing that things would break (LOAD is the only one that comes to mind, with too many tickets to even list in [#666](https://github.com/rebol/rebol-issues/issues/666)). We even try to keep the order of function options the same when we can so it doesn&#39;t break APPLY calls, though if we need to remove an option that becomes less important.
&gt;
&gt; Internal semantic changes are easier to justify than API changes, but only if they&#39;re improvements or fixes. Sometimes we have made some arguments take more or less types, to clean up their models - the rebalancing of none propagation, and the systemic binary conversions revamp, are good examples of those. In one case (issue!) we even changed the semantic model of a datatype from one type class to another, but it&#39;s possible to gloss over that quite a bit since those classes have more in common than they don&#39;t (it&#39;s on my todo list). In one notable case and likely a few more, we might want to revert a few changes or change them again better (at least before 3.0 when core semantics and naming of existing stuff gets standardized again).
&gt;
&gt; If you are replacing an old R2 function with a new one, you need to both justify adding the new function, and separately justify dropping the old. The only reason I&#39;ve seen so far for replacing a function with another function of the same name is if the old name was so bad that it was actively misleading, and we want to make sure the renaming sticks just for our developers&#39; benefit (the only instance I can recall is [#1972](https://github.com/rebol/rebol-issues/issues/1972), and even that might just result in removing those function names altogether). More often we just add a new function with a new name. And for the most part we only remove an old function altogether if it no longer makes sense in the new system model (AS-STRING and AS-BINARY), or is basically hostile in the new model (ALIAS).
&gt;
&gt; More often, legacy functions might become optional, exported from a module that you don&#39;t need to import if you don&#39;t want to. Modules are intended as the general answer to the question of &quot;Do you need it?&quot;, the answer generally being &quot;Yes, someone needs it, but maybe not by default, and maybe not built in.&quot;; modules are intended as the balance between /Command/View maximalists and /Base minimalists. All current functions are considered to be subject to that culling, especially if they&#39;re mezzanine, as long as they&#39;re not used to implement R3 itself.
&gt;
&gt; One thing that you need to consider though is that natives don&#39;t add any overhead to Rebol when they&#39;re not used. Mezzanines have to be loaded and initialized at startup time, but natives just sit there. You can even reassign their words if some native that you don&#39;t like gets exported, though you might want to check before changing them in lib if they&#39;re being used internally. DO operations aren&#39;t keywords (of DO at least), they&#39;re all pretty much optional. This isn&#39;t PARSE, remember. So it&#39;s hard to justify removing a native from Rebol altogether when people are already using it, since you really don&#39;t need to, and R3 being open source means that you can do whatever you like with your own builds.
&gt;
&gt; In the case of FOR, people actually use it when it makes sense to do so (like me, for instance). They didn&#39;t use it much in R2, but that wasn&#39;t because it was badly designed for its task, it was because it was badly implemented (slow and buggy). But even given that they still used it, which showed that there was some merit to its design. That suggests that we keep the API for the most part, fix the ugly parts of the semantics, and optimize the heck out of it so people will actually want to use it.
&gt;
&gt; And if someone wants to make an awesome dialected general loop, they&#39;ll have to give it a new name like EVERY, because FOR is taken by something that works. Or they can just make their own add-on module and name it whatever they like, their choice.</description>
    
    <lastBuildDate>Fri, 23 Mar 2018 17:16:45 +0000</lastBuildDate>
    <category>Philosophy</category>
    <atom:link href="https://forum.rebol.info/t/brianhs-philosophy-of-compatibility-circa-march-2013/580.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>BrianH&#39;s Philosophy of Compatibility, circa March 2013</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>In 2013 there was a bug about a narrow question about FOR semantics in CureCode.  Today I want to fix the bug, and cite the issue.  But the discussion got really complicated and intertwined with alternate proposals, so it's unusually hard to read.</p>
<p>The biggest offender who made that thread hard to read is <em>me</em> <img src="//forum.rebol.info/images/emoji/twitter/unamused.png?v=7" title=":unamused:" class="emoji" alt=":unamused:"> ... where I dodged the subject of the post entirely and just said (basically) <em>"who cares, FOR sucks, let's talk about something else"</em>.  Ladislav more concretely engaged the topic of the issue with a specific proposal and its ramifications.  By comparison, it's much more on topic.</p>
<p>What I said prompted Gregg to ask:</p>
<blockquote>
<p><strong>Author:</strong> Gregg Irwin<br>
<strong>Date:</strong> <code>12-Mar-2013 23:41</code></p>
<p>Brian(H), just asking, is there a doc somewhere about what we are and aren't willing to break in R3? I know FOR is probably used by a lot of people, no matter how much we've discouraged it, but it may be worth breaking if we can make things much better going forward.</p>
</blockquote>
<p>To which BrianH wrote this reply, that Gregg suggested be put in a wiki.  I'm deleting it there and moving it here, so there is some chance at actually reading what the issue is about!!!  The original thread is preserved <a href="https://web.archive.org/web/20180323160404/https://www.curecode.org/rebol3/ticket.rsp?id=1993" rel="nofollow noopener">on the Internet Archive</a></p>
<blockquote>
<p><strong>Author:</strong> Brian Hawley<br>
<strong>Date:</strong> <code>13-Mar-2013 01:04</code></p>
<p>The policy is mostly documented in the many places where I've mentioned the policy in CC, so many I don't even have a count. It was set by Carl back at the beginning, so he might have written a blog about it, I don't remember.</p>
<p>The basic themes are in <a href="https://github.com/rebol/rebol-issues/issues/666" rel="nofollow noopener">#666</a> and <a href="https://github.com/rebol/rebol-issues/issues/667" rel="nofollow noopener">#667</a>. Overall, it's a matter of having to justify breaking things, and in many cases we can, especially when the old function was so broken that noone really uses it (<a href="https://github.com/rebol/rebol-issues/issues/1973" rel="nofollow noopener">#1973</a> for instance, <a href="https://github.com/rebol/rebol-issues/issues/1972" rel="nofollow noopener">#1972</a> maybe). In other cases, we change the name of the function when it was the name itself that was seriously broken (<a href="https://github.com/rebol/rebol-issues/issues/1971" rel="nofollow noopener">#1971</a>). In most cases though, we just fix the internal semantics so that the external API will pretty much work the same, but better (like this one). In just a few cases, the API of the old function was so broken or so tied into the old R2 system model that we just had to revamp it even knowing that things would break (LOAD is the only one that comes to mind, with too many tickets to even list in <a href="https://github.com/rebol/rebol-issues/issues/666" rel="nofollow noopener">#666</a>). We even try to keep the order of function options the same when we can so it doesn't break APPLY calls, though if we need to remove an option that becomes less important.</p>
<p>Internal semantic changes are easier to justify than API changes, but only if they're improvements or fixes. Sometimes we have made some arguments take more or less types, to clean up their models - the rebalancing of none propagation, and the systemic binary conversions revamp, are good examples of those. In one case (issue!) we even changed the semantic model of a datatype from one type class to another, but it's possible to gloss over that quite a bit since those classes have more in common than they don't (it's on my todo list). In one notable case and likely a few more, we might want to revert a few changes or change them again better (at least before 3.0 when core semantics and naming of existing stuff gets standardized again).</p>
<p>If you are replacing an old R2 function with a new one, you need to both justify adding the new function, and separately justify dropping the old. The only reason I've seen so far for replacing a function with another function of the same name is if the old name was so bad that it was actively misleading, and we want to make sure the renaming sticks just for our developers' benefit (the only instance I can recall is <a href="https://github.com/rebol/rebol-issues/issues/1972" rel="nofollow noopener">#1972</a>, and even that might just result in removing those function names altogether). More often we just add a new function with a new name. And for the most part we only remove an old function altogether if it no longer makes sense in the new system model (AS-STRING and AS-BINARY), or is basically hostile in the new model (ALIAS).</p>
<p>More often, legacy functions might become optional, exported from a module that you don't need to import if you don't want to. Modules are intended as the general answer to the question of "Do you need it?", the answer generally being "Yes, someone needs it, but maybe not by default, and maybe not built in."; modules are intended as the balance between /Command/View maximalists and /Base minimalists. All current functions are considered to be subject to that culling, especially if they're mezzanine, as long as they're not used to implement R3 itself.</p>
<p>One thing that you need to consider though is that natives don't add any overhead to Rebol when they're not used. Mezzanines have to be loaded and initialized at startup time, but natives just sit there. You can even reassign their words if some native that you don't like gets exported, though you might want to check before changing them in lib if they're being used internally. DO operations aren't keywords (of DO at least), they're all pretty much optional. This isn't PARSE, remember. So it's hard to justify removing a native from Rebol altogether when people are already using it, since you really don't need to, and R3 being open source means that you can do whatever you like with your own builds.</p>
<p>In the case of FOR, people actually use it when it makes sense to do so (like me, for instance). They didn't use it much in R2, but that wasn't because it was badly designed for its task, it was because it was badly implemented (slow and buggy). But even given that they still used it, which showed that there was some merit to its design. That suggests that we keep the API for the most part, fix the ugly parts of the semantics, and optimize the heck out of it so people will actually want to use it.</p>
<p>And if someone wants to make an awesome dialected general loop, they'll have to give it a new name like EVERY, because FOR is taken by something that works. Or they can just make their own add-on module and name it whatever they like, their choice.</p>
</blockquote>
          <p><a href="https://forum.rebol.info/t/brianhs-philosophy-of-compatibility-circa-march-2013/580/1">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/brianhs-philosophy-of-compatibility-circa-march-2013/580/1</link>
        <pubDate>Fri, 23 Mar 2018 16:04:48 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-580-1</guid>
        <source url="https://forum.rebol.info/t/brianhs-philosophy-of-compatibility-circa-march-2013/580.rss">BrianH&#39;s Philosophy of Compatibility, circa March 2013</source>
      </item>
  </channel>
</rss>
