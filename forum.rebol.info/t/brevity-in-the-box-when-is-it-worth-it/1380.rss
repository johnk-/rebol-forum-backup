<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Brevity in the Box: When Is It Worth It?</title>
    <link>https://forum.rebol.info/t/brevity-in-the-box-when-is-it-worth-it/1380</link>
    <description>(cc: @razetime, please let me know if any of this makes sense, or if not what parts don&#39;t)

Now that I&#39;m again [revisiting Rebmu](https://forum.rebol.info/t/reviving-the-rebmu-dialect/1377), the familiar pattern of *&quot;hey wait, should this be a default language feature?&quot;* comes up again.

## A Simple Example Of The Pattern

Just imagine a shortcut for something like WHILE, where if you give it a WORD! as the condition, it acts as if you put the condition in a block:

     x: true
     while &#39;x [...]

That&#39;s shorter than **while [x] [...]**.  But to get it even shorter, while could *quote* its first argument.

     x: true
     while x [...]  ; doesn&#39;t eval X at callsite, so WHILE gets the WORD! itself

The downside to this is that if the condition is generated by code, you&#39;d have to escape the quoting somehow.  Otherwise **while reduce [some condition] [some body]** would be interpreted expecting REDUCE to be an arity-0 function called each time as the condition check.  Then, the **[some condition]** block would wind up in the body slot.  So `[some body]` would get inertly discarded as the next expression.

## This Is Harder To Teach

A new user has a tough time getting their head around the simple question of why IF can&#39;t have a BLOCK! around its condition, but WHILE requires one.  It takes a while to instill this &quot;obvious&quot; idea and convince people that it is a design feature vs. a bug.  *(@razetime - it would be a good idea to be able to write out--in your own words--why Rebol&#39;s IF doesn&#39;t take a BLOCK! as its condition, but WHILE needs it.)*

Though changing the convention would have its share of surprises, this isn&#39;t to say that the current behavior doesn&#39;t have its own confusing possibilities.  With evaluative conditions, you could leave the block off on accident and if it *incidentally* was a block, you could run something as code:

     data: [[print &quot;formatting hard drive&quot;] [print &quot;sorting MP3 collection&quot;]]

     x: first data
     while x [...]   ; imagine they meant to say `while [x] [...]`

You can still make mistakes under today&#39;s semantics, as the code above shows.  It can be argued that the mistake is more consistent, as the argument is simply being evaluated like that of APPEND or other primitives.  Though that consistency doesn&#39;t magically mean it&#39;s any less confusing.

## Might Quoting-but-Erroring Provide a Smooth Continuum?

Continuing to consider this example, we might imagine that it quotes the condition argument in the default implementation *but refuses to run anything but BLOCK! and GROUP!*  This would pave the way for compatibility with code that gave meaning to the quoted case.

     import &lt;core&gt;  ; imagine this is how you get the default definitions

     x: true
     while x [...]  ; !!! Error, WORD! not accepted as argument
     while &#39;x [...]  ; maybe this would be okay vs. `while [x]`, though?

Then if you did some kind of expert mode import, it would become more lax

     import &lt;core&gt;/lax   ; let&#39;s say you can provide switches to IMPORT

     x: true
     while x [...]  ; let&#39;s say lax meant this acts as `while [x]`

This might be reasonable.  And it may provide an answer to the issues I bring up in [&quot;Speaking with Tics&quot;](https://forum.rebol.info/t/speaking-with-tics-should-quoted-arguments-always-be-apostrophed/1359).  Maybe a strict mode makes you say **for-each &#39;x [...]** and **&#39;type of x** and then there&#39;s a wholesale switch on arguments that lets you dodge quoting.

## Another Example: DOES

Today&#39;s DOES is actually taken from Rebmu, because it lets you avoid putting the body of the DOES in an outermost block:

     &gt;&gt; old-way: does [print &quot;Hello&quot;]
     &gt;&gt; old-way
     Hello

     &gt;&gt; new-way: does print &quot;Hello&quot;
     &gt;&gt; new-way
     Hello

I thought this was cool enough to adopt.  But this has that characteristic pattern of needing escaping when the body is generated from code:

     rebol2&gt;&gt; old-way: does reverse [&quot;Different&quot; print]  ; reversal is body
     rebol2&gt;&gt; old-way
     Different  ; printed

     &gt;&gt; new-way: does reverse [&quot;Different&quot; print]  ; specializes REVERSE
     &gt;&gt; new-way
     == [print &quot;Different&quot;]  ; block value, reversed each time
     &gt;&gt; new-way
     == [&quot;Different&quot; print]  ; it&#39;s the same block, so doubly-reversed now

     &gt;&gt; new-compatible: does :(reverse [&quot;Different&quot; print])  ; reversal as body
     &gt;&gt; new-compatible
     Different  ; printed

&gt; Note that the DOES handling for GROUP! isn&#39;t escaped so you have to use **:(reverse [&quot;Different&quot; print])**.  Whether we think this needs fixing or not depends on if we decide that **does (...)** has an interesting unique meaning, e.g. **does (elide print &quot;vanishes&quot;)** would be invisible while **does [elide print &quot;vanishes&quot;]** would be void.  In other words, **does (x)** is currently acting as **do &#39;(x)** would, while **does :(x)** is acting like **do x**.  I&#39;m not 100% sure either way right now.

*This feels like something positive to have in the box as a default, as opposed to just being a fringe Rebmu-ism.*  Especially because DOES lacks a RETURN statement, isn&#39;t it nice to be able to say:

     helper: does catch [
          if condition [throw 10]
          throw 20
     ]

     ; Compare with...

     helper: does [catch [
          if condition [throw 10]
          throw 20
     ]]

But notice the implication here gets to where DOES needs to be variadic.  The mechanic of doing something along the lines of [POINTFREE](https://forum.rebol.info/t/looking-into-a-usermode-pointfree/1236) for a parameter is something that&#39;s a pain to have to rewrite every time, and it means the argument is harder to fill with in FRAME!s with specializations.  That suggests it should probably be a parameter convention in its own right.  :-/

## How Far Should This Go?

Much like the points I raise in &quot;Speaking With Tics&quot; regarding shorthand, it&#39;s hard to say.

DOES is a pretty good poster child for the question.  A reasonable hedging strategy might be to reserve the right to make DOES be &quot;clever&quot; in the future by quoting its argument, but disallowing WORD!s for now.  So if you produce the thing-to-do with code, you have to put that code in a GET-GROUP! as **does :(...)**.

But I have mixed feelings about extending this approach places.  If you want to do some pre-binding on a function body, do you want to have to write:

     func [...] :(in some-context [
         ...
     ])

Or is it too &quot;Rebol-like&quot; to have these meta-coding experiments not need parentheses:

     func [...] in some-context [
         ...
     ]

Key to the question under debate is if it would be more common for people to want to write:

     func [...] case [
         ...
     ]

...insead of:

     func [...] [
         case [
             ...
         ]
     ]

**When Rebmu is considered, meta-coding is the rarer need, so that seems to favor optimizing out the brackets in the non-meta cases and paying for the group in the meta case.**  But clearly the mechanics get weird.  As an example, think about:

     func [x] if x [
         ...
     ]

For that to be equivalent to **func [x] [if x [...]]**, *the variadic expression needs to bind into the spec*.  So that X can&#39;t be specialized as whatever it was in the enclosing context.  So a magic parameter convention which was willing to specialize the body as an ACTION! couldn&#39;t be used, as it would need to be informed by the binding logic of FUNC itself.  This points to an advantage of getting things in blocks.

## Lowest Common Denominator In Box, Then Let Users Decide?

Imagine we say that a function body can be only two things, a BLOCK! or a GET-GROUP!.

That could be the standard that you encourage to work for any variant of FUNC/FUNCTION.  But beyond that, each module could pick its conventions...or even change conventions on an impromptu basis (per class, per function, or per scope-in-function even).

One convention might say:

    func [x] reverse [...]  =&gt;  func [x] :(reverse [...])   ; reversed block is body

Another convention might say:

    func [x] reverse [y]  =&gt;  func [x] [reverse [...]]   ; reverse upon invocation

Restricting to [...] and :(...) by default doesn&#39;t seem too terribly antagonistic.  The policy needs a name, something like ***&quot;the baseline block rule&quot;***.  Then focus on facilities for easily customizing local definitions of things like FUNC or WHILE to be more creative, instead of trying to prescribe the shape of that creativity in the natives themselves.

One advantage of a baseline block proposal is better learnability for new users.  Recall the example I gave up top about WHILE working &quot;incidentally&quot; because the value you forgot to put in a block turned out to just happen to evaluate to a block:

     data: [[print &quot;formatting hard drive&quot;] [print &quot;sorting MP3 collection&quot;]]

     x: first data
     while x [...]   ; imagine they meant to say `while [x] [...]`

But with baseline block, that&#39;d be an error.  They&#39;d have to clarify it as either **while [x]** or **while :(x)**.

Then we focus on figuring out how to make it easier and easier for people to bend this when they get new ideas.  Maybe **while 7 =&gt; (x q) [body]** signals something of interest to a budding language designer, and they want to build a detection pattern for INTEGER! =&gt; GROUP! that applies in while conditions only... but they&#39;d like all their normal whiles to keep working.  :man_shrugging:

This way, the golfing adaptations become just a sample of the kinds of adaptations you might choose.  And if you liked the Rebmu choices at a conceptual level, you could import those without having to also adopt all the short names as well.</description>
    
    <lastBuildDate>Mon, 02 Nov 2020 07:44:24 +0000</lastBuildDate>
    <category>Philosophy</category>
    <atom:link href="https://forum.rebol.info/t/brevity-in-the-box-when-is-it-worth-it/1380.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Brevity in the Box: When Is It Worth It?</title>
        <dc:creator><![CDATA[iArnold]]></dc:creator>
        <description><![CDATA[
            <p>In the beginning it was hard to grasp why WHILE had a block instead of just a condition or conditions, but it is a feature, because the block! will be evaluated which makes more complex things possible.<br>
Having the WORD! as an alternative would be confusing, but only at first as are many things Rebol. (And that is NOT a BADTHING!)</p>
          <p><a href="https://forum.rebol.info/t/brevity-in-the-box-when-is-it-worth-it/1380/2">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/brevity-in-the-box-when-is-it-worth-it/1380/2</link>
        <pubDate>Mon, 02 Nov 2020 07:44:24 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1380-2</guid>
        <source url="https://forum.rebol.info/t/brevity-in-the-box-when-is-it-worth-it/1380.rss">Brevity in the Box: When Is It Worth It?</source>
      </item>
      <item>
        <title>Brevity in the Box: When Is It Worth It?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>(cc: <a class="mention" href="/u/razetime">@razetime</a>, please let me know if any of this makes sense, or if not what parts don't)</p>
<p>Now that I'm again <a href="https://forum.rebol.info/t/reviving-the-rebmu-dialect/1377">revisiting Rebmu</a>, the familiar pattern of <em>"hey wait, should this be a default language feature?"</em> comes up again.</p>
<h2>A Simple Example Of The Pattern</h2>
<p>Just imagine a shortcut for something like WHILE, where if you give it a WORD! as the condition, it acts as if you put the condition in a block:</p>
<pre><code> x: true
 while 'x [...]
</code></pre>
<p>That's shorter than <strong>while [x] [...]</strong>.  But to get it even shorter, while could <em>quote</em> its first argument.</p>
<pre><code> x: true
 while x [...]  ; doesn't eval X at callsite, so WHILE gets the WORD! itself
</code></pre>
<p>The downside to this is that if the condition is generated by code, you'd have to escape the quoting somehow.  Otherwise <strong>while reduce [some condition] [some body]</strong> would be interpreted expecting REDUCE to be an arity-0 function called each time as the condition check.  Then, the <strong>[some condition]</strong> block would wind up in the body slot.  So <code>[some body]</code> would get inertly discarded as the next expression.</p>
<h2>This Is Harder To Teach</h2>
<p>A new user has a tough time getting their head around the simple question of why IF can't have a BLOCK! around its condition, but WHILE requires one.  It takes a while to instill this "obvious" idea and convince people that it is a design feature vs. a bug.  <em>(<a class="mention" href="/u/razetime">@razetime</a> - it would be a good idea to be able to write out--in your own words--why Rebol's IF doesn't take a BLOCK! as its condition, but WHILE needs it.)</em></p>
<p>Though changing the convention would have its share of surprises, this isn't to say that the current behavior doesn't have its own confusing possibilities.  With evaluative conditions, you could leave the block off on accident and if it <em>incidentally</em> was a block, you could run something as code:</p>
<pre><code> data: [[print "formatting hard drive"] [print "sorting MP3 collection"]]

 x: first data
 while x [...]   ; imagine they meant to say `while [x] [...]`
</code></pre>
<p>You can still make mistakes under today's semantics, as the code above shows.  It can be argued that the mistake is more consistent, as the argument is simply being evaluated like that of APPEND or other primitives.  Though that consistency doesn't magically mean it's any less confusing.</p>
<h2>Might Quoting-but-Erroring Provide a Smooth Continuum?</h2>
<p>Continuing to consider this example, we might imagine that it quotes the condition argument in the default implementation <em>but refuses to run anything but BLOCK! and GROUP!</em>  This would pave the way for compatibility with code that gave meaning to the quoted case.</p>
<pre><code> import &lt;core&gt;  ; imagine this is how you get the default definitions

 x: true
 while x [...]  ; !!! Error, WORD! not accepted as argument
 while 'x [...]  ; maybe this would be okay vs. `while [x]`, though?
</code></pre>
<p>Then if you did some kind of expert mode import, it would become more lax</p>
<pre><code> import &lt;core&gt;/lax   ; let's say you can provide switches to IMPORT

 x: true
 while x [...]  ; let's say lax meant this acts as `while [x]`
</code></pre>
<p>This might be reasonable.  And it may provide an answer to the issues I bring up in <a href="https://forum.rebol.info/t/speaking-with-tics-should-quoted-arguments-always-be-apostrophed/1359">"Speaking with Tics"</a>.  Maybe a strict mode makes you say <strong>for-each 'x [...]</strong> and <strong>'type of x</strong> and then there's a wholesale switch on arguments that lets you dodge quoting.</p>
<h2>Another Example: DOES</h2>
<p>Today's DOES is actually taken from Rebmu, because it lets you avoid putting the body of the DOES in an outermost block:</p>
<pre><code> &gt;&gt; old-way: does [print "Hello"]
 &gt;&gt; old-way
 Hello

 &gt;&gt; new-way: does print "Hello"
 &gt;&gt; new-way
 Hello
</code></pre>
<p>I thought this was cool enough to adopt.  But this has that characteristic pattern of needing escaping when the body is generated from code:</p>
<pre><code> rebol2&gt;&gt; old-way: does reverse ["Different" print]  ; reversal is body
 rebol2&gt;&gt; old-way
 Different  ; printed

 &gt;&gt; new-way: does reverse ["Different" print]  ; specializes REVERSE
 &gt;&gt; new-way
 == [print "Different"]  ; block value, reversed each time
 &gt;&gt; new-way
 == ["Different" print]  ; it's the same block, so doubly-reversed now

 &gt;&gt; new-compatible: does :(reverse ["Different" print])  ; reversal as body
 &gt;&gt; new-compatible
 Different  ; printed
</code></pre>
<blockquote>
<p>Note that the DOES handling for GROUP! isn't escaped so you have to use <strong>:(reverse ["Different" print])</strong>.  Whether we think this needs fixing or not depends on if we decide that <strong>does (...)</strong> has an interesting unique meaning, e.g. <strong>does (elide print "vanishes")</strong> would be invisible while <strong>does [elide print "vanishes"]</strong> would be void.  In other words, <strong>does (x)</strong> is currently acting as <strong>do '(x)</strong> would, while <strong>does :(x)</strong> is acting like <strong>do x</strong>.  I'm not 100% sure either way right now.</p>
</blockquote>
<p><em>This feels like something positive to have in the box as a default, as opposed to just being a fringe Rebmu-ism.</em>  Especially because DOES lacks a RETURN statement, isn't it nice to be able to say:</p>
<pre><code> helper: does catch [
      if condition [throw 10]
      throw 20
 ]

 ; Compare with...

 helper: does [catch [
      if condition [throw 10]
      throw 20
 ]]
</code></pre>
<p>But notice the implication here gets to where DOES needs to be variadic.  The mechanic of doing something along the lines of <a href="https://forum.rebol.info/t/looking-into-a-usermode-pointfree/1236">POINTFREE</a> for a parameter is something that's a pain to have to rewrite every time, and it means the argument is harder to fill with in FRAME!s with specializations.  That suggests it should probably be a parameter convention in its own right.  :-/</p>
<h2>How Far Should This Go?</h2>
<p>Much like the points I raise in "Speaking With Tics" regarding shorthand, it's hard to say.</p>
<p>DOES is a pretty good poster child for the question.  A reasonable hedging strategy might be to reserve the right to make DOES be "clever" in the future by quoting its argument, but disallowing WORD!s for now.  So if you produce the thing-to-do with code, you have to put that code in a GET-GROUP! as <strong>does :(...)</strong>.</p>
<p>But I have mixed feelings about extending this approach places.  If you want to do some pre-binding on a function body, do you want to have to write:</p>
<pre><code> func [...] :(in some-context [
     ...
 ])
</code></pre>
<p>Or is it too "Rebol-like" to have these meta-coding experiments not need parentheses:</p>
<pre><code> func [...] in some-context [
     ...
 ]
</code></pre>
<p>Key to the question under debate is if it would be more common for people to want to write:</p>
<pre><code> func [...] case [
     ...
 ]
</code></pre>
<p>...insead of:</p>
<pre><code> func [...] [
     case [
         ...
     ]
 ]
</code></pre>
<p><strong>When Rebmu is considered, meta-coding is the rarer need, so that seems to favor optimizing out the brackets in the non-meta cases and paying for the group in the meta case.</strong>  But clearly the mechanics get weird.  As an example, think about:</p>
<pre><code> func [x] if x [
     ...
 ]
</code></pre>
<p>For that to be equivalent to <strong>func [x] [if x [...]]</strong>, <em>the variadic expression needs to bind into the spec</em>.  So that X can't be specialized as whatever it was in the enclosing context.  So a magic parameter convention which was willing to specialize the body as an ACTION! couldn't be used, as it would need to be informed by the binding logic of FUNC itself.  This points to an advantage of getting things in blocks.</p>
<h2>Lowest Common Denominator In Box, Then Let Users Decide?</h2>
<p>Imagine we say that a function body can be only two things, a BLOCK! or a GET-GROUP!.</p>
<p>That could be the standard that you encourage to work for any variant of FUNC/FUNCTION.  But beyond that, each module could pick its conventions...or even change conventions on an impromptu basis (per class, per function, or per scope-in-function even).</p>
<p>One convention might say:</p>
<pre><code>func [x] reverse [...]  =&gt;  func [x] :(reverse [...])   ; reversed block is body
</code></pre>
<p>Another convention might say:</p>
<pre><code>func [x] reverse [y]  =&gt;  func [x] [reverse [...]]   ; reverse upon invocation
</code></pre>
<p>Restricting to [...] and :(...) by default doesn't seem too terribly antagonistic.  The policy needs a name, something like <em><strong>"the baseline block rule"</strong></em>.  Then focus on facilities for easily customizing local definitions of things like FUNC or WHILE to be more creative, instead of trying to prescribe the shape of that creativity in the natives themselves.</p>
<p>One advantage of a baseline block proposal is better learnability for new users.  Recall the example I gave up top about WHILE working "incidentally" because the value you forgot to put in a block turned out to just happen to evaluate to a block:</p>
<pre><code> data: [[print "formatting hard drive"] [print "sorting MP3 collection"]]

 x: first data
 while x [...]   ; imagine they meant to say `while [x] [...]`
</code></pre>
<p>But with baseline block, that'd be an error.  They'd have to clarify it as either <strong>while [x]</strong> or <strong>while :(x)</strong>.</p>
<p>Then we focus on figuring out how to make it easier and easier for people to bend this when they get new ideas.  Maybe <strong>while 7 =&gt; (x q) [body]</strong> signals something of interest to a budding language designer, and they want to build a detection pattern for INTEGER! =&gt; GROUP! that applies in while conditions only... but they'd like all their normal whiles to keep working.  <img src="https://forum.rebol.info/images/emoji/twitter/man_shrugging.png?v=9" title=":man_shrugging:" class="emoji" alt=":man_shrugging:"></p>
<p>This way, the golfing adaptations become just a sample of the kinds of adaptations you might choose.  And if you liked the Rebmu choices at a conceptual level, you could import those without having to also adopt all the short names as well.</p>
          <p><a href="https://forum.rebol.info/t/brevity-in-the-box-when-is-it-worth-it/1380/1">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/brevity-in-the-box-when-is-it-worth-it/1380/1</link>
        <pubDate>Mon, 02 Nov 2020 03:09:34 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1380-1</guid>
        <source url="https://forum.rebol.info/t/brevity-in-the-box-when-is-it-worth-it/1380.rss">Brevity in the Box: When Is It Worth It?</source>
      </item>
  </channel>
</rss>
