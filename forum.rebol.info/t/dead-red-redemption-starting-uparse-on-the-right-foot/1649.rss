<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Dead Red Redemption: Starting UPARSE on the Right Foot</title>
    <link>https://forum.rebol.info/t/dead-red-redemption-starting-uparse-on-the-right-foot/1649</link>
    <description>When UPARSE began it couldn&#39;t do much.  So it had one test file %uparse.test.reb, that grew as the number of combinators grew.

This &quot;one test file for all parse functions&quot; approach was all the Saphirion tests ever had.  And the ever-growing-file method is also used by the [Red parse tests](https://github.com/red/red/blob/master/tests/source/units/parse-test.red).

But UPARSE now aims higher: *each combinator gets its own test file*.  While some tests will not fit precisely into that--especially larger examples that use many features--it&#39;s a better general idea for most of the tests.

Hence you can see [all the nice files in the **`%tests/parse/`**](https://github.com/metaeducation/ren-c/tree/master/tests/parse) directory.  And now that UPARSE is capable enough, I&#39;ve even mined the R3-Alpha PARSE tests and sorted through them...adjusting them for UPARSE and making sure they work.

## And Red Is Finally Going to Be Sort Of Useful...

This morning I hacked up a converter to translate Red&#39;s rather verbose test format to the more spare Rebol test form.  At some point we&#39;ll be able to run Red&#39;s test suite directly &quot;via Redbol&quot;, but I just wanted to go through and mine their parse tests for anything useful...and have them translated into the UPARSE way of saying things.

So... **MEET [%PARSE-TESTS-FROM-RED.TEST.REB](https://github.com/metaeducation/ren-c/blob/414a51e4974dfaa5e18486bc69e8a2fc52588156/tests/parse/parse-tests-from-red.test.reb)**!

*(Note: Capture was done as of the last change to that file on Oct 16, 2020... [commit 32c30072ff215fd4efc0200ab3572ffd7afc8e9f](https://github.com/red/red/commit/32c30072ff215fd4efc0200ab3572ffd7afc8e9f#diff-aa7745d6b886ee41ee7e0ff66dfcbeb5412f86eb0be8bd47370e1e3ef244e089)...curious they haven&#39;t added any parse tests for a year...?)*

No small feat to go through those, but.  Here we are.  Most of them work--but BREAK and REJECT still need to be thought through as combinators.  So the tests that don&#39;t work are the ones that use those.  I&#39;m starting them out as a commit of one file just to show what was taken if there&#39;s any question about that.  But the next step is to break them out into the per-combinator files.

They licensed their tests BSD-3 which is [Apache-2 Compatible to include or extend](http://www.apache.org/legal/resolved.html#category-a).  Taking Apache-2 code back to BSD-3 isn&#39;t allowed by default.  But they have my permission to take whatever *tests* as BSD-3, if they care.  &lt;sub&gt;(They can in fact take any of my *ideas*.  Should they ever do so, then them merely knowing that their ideas don&#39;t work and mine do is plenty punishment for them.  But the non-test-*code* is LGPL...that includes the code for UPARSE and the web REPL.  Borrowing from that means being subject to the LGPL license.)&lt;/sub&gt;

Changes to remember are:

* UPARSE uses WHILE instead of ANY...and neither WHILE nor SOME have a progress requirement.  Use FURTHER if progress is mandated.

* SET-WORD! must be combined with `&lt;here&gt;` to capture a position, vs. that weird old behavior of set-word alone.  Seeking positions is done with the SEEK combinator, not a GET-WORD!.

* UPARSE replaces END with `&lt;end&gt;` and SKIP with `&lt;any&gt;`. I think these TAG! combinators are working out great...it&#39;s nice to have END free for a variable name...and it opens up the space for more nouns that are &quot;out of band&quot; from variable names.  Needing to say `&#39;&lt;tag&gt;` to actually match a tag is a small price to pay.

* General Ren-C renamings (string! =&gt; text!, number! =&gt; any-number!, none! =&gt; blank!), historical TRY is TRAP (with a much neater meaning for TRY)...

* Stopping an alternate match is just done with FALSE.  FAIL is reserved for the &quot;raise an error&quot; sense of failing, and by letting LOGIC! decide if the parse should go on or not we have a nice ability to use splicing rules like `:(condition = whatever)` to put a true to go on or a false to stop matching.

Thoughts follow.

## You Never Find Out If Red PARSE COLLECT fails

Once a COLLECT keyword is hit, your result will be an array.  It will contain whatever got collected up to the point of failure.

    red&gt;&gt; parse [1 2 3 &lt;bomb&gt;] [collect [some keep integer!] word!]
    == [1 2 3]

    red&gt;&gt; parse [1 2 3 &lt;bomb&gt;] [collect [some keep integer! word!]]
    == [1 2 3]

    red&gt;&gt; parse [1 2 3 &lt;bomb&gt; 4] [collect [some keep integer! word!]]
    == [1 2 3]

Ren-C&#39;s system lets you have your cake and eat it too... the COLLECT result can be the result and you can even elide matches outside:

    ren-c&gt;&gt; uparse [1 2 3 ta-da!] [collect [some keep integer!] elide word!]
    == [1 2 3]

    ren-c&gt;&gt; uparse [1 2 3 ta-da!] [collect [some keep integer!] word!]
    == ta-da!

    ren-c&gt;&gt; uparse [1 2 3 &lt;bomb&gt;] [collect [some keep integer!] word!]
    ; null

And of course you can always store rule results--any rule synthesized result--into a variable:

    ren-c&gt;&gt; uparse [1 2 3 ta-da!] [block: collect [some keep integer!] word!]
    == ta-da!

    ren-c&gt;&gt; block
    == [1 2 3]

Every option is on the table (except having rules you write as if they must match fail, and not tell you!)

## Red PARSE COLLECT/KEEP Is Wacky About Splicing

Here&#39;s a collect test that shows some nasty inconsistencies:

    red&gt;&gt; parse [a b b b] [collect [skip keep some &#39;b]]
    == [[b b b]]

First of all, that KEEP is keeping a BLOCK!.  We know that in ordinary COLLECT if you keep a block it will splice...but this PARSE KEEP is acting like a KEEP/ONLY.

Secondly, the **some &#39;b** rule is returning a BLOCK!.  But that&#39;s not what it does in general.  Try an assignment:

    red&gt;&gt; parse [a b b b] [skip set var some &#39;b]
    == true

    red&gt;&gt; var
    == b

So KEEP SOME &#39;B has a different logic for what SOME &#39;B synthesizes than SET SOME &#39;B.  :clown_face: 

Ren-C is consistent on both fronts.  KEEP will splice unless a value is QUOTED!.  SOME always synthesizes the value of its last rule unless you ask for a copy.  Currently that is done with ACROSS *(may name change to COPY after a settling period...the distinction is currently helpful)*

    ren-c&gt;&gt; uparse [a b b b] [collect [&lt;any&gt;, keep ^ across some &#39;b]]
    == [[b b b]]

    ren-c&gt;&gt; uparse [a b b b] [collect [&lt;any&gt;, keep across some &#39;b]]
    == [b b b]

    ren-c&gt;&gt; uparse [a b b b] [collect [&lt;any&gt;, keep ^ some &#39;b]]
    == [b]

You could have also written that as **keep ^[across some &#39;b]** for instance.  To please @rgchris we could add QUOTE as a UPARSE keyword so you could avoid the ^... it doesn&#39;t mean quite the same thing as META but makes some sense: &quot;keep this thing literally&quot;.  **keep quote across some &#39;b**.

**But...how do you splice in Red KEEP?**

If you guessed weird keyword pattern, you&#39;d be right. [KEEP PICK and KEEP COPY variants are explained (?) here](https://github.com/red/red/issues/2391#issuecomment-281655108):

    red&gt;&gt; parse [x -- ] [collect [keep to &#39;-- ]]
    == [x]
    red&gt;&gt; parse [x y -- ] [collect [keep to &#39;-- ]]
    == [[x y]]

    red&gt;&gt; parse [x -- ] [collect [keep pick to &#39;-- ]]
    == [x] 
    red&gt;&gt; parse [x y -- ] [collect [keep pick to &#39;-- ]]
    == [x y]

    red&gt;&gt; parse [x -- ] [collect [keep copy _ to &#39;-- ]]
    == [[x]]
    red&gt;&gt; parse [x y -- ] [collect [keep copy _ to &#39;-- ]]
    == [[x y]]

*(Sidenote: the use of the _ as a &quot;word that is thrown away&quot; shows that being forced to name arguments to COPY is a bad idea.  It&#39;s better as a combinator that synthesizes a result that may or may not be stored in a variable.)*

The best I can imagine is that this is an attempt to avoid generating large intermediate series. Since Red doesn&#39;t worry about &quot;rollback&quot; then if it wants to append things as it goes to the collecting array it can do so with this KEEP PICK.

It doesn&#39;t seem to even make any sense...the above suggests that KEEP PICK splices, but apparently not if the result comes from a GROUP! (??).   See [Red Issue #4198](https://github.com/red/red/issues/4198):

    red&gt;&gt; parse [][collect keep pick (&#39;a)]
    == [a]

    red&gt;&gt; parse [][collect keep pick ([a b])]
    == [[a b]]

Truly nutty.  UPARSE is going down a vastly more consistent/usable road.  But if rollback isn&#39;t a requirement there&#39;s no reason the append-with-no-intermediate-series behavior couldn&#39;t be mimic&#39;d in the UPARSE2 emulation.  Don&#39;t know who&#39;d want it, though.

## Explicit Advancement Requirement Is Good

These tests all infinite loop in UPARSE:

    uparse? [a a] [some [&#39;c | not &#39;b] 2 &lt;any&gt;]
    uparse? &quot;aa&quot; [some [#c | not #b] 2 &lt;any&gt;]
    uparse? &quot;bx&quot; [some [not &quot;b&quot; | &lt;any&gt;]]
    uparse? #{0A0A} [some [#&quot;^L&quot; | not #{0B}] 2 &lt;any&gt;]

And they&#39;re trickier than usual, because if you just change that to `some further` they won&#39;t work... because you&#39;re demanding rules like `further [&#39;c | not &#39;b]` make progress *some* number of times.

It&#39;s a really convoluted way of thinking of what you&#39;re doing here as *&quot;some number of matches... including a non-match that doesn&#39;t advance of &#39;b counting as at least one match.  So the SOME doesn&#39;t fail to match, -but- if it doesn&#39;t advance, even though the one time succeeded count it as a break of the iteration and yield success&quot;*.

Who wants to think like that?  It doesn&#39;t really make sense.  If you insist on using SOME you have to use an OPT and FURTHER:

    uparse? [a a] [opt some further [&#39;c | not &#39;b], 2 &lt;any&gt;]

But we have another name for OPT SOME which is WHILE:

    uparse? [a a] [while further [&#39;c | not &#39;b], 2 &lt;any&gt;]

Or write it more coherently by just testing for the NOT in sequence, vs inside the looped alternate:

    uparse? [a a] [while &#39;c, not &#39;b, 2 &lt;any&gt;]

I know it&#39;s just a test, but, I have a feeling that most of these &quot;infinite rules need to break&quot; rules have saner expressions...which makes for a more understandable SOME.  Red embraces the advancement rule on purpose; these tests represent &quot;fixes&quot; to what they consider bugs, e.g. [Red Issue #3927](https://github.com/red/red/issues/3927).

But I think requiring advancement fundamentally limits the perception of what PARSE can do.  It can be the control structure of an application or state machine... SOME and WHILE are loops.  You might want to re-run a rule so long as input is pending on a network port.  Especially with GROUP! rule splicing that can inject &quot;true&quot; or &quot;false&quot;, you can mix and match rules with imperative code... and having a successful rule decide it was &quot;too successful&quot; is just disruptive.

Having a good debugger someday *(it&#39;s always &quot;someday&quot;...? :-/)* will make it easy enough to find the infinite loops.

## We Don&#39;t Do /INTO... nor COLLECT INTO

Red is concerned about low level series optimization, even though Gregg has indicated he agrees with me that this is a bad thing to focus on:

https://forum.rebol.info/t/stopping-the-into-virus/705/1

Not going to rewrite that post here.  But I&#39;ll say the idea of being able to make series discontiguous in memory is an interesting one; kind of like how filesystems can split files into chunks.  It seems to me that if series could be &quot;chunked&quot; in this way at a system level, we could worry less about these /INTO matters.  I&#39;d rather look into that kind of answer vs. burdening users with /INTO.

So there&#39;s no COLLECT INTO pattern in UPARSE.  They also have a COLLECT AFTER which uses the position after the current series position instead of before the current series position to insert.  :-/  The need for these permutations just seems to further demonstrate what an awkward thing this is to build in.

Someone can put this stuff in Redbol&#39;s PARSE built on UPARSE with different combinators--if they really want it.  Don&#39;t think that will be me!

## Using Things as Non-Rules Consistently Requires GROUP!

In Red, this works:

    red&gt;&gt; parse blk: [] [insert 1]
    == true

    red&gt;&gt; blk
    == [1]

Why treat that 1 as a number, instead of as a rule?  Well, in Red&#39;s world a rule can&#39;t provide a value to insert...because rules (theoretically) don&#39;t synthesize values.  Of course that&#39;s a mixed bag, we see **keep some &quot;a&quot;** treating it as if **some &quot;a&quot;** made a value that could be worth keeping.  Why not a value worth inserting?

Ren-C takes a hard-line stance on this and says that a raw integer that&#39;s not inside a GROUP! is a match count for a rule.  So `[insert 1]` is malformed... you could say `[insert 1 &quot;a&quot;]` and then if it foudn a single &quot;a&quot; that would be what gets inserted:

     ren-c&gt;&gt; uparse? blk: [&quot;a&quot;] [insert 1 &quot;a&quot;, &lt;any&gt;]
     == #[true]

     ren-c&gt;&gt; blk
     == [&quot;a&quot; &quot;a&quot;]

So the rule matched the &quot;a&quot; that was in the block, inserted another one, and then skipped it to reach the end of the input.  But if you really want to keep a 1 synthesized out of thin air and not matched against any input, you need a GROUP!

    ren-c&gt;&gt; uparse? blk: [] [insert (1)]
    == #[true]

    ren-c&gt;&gt; blk
    == [1]

Unlike the constant questioning caused by living in the design ghetto, UPARSE is reliable and consistent.  :slight_smile: 

## Red&#39;s PARSE INSERT Is Either Arity-1 or Arity-2

As I show above, Red lets you do `insert 1`... which makes it look like INSERT takes a single argument.  That&#39;s the thing to insert.  You don&#39;t need to tell it what series or position, because it presumes you mean the current series at the parse position.

But weirdly enough, [you can provide a position as the first argument to insert as a word](https://github.com/red/red/issues/4153).  In this case it takes two parameters.

    &gt;&gt; parse (data: [a b c]) [
        pos-head:           ; capture head postion to variable
        to end              ; seek to end of series
        pos-tail:           ; capture tail position to variable
        insert pos-head 1   ; use arity-2 form of insert, arg 1 is where
    ]
    == true  ; parse position was moved past insertion to end

    &gt;&gt; data
    == [1 a b c]  ; data changed as expected

    &gt;&gt; pos-head
    == [1 a b c]  ; pos-head did not move to consistently point at a

    &gt;&gt; pos-tail  ; pos-tail also did not move, no longer tail
    == [c]

There&#39;s a little bit of this mechanism that would be hard to do yourself.  If you tried to save the parse position, do a SEEK to where you want to insert, then insert, and jump back to the parse position you saved... your parse position wouldn&#39;t take into account the size of the insertion.  So you&#39;d have to do something more like:

* Save the parse position
* Seek to where you want to insert
* Save the insertion position
* Do the insert
* If parse position was before insertion position, jump back to it, else
    * Save the after-insertion position
    * Count distance between after-insertion position and before insertion position
    * Seek to the saved parse position plus that distance

So this form of INSERT does that for you.  But as shown above, the only position that is getting adjusted in this way is your parse position...all other saved positions in the parse will have the wrong index.  This is just a general Rebol issue since it&#39;s nothing more than arrays and indices at heart.  :frowning: 

Here&#39;s an example weird Red test of this:

    red&gt;&gt; series: [a b c]
    red&gt;&gt; letters: [x y z]
    red&gt;&gt; parse series [
         mark: &#39;a insert mark letters insert only mark letters &#39;b &#39;c
     ]
    == true
    red&gt;&gt; series
    == [[x y z] x y z a b c]

Here&#39;s me rotely translating that parse rule according to my formula above:

    [
        mark: &lt;here&gt;
         &#39;a

        ; Try equivalent of Red&#39;s `insert mark letters`
        pos: &lt;here&gt;
        seek (mark)
        insert (letters)
        after: &lt;here&gt;
        seek (skip pos (index? after) - (index? mark))

        ; Try equivalent of Red&#39;s `insert only mark letters`
        pos: &lt;here&gt;
        seek (mark)
        insert ^(letters)
        after: &lt;here&gt;
        seek (skip pos (index? after) - (index? mark))

        &#39;b &#39;c
    ]

The mechanic isn&#39;t rocket science, but it&#39;s sure a pain to do by hand.  Another approach would be PUSH-POSITION and POP-POSITION operators, where the positions on the stack get updated for insertions.

CHANGE is weirder still, because if you pass it a position in the series it changes *between* the current parse position and what you pass it.

    red&gt;&gt; parse blk: [a b c 1 2 3] [
        mark:
        some word!
        change mark &quot;like so&quot;
        some integer!
    ]
    == true

    red&gt;&gt; blk
    == [&quot;like so&quot; 1 2 3]

Gabriele dropped mutating operators like CHANGE/INSERT/REMOVE from Topaz PARSE entirely.  They are troublemakers, for sure.  I&#39;ve kept an open mind but this is of course the kind of debacle you&#39;re going to have with them.

But no matter how this is dealt with, I don&#39;t think variable-arity INSERT is the right answer.  This needs more careful thought if mutations are going to be allowed.

## Weird Implicit KEEP on Nested COLLECT

This is the silly consequence of the fact that COLLECT doesn&#39;t really know where it&#39;s writing things when you don&#39;t use INTO.  It bubbles its result out the top of the parse if you merely mention COLLECT.  So if you have a nested collect and no INTO, where else would it go?

    red&gt;&gt; parse [a a [1 1] b b] [
         collect [while [
             keep word!
             | ahead block! into [collect [some keep integer!]]
         ]]
    ]
    == [a a [1 1] b b]

It&#39;s nicer to have the option to do what you want with it.  In Ren-C, such a COLLECT would just be thrown out...you&#39;d have to KEEP it in the outer collect.  At which point you could splice it, or not...

    ren-c&gt;&gt; uparse [a a [1 1] b b] [
         collect [while [
             keep ^ word!
             | into block! [keep collect [some keep integer!]]
         ]]
    ]
    == [a a 1 1 b b]

    ren-c&gt;&gt; uparse [a a [1 1] b b] [
         collect [while [
             keep ^ word!
             | into block! [keep ^ collect [some keep integer!]]
         ]]
    ]
    == [a a [1 1] b b]

## Weird TO END Behavior With Strings

In [Red Issue #2561](https://github.com/red/red/issues/2561) it was observed that the null terminator of strings was getting captured by KEEP TO END in PARSE collect.  Clearly a bug.

But the fix yields this weird behavior:

    red&gt;&gt; parse &quot;&quot; [collect [keep to end]]|
    == []

    red&gt;&gt; parse &quot;&quot; [collect [keep pick to end]]|
    == []

I ask the usual question of why KEEP should be different from anything else.  Let&#39;s try:

    red&gt;&gt; parse &quot;&quot; [test: to end]
    == true

    red&gt;&gt; test
    == &quot;&quot;

So if that&#39;s what TO END synthesized, why isn&#39;t it what KEEP would keep?

For all the whining from the Red camp that I *&quot;make things too complicated&quot;* (or whatever they say, it&#39;s not true)--it would be *so much easier* if they&#39;d just follow the UPARSE schematic.  Rules synthesize values, BLOCK! rules synthesize the value of their last synthesized alternate, GROUP!s consume no input and just synthesize a value.  And that value is what gets up to KEEP or set in a variable or returned from the overall operation.  Sheesh.</description>
    
    <lastBuildDate>Mon, 09 Aug 2021 22:33:45 +0000</lastBuildDate>
    <category>Testing</category>
    <atom:link href="https://forum.rebol.info/t/dead-red-redemption-starting-uparse-on-the-right-foot/1649.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Dead Red Redemption: Starting UPARSE on the Right Foot</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1649">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I'm starting them out as a commit of one file just to show what was taken if there's any question about that. But the next step is to break them out into the per-combinator files.</p>
</blockquote>
</aside>
<p>...and no small amount of work that was.  <img src="https://forum.rebol.info/images/emoji/twitter/man_technologist.png?v=9" title=":man_technologist:" class="emoji" alt=":man_technologist:"></p>
<aside class="onebox githubcommit">
  <header class="source">
      <a href="https://github.com/metaeducation/ren-c/commit/15876a28c5a3a9b60bb672676b7cf75d04425106" target="_blank" rel="noopener">github.com/metaeducation/ren-c</a>
  </header>
  <article class="onebox-body">
    <div class="github-row">
  <div class="github-icon-container" title="Commit">
    <svg width="60" height="60" class="github-icon" viewbox="0 0 14 16" aria-hidden="true"><path d="M10.86 7c-.45-1.72-2-3-3.86-3-1.86 0-3.41 1.28-3.86 3H0v2h3.14c.45 1.72 2 3 3.86 3 1.86 0 3.41-1.28 3.86-3H14V7h-3.14zM7 10.2c-1.22 0-2.2-.98-2.2-2.2 0-1.22.98-2.2 2.2-2.2 1.22 0 2.2.98 2.2 2.2 0 1.22-.98 2.2-2.2 2.2z"></path></svg>
  </div>

  <div class="github-info-container">
    <h4>
      <a href="https://github.com/metaeducation/ren-c/commit/15876a28c5a3a9b60bb672676b7cf75d04425106" target="_blank" rel="noopener">Break %parse-tests-from-red into the per-combinator files</a>
    </h4>

    <div class="github-info">
      <div class="date">
        committed <span class="discourse-local-date" data-format="ll" data-date="2021-08-07" data-time="19:22:11" data-timezone="UTC">07:22PM - 07 Aug 21 UTC</span>
      </div>

      <div class="user">
        <a href="https://github.com/hostilefork" target="_blank" rel="noopener">
          <img alt="hostilefork" src="https://avatars.githubusercontent.com/u/20440?v=4" class="onebox-avatar-inline" width="20" height="20">
          hostilefork
        </a>
        
      </div>

      <div class="lines" title="changed 42 files with 3804 additions and 3407 deletions">
        <a href="https://github.com/metaeducation/ren-c/commit/15876a28c5a3a9b60bb672676b7cf75d04425106" target="_blank" rel="noopener">
          <span class="added">+3804</span>
          <span class="removed">-3407</span>
        </a>
      </div>
    </div>

  </div>
</div>


  <div class="github-row">
    <pre class="github-content" style="white-space: normal;">This breaks down the monolithic tests from %parse-test.red so that
they are in files for the combinators used.
It's an inexact science but...</pre>
  </div>


  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<p>A lot of the Red tests are redundant, and the consistent design of UPARSE isn't as likely to have trouble with some of the variants they worry over.  I would like to see a lot of the tests that look like they are generated by an algorithm be expressed in the test files as the algorithm... because it's laborious to read them and realize if you've got a case tested for BLOCK! input that you missed for TEXT! or BINARY!...</p>
<p><strong>But however you look at it, UPARSE is now the most heavily tested PARSE implementation out there!</strong></p>
<h2>YOU CAN HELP</h2>
<p>Yes, you!  Send in your tests.  Anything you type in the web REPL to see if it works or not...that counts.</p>
          <p><a href="https://forum.rebol.info/t/dead-red-redemption-starting-uparse-on-the-right-foot/1649/3">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/dead-red-redemption-starting-uparse-on-the-right-foot/1649/3</link>
        <pubDate>Mon, 09 Aug 2021 22:33:45 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1649-3</guid>
        <source url="https://forum.rebol.info/t/dead-red-redemption-starting-uparse-on-the-right-foot/1649.rss">Dead Red Redemption: Starting UPARSE on the Right Foot</source>
      </item>
      <item>
        <title>Dead Red Redemption: Starting UPARSE on the Right Foot</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>Here is the script I used to do the conversion of Red's %parse-test.red.</p>
<p>Generally speaking I don't intend to do any more such conversions.  When we run Redbol tests, it will use their test format and be running under Redbol emulation.</p>
<p>Since this was a one-time thing...I just did it quick and dirty.  And I just edited it by hand after the script did what it could.  But it was a reminder that we need some better tools for working in the symbolic domain; things like REPLACE/ALL/DEEP (Red actually has that).  When you replace things as text there's all kinds of room for error...the meaning of "whole words only" is hard to capture in parse rules.</p>
<p>It's good to sit down and just suffer through a task like this now and again--to think about the things that are hard, and notice all the unpolished edges.  But I do have to say the parts that I find really interesting are Ren-C-isms...the NULLs and the ELSEs and the way things click together.</p>
<p>UPARSE is just going to make it that much better.  But there will still be a long way to go.</p>
<p>(I hope it just gets to the point where smart people will see potential in it so that it's not just me hacking on the interpreter and design!)</p>
<pre><code>source: as text! read %parse-test.red

delimit: charset " ^/])^-"
whitespace: charset " ^/^-"
parse source [
    while [
        "any-string!"  ; skip these
        |
        change ["string!" ahead delimit] ("text!")
        |
        change ["none!" ahead delimit] ("blank!")
        |
        change ["none!" ahead delimit] ("none")
        |
        change ["number!" ahead delimit] ("any-number!")
        |
        change ["skip" ahead delimit] ("&lt;any&gt;")
        |
        change ["end" ahead delimit] ("&lt;end&gt;")
        |
        change ["try" ahead delimit] ("trap")
        |
        change [
            "copy" some whitespace not [{"} | "[" | "{" | "#"]
            copy var to delimit
        ] (
            :[(to set-word! var) space 'across]
        )
        |
        "charset"  ; skip to make it easier to see the SETs
        |
        change [
            pos: here
            "set" some whitespace [not [{"} | "[" | "{" | "#"]
            copy var to delimit | (print ["PROBLEMO!" copy/part pos 20])]
        ] (
            :[(to set-word! var)]
        )
        |
        change ["parse" ahead [delimit | "/"]] (
            "uparse?"  ; plain UPARSE returns block synthesis, not logic
        )
        |
        change ["fail" ahead delimit] ("false")
        |
        change ["any" ahead delimit] ("while")  ; most if not all ANY are rules
        |
        skip
    ]
]

loaded: load source

lineize: func [
    {Turn block with NEW-LINE markers in it to where each line is in a BLOCK!}
    return: [block!]
    block [block!]
][
    ; turn the group into blocks that represent lines.
    let start: block
    return collect [
        cycle [
            if tail? start [stop]
            let end: next start
            cycle [
                if new-line? end [stop]
                if tail? end [stop]
                end: next end
            ]
            let line: take/part start end
            new-line line false
            new-line tail line false
            keep ^line
        ]
    ]
]

unlineize: func [
    {Flatten blocks representing lines into series with NEW-LINE markers}
    return: [block!]
    lines [block!]
][
    let block: first lines

    if 1 = length of lines [
        ;
        ; if it's just one line, make the resulting block a single line
        ;
        new-line block false
        new-line tail block false
        return block
    ]

    for-each line next lines [
        let pos: tail block
        append block line
        new-line pos true
    ]

    new-line block true
    new-line tail block true
    return block
]

elide pos: loaded
cycle [
    pos: find pos [--test--] else [stop]
    take pos
    if text? pos.1 [label: take pos]
    end-group: find pos [===end-group===]
    next-test: find pos [--test--]
    end: all [
        not end-group
        not next-test
        tail pos
    ] else [
        end-group: default [tail pos]
        next-test: default [tail pos]
        if (index? end-group) &lt; (index? next-test) [
            end-group
        ] else [
            next-test
        ]
    ]
    block: take/part pos end
    lines: lineize block

    temp: back tail lines
    if '--assert = first temp.1  [
        if '--assert != first try first try back temp [
            ;
            ; Last line of collection is assert with no prior line or no
            ; assert on prior line.  Just remove it.
            ;
            take temp.1
        ] else [
            ; more asserts above.  group these lines into a DID clause

            clauses: reverse collect [  ; TEMP is a position in array of lines
                cycle [
                    if '--assert &lt;&gt; first temp.1 [stop]
                    take temp.1  ; the --assert
                    keep ^ take temp  ; the line
                    if head? temp [stop]
                    temp: back temp
                ]
            ]
            append lines compose/deep [[did all (unlineize clauses)]]
        ]
    ]

    group: as group! unlineize lines

    insert pos quote group
    new-line pos true
]

; Now cluster the test groups

elide clusters: collect [
    cycle [
        pos: loaded
        assert [pos.1 = '===start-group===]
        take pos
        assert [text? pos.1]  ; group name, keep it (strings legal)

        ; There can be some code here that's not in a group but should be
        ; as leading setup for the cluster.  Fix it manually, this script
        ; is only being run once...not worth automating.

        loop ['===end-group=== != pos.1] [
            pos: next pos
        ]
        take pos
        keep ^(take/part loaded pos)
        if empty? loaded [stop]
    ]
]

write %working.red mold/only clusters</code></pre>
          <p><a href="https://forum.rebol.info/t/dead-red-redemption-starting-uparse-on-the-right-foot/1649/2">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/dead-red-redemption-starting-uparse-on-the-right-foot/1649/2</link>
        <pubDate>Fri, 06 Aug 2021 22:44:32 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1649-2</guid>
        <source url="https://forum.rebol.info/t/dead-red-redemption-starting-uparse-on-the-right-foot/1649.rss">Dead Red Redemption: Starting UPARSE on the Right Foot</source>
      </item>
      <item>
        <title>Dead Red Redemption: Starting UPARSE on the Right Foot</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>When UPARSE began it couldn't do much.  So it had one test file %uparse.test.reb, that grew as the number of combinators grew.</p>
<p>This "one test file for all parse functions" approach was all the Saphirion tests ever had.  And the ever-growing-file method is also used by the <a href="https://github.com/red/red/blob/master/tests/source/units/parse-test.red">Red parse tests</a>.</p>
<p>But UPARSE now aims higher: <em>each combinator gets its own test file</em>.  While some tests will not fit precisely into that--especially larger examples that use many features--it's a better general idea for most of the tests.</p>
<p>Hence you can see <a href="https://github.com/metaeducation/ren-c/tree/master/tests/parse">all the nice files in the <strong><code>%tests/parse/</code></strong></a> directory.  And now that UPARSE is capable enough, I've even mined the R3-Alpha PARSE tests and sorted through them...adjusting them for UPARSE and making sure they work.</p>
<h2>And Red Is Finally Going to Be Sort Of Useful...</h2>
<p>This morning I hacked up a converter to translate Red's rather verbose test format to the more spare Rebol test form.  At some point we'll be able to run Red's test suite directly "via Redbol", but I just wanted to go through and mine their parse tests for anything useful...and have them translated into the UPARSE way of saying things.</p>
<p>So... <strong>MEET <a href="https://github.com/metaeducation/ren-c/blob/414a51e4974dfaa5e18486bc69e8a2fc52588156/tests/parse/parse-tests-from-red.test.reb">%PARSE-TESTS-FROM-RED.TEST.REB</a></strong>!</p>
<p><em>(Note: Capture was done as of the last change to that file on Oct 16, 2020... <a href="https://github.com/red/red/commit/32c30072ff215fd4efc0200ab3572ffd7afc8e9f#diff-aa7745d6b886ee41ee7e0ff66dfcbeb5412f86eb0be8bd47370e1e3ef244e089">commit 32c30072ff215fd4efc0200ab3572ffd7afc8e9f</a>...curious they haven't added any parse tests for a year...?)</em></p>
<p>No small feat to go through those, but.  Here we are.  Most of them work--but BREAK and REJECT still need to be thought through as combinators.  So the tests that don't work are the ones that use those.  I'm starting them out as a commit of one file just to show what was taken if there's any question about that.  But the next step is to break them out into the per-combinator files.</p>
<p>They licensed their tests BSD-3 which is <a href="http://www.apache.org/legal/resolved.html#category-a">Apache-2 Compatible to include or extend</a>.  Taking Apache-2 code back to BSD-3 isn't allowed by default.  But they have my permission to take whatever <em>tests</em> as BSD-3, if they care.  <sub>(They can in fact take any of my <em>ideas</em>.  Should they ever do so, then them merely knowing that their ideas don't work and mine do is plenty punishment for them.  But the non-test-<em>code</em> is LGPL...that includes the code for UPARSE and the web REPL.  Borrowing from that means being subject to the LGPL license.)</sub></p>
<p>Changes to remember are:</p>
<ul>
<li>
<p>UPARSE uses WHILE instead of ANY...and neither WHILE nor SOME have a progress requirement.  Use FURTHER if progress is mandated.</p>
</li>
<li>
<p>SET-WORD! must be combined with <code>&lt;here&gt;</code> to capture a position, vs. that weird old behavior of set-word alone.  Seeking positions is done with the SEEK combinator, not a GET-WORD!.</p>
</li>
<li>
<p>UPARSE replaces END with <code>&lt;end&gt;</code> and SKIP with <code>&lt;any&gt;</code>. I think these TAG! combinators are working out great...it's nice to have END free for a variable name...and it opens up the space for more nouns that are "out of band" from variable names.  Needing to say <code>'&lt;tag&gt;</code> to actually match a tag is a small price to pay.</p>
</li>
<li>
<p>General Ren-C renamings (string! =&gt; text!, number! =&gt; any-number!, none! =&gt; blank!), historical TRY is TRAP (with a much neater meaning for TRY)...</p>
</li>
<li>
<p>Stopping an alternate match is just done with FALSE.  FAIL is reserved for the "raise an error" sense of failing, and by letting LOGIC! decide if the parse should go on or not we have a nice ability to use splicing rules like <code>:(condition = whatever)</code> to put a true to go on or a false to stop matching.</p>
</li>
</ul>
<p>Thoughts follow.</p>
<h2>You Never Find Out If Red PARSE COLLECT fails</h2>
<p>Once a COLLECT keyword is hit, your result will be an array.  It will contain whatever got collected up to the point of failure.</p>
<pre><code>red&gt;&gt; parse [1 2 3 &lt;bomb&gt;] [collect [some keep integer!] word!]
== [1 2 3]

red&gt;&gt; parse [1 2 3 &lt;bomb&gt;] [collect [some keep integer! word!]]
== [1 2 3]

red&gt;&gt; parse [1 2 3 &lt;bomb&gt; 4] [collect [some keep integer! word!]]
== [1 2 3]
</code></pre>
<p>Ren-C's system lets you have your cake and eat it too... the COLLECT result can be the result and you can even elide matches outside:</p>
<pre><code>ren-c&gt;&gt; uparse [1 2 3 ta-da!] [collect [some keep integer!] elide word!]
== [1 2 3]

ren-c&gt;&gt; uparse [1 2 3 ta-da!] [collect [some keep integer!] word!]
== ta-da!

ren-c&gt;&gt; uparse [1 2 3 &lt;bomb&gt;] [collect [some keep integer!] word!]
; null
</code></pre>
<p>And of course you can always store rule results--any rule synthesized result--into a variable:</p>
<pre><code>ren-c&gt;&gt; uparse [1 2 3 ta-da!] [block: collect [some keep integer!] word!]
== ta-da!

ren-c&gt;&gt; block
== [1 2 3]
</code></pre>
<p>Every option is on the table (except having rules you write as if they must match fail, and not tell you!)</p>
<h2>Red PARSE COLLECT/KEEP Is Wacky About Splicing</h2>
<p>Here's a collect test that shows some nasty inconsistencies:</p>
<pre><code>red&gt;&gt; parse [a b b b] [collect [skip keep some 'b]]
== [[b b b]]
</code></pre>
<p>First of all, that KEEP is keeping a BLOCK!.  We know that in ordinary COLLECT if you keep a block it will splice...but this PARSE KEEP is acting like a KEEP/ONLY.</p>
<p>Secondly, the <strong>some 'b</strong> rule is returning a BLOCK!.  But that's not what it does in general.  Try an assignment:</p>
<pre><code>red&gt;&gt; parse [a b b b] [skip set var some 'b]
== true

red&gt;&gt; var
== b
</code></pre>
<p>So KEEP SOME 'B has a different logic for what SOME 'B synthesizes than SET SOME 'B.  <img src="https://forum.rebol.info/images/emoji/twitter/clown_face.png?v=9" title=":clown_face:" class="emoji" alt=":clown_face:"></p>
<p>Ren-C is consistent on both fronts.  KEEP will splice unless a value is QUOTED!.  SOME always synthesizes the value of its last rule unless you ask for a copy.  Currently that is done with ACROSS <em>(may name change to COPY after a settling period...the distinction is currently helpful)</em></p>
<pre><code>ren-c&gt;&gt; uparse [a b b b] [collect [&lt;any&gt;, keep ^ across some 'b]]
== [[b b b]]

ren-c&gt;&gt; uparse [a b b b] [collect [&lt;any&gt;, keep across some 'b]]
== [b b b]

ren-c&gt;&gt; uparse [a b b b] [collect [&lt;any&gt;, keep ^ some 'b]]
== [b]
</code></pre>
<p>You could have also written that as <strong>keep ^[across some 'b]</strong> for instance.  To please <a class="mention" href="/u/rgchris">@rgchris</a> we could add QUOTE as a UPARSE keyword so you could avoid the ^... it doesn't mean quite the same thing as META but makes some sense: "keep this thing literally".  <strong>keep quote across some 'b</strong>.</p>
<p><strong>But...how do you splice in Red KEEP?</strong></p>
<p>If you guessed weird keyword pattern, you'd be right. <a href="https://github.com/red/red/issues/2391#issuecomment-281655108">KEEP PICK and KEEP COPY variants are explained (?) here</a>:</p>
<pre><code>red&gt;&gt; parse [x -- ] [collect [keep to '-- ]]
== [x]
red&gt;&gt; parse [x y -- ] [collect [keep to '-- ]]
== [[x y]]

red&gt;&gt; parse [x -- ] [collect [keep pick to '-- ]]
== [x] 
red&gt;&gt; parse [x y -- ] [collect [keep pick to '-- ]]
== [x y]

red&gt;&gt; parse [x -- ] [collect [keep copy _ to '-- ]]
== [[x]]
red&gt;&gt; parse [x y -- ] [collect [keep copy _ to '-- ]]
== [[x y]]
</code></pre>
<p><em>(Sidenote: the use of the _ as a "word that is thrown away" shows that being forced to name arguments to COPY is a bad idea.  It's better as a combinator that synthesizes a result that may or may not be stored in a variable.)</em></p>
<p>The best I can imagine is that this is an attempt to avoid generating large intermediate series. Since Red doesn't worry about "rollback" then if it wants to append things as it goes to the collecting array it can do so with this KEEP PICK.</p>
<p>It doesn't seem to even make any sense...the above suggests that KEEP PICK splices, but apparently not if the result comes from a GROUP! (??).   See <a href="https://github.com/red/red/issues/4198">Red Issue #4198</a>:</p>
<pre><code>red&gt;&gt; parse [][collect keep pick ('a)]
== [a]

red&gt;&gt; parse [][collect keep pick ([a b])]
== [[a b]]
</code></pre>
<p>Truly nutty.  UPARSE is going down a vastly more consistent/usable road.  But if rollback isn't a requirement there's no reason the append-with-no-intermediate-series behavior couldn't be mimic'd in the UPARSE2 emulation.  Don't know who'd want it, though.</p>
<h2>Explicit Advancement Requirement Is Good</h2>
<p>These tests all infinite loop in UPARSE:</p>
<pre><code>uparse? [a a] [some ['c | not 'b] 2 &lt;any&gt;]
uparse? "aa" [some [#c | not #b] 2 &lt;any&gt;]
uparse? "bx" [some [not "b" | &lt;any&gt;]]
uparse? #{0A0A} [some [#"^L" | not #{0B}] 2 &lt;any&gt;]
</code></pre>
<p>And they're trickier than usual, because if you just change that to <code>some further</code> they won't work... because you're demanding rules like <code>further ['c | not 'b]</code> make progress <em>some</em> number of times.</p>
<p>It's a really convoluted way of thinking of what you're doing here as <em>"some number of matches... including a non-match that doesn't advance of 'b counting as at least one match.  So the SOME doesn't fail to match, -but- if it doesn't advance, even though the one time succeeded count it as a break of the iteration and yield success"</em>.</p>
<p>Who wants to think like that?  It doesn't really make sense.  If you insist on using SOME you have to use an OPT and FURTHER:</p>
<pre><code>uparse? [a a] [opt some further ['c | not 'b], 2 &lt;any&gt;]
</code></pre>
<p>But we have another name for OPT SOME which is WHILE:</p>
<pre><code>uparse? [a a] [while further ['c | not 'b], 2 &lt;any&gt;]
</code></pre>
<p>Or write it more coherently by just testing for the NOT in sequence, vs inside the looped alternate:</p>
<pre><code>uparse? [a a] [while 'c, not 'b, 2 &lt;any&gt;]
</code></pre>
<p>I know it's just a test, but, I have a feeling that most of these "infinite rules need to break" rules have saner expressions...which makes for a more understandable SOME.  Red embraces the advancement rule on purpose; these tests represent "fixes" to what they consider bugs, e.g. <a href="https://github.com/red/red/issues/3927">Red Issue #3927</a>.</p>
<p>But I think requiring advancement fundamentally limits the perception of what PARSE can do.  It can be the control structure of an application or state machine... SOME and WHILE are loops.  You might want to re-run a rule so long as input is pending on a network port.  Especially with GROUP! rule splicing that can inject "true" or "false", you can mix and match rules with imperative code... and having a successful rule decide it was "too successful" is just disruptive.</p>
<p>Having a good debugger someday <em>(it's always "someday"...? :-/)</em> will make it easy enough to find the infinite loops.</p>
<h2>We Don't Do /INTO... nor COLLECT INTO</h2>
<p>Red is concerned about low level series optimization, even though Gregg has indicated he agrees with me that this is a bad thing to focus on:</p>
<aside class="quote quote-modified" data-post="1" data-topic="705">
  <div class="title">
    <div class="quote-controls"></div>
    <img alt="" width="20" height="20" src="/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar">
    <a href="https://forum.rebol.info/t/stopping-the-into-virus/705/1">Stopping the /INTO Virus</a> <a class="badge-wrapper  bullet" href="/c/development/internals/9"><span class="badge-category-parent-bg" style="background-color: #25AAE2;"></span><span class="badge-category-bg" style="background-color: #25AAE2;"></span><span style="" data-drop-close="true" class="badge-category clear-badge" title="Internals of the Rebol language">Internals</span></a>
  </div>
  <blockquote>
    In R3-Alpha, an /INTO option was added to REDUCE and COMPOSE.  It blended the functionality of INSERT into these routines, so as to avoid the overhead of creating an intermediate series that would just be thrown away: 
&gt;&gt; data: copy [a b c]
&gt;&gt; insert data reduce [10 + 20 30 + 40]
&gt;&gt; data
[30 70 a b c]

&gt;&gt; data: copy [a b c]
&gt;&gt; reduce/into [10 + 20 30 + 40] data
&gt;&gt; data
[30 70 a b c]

So no new functionality is added...this is a refinement whose sole purpose is to be a lower-overhead way of doing…
  </blockquote>
</aside>

<p>Not going to rewrite that post here.  But I'll say the idea of being able to make series discontiguous in memory is an interesting one; kind of like how filesystems can split files into chunks.  It seems to me that if series could be "chunked" in this way at a system level, we could worry less about these /INTO matters.  I'd rather look into that kind of answer vs. burdening users with /INTO.</p>
<p>So there's no COLLECT INTO pattern in UPARSE.  They also have a COLLECT AFTER which uses the position after the current series position instead of before the current series position to insert.  :-/  The need for these permutations just seems to further demonstrate what an awkward thing this is to build in.</p>
<p>Someone can put this stuff in Redbol's PARSE built on UPARSE with different combinators--if they really want it.  Don't think that will be me!</p>
<h2>Using Things as Non-Rules Consistently Requires GROUP!</h2>
<p>In Red, this works:</p>
<pre><code>red&gt;&gt; parse blk: [] [insert 1]
== true

red&gt;&gt; blk
== [1]
</code></pre>
<p>Why treat that 1 as a number, instead of as a rule?  Well, in Red's world a rule can't provide a value to insert...because rules (theoretically) don't synthesize values.  Of course that's a mixed bag, we see <strong>keep some "a"</strong> treating it as if <strong>some "a"</strong> made a value that could be worth keeping.  Why not a value worth inserting?</p>
<p>Ren-C takes a hard-line stance on this and says that a raw integer that's not inside a GROUP! is a match count for a rule.  So <code>[insert 1]</code> is malformed... you could say <code>[insert 1 "a"]</code> and then if it foudn a single "a" that would be what gets inserted:</p>
<pre><code> ren-c&gt;&gt; uparse? blk: ["a"] [insert 1 "a", &lt;any&gt;]
 == #[true]

 ren-c&gt;&gt; blk
 == ["a" "a"]
</code></pre>
<p>So the rule matched the "a" that was in the block, inserted another one, and then skipped it to reach the end of the input.  But if you really want to keep a 1 synthesized out of thin air and not matched against any input, you need a GROUP!</p>
<pre><code>ren-c&gt;&gt; uparse? blk: [] [insert (1)]
== #[true]

ren-c&gt;&gt; blk
== [1]
</code></pre>
<p>Unlike the constant questioning caused by living in the design ghetto, UPARSE is reliable and consistent.  <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
<h2>Red's PARSE INSERT Is Either Arity-1 or Arity-2</h2>
<p>As I show above, Red lets you do <code>insert 1</code>... which makes it look like INSERT takes a single argument.  That's the thing to insert.  You don't need to tell it what series or position, because it presumes you mean the current series at the parse position.</p>
<p>But weirdly enough, <a href="https://github.com/red/red/issues/4153">you can provide a position as the first argument to insert as a word</a>.  In this case it takes two parameters.</p>
<pre><code>&gt;&gt; parse (data: [a b c]) [
    pos-head:           ; capture head postion to variable
    to end              ; seek to end of series
    pos-tail:           ; capture tail position to variable
    insert pos-head 1   ; use arity-2 form of insert, arg 1 is where
]
== true  ; parse position was moved past insertion to end

&gt;&gt; data
== [1 a b c]  ; data changed as expected

&gt;&gt; pos-head
== [1 a b c]  ; pos-head did not move to consistently point at a

&gt;&gt; pos-tail  ; pos-tail also did not move, no longer tail
== [c]
</code></pre>
<p>There's a little bit of this mechanism that would be hard to do yourself.  If you tried to save the parse position, do a SEEK to where you want to insert, then insert, and jump back to the parse position you saved... your parse position wouldn't take into account the size of the insertion.  So you'd have to do something more like:</p>
<ul>
<li>Save the parse position</li>
<li>Seek to where you want to insert</li>
<li>Save the insertion position</li>
<li>Do the insert</li>
<li>If parse position was before insertion position, jump back to it, else
<ul>
<li>Save the after-insertion position</li>
<li>Count distance between after-insertion position and before insertion position</li>
<li>Seek to the saved parse position plus that distance</li>
</ul>
</li>
</ul>
<p>So this form of INSERT does that for you.  But as shown above, the only position that is getting adjusted in this way is your parse position...all other saved positions in the parse will have the wrong index.  This is just a general Rebol issue since it's nothing more than arrays and indices at heart.  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=9" title=":frowning:" class="emoji" alt=":frowning:"></p>
<p>Here's an example weird Red test of this:</p>
<pre><code>red&gt;&gt; series: [a b c]
red&gt;&gt; letters: [x y z]
red&gt;&gt; parse series [
     mark: 'a insert mark letters insert only mark letters 'b 'c
 ]
== true
red&gt;&gt; series
== [[x y z] x y z a b c]
</code></pre>
<p>Here's me rotely translating that parse rule according to my formula above:</p>
<pre><code>[
    mark: &lt;here&gt;
     'a

    ; Try equivalent of Red's `insert mark letters`
    pos: &lt;here&gt;
    seek (mark)
    insert (letters)
    after: &lt;here&gt;
    seek (skip pos (index? after) - (index? mark))

    ; Try equivalent of Red's `insert only mark letters`
    pos: &lt;here&gt;
    seek (mark)
    insert ^(letters)
    after: &lt;here&gt;
    seek (skip pos (index? after) - (index? mark))

    'b 'c
]
</code></pre>
<p>The mechanic isn't rocket science, but it's sure a pain to do by hand.  Another approach would be PUSH-POSITION and POP-POSITION operators, where the positions on the stack get updated for insertions.</p>
<p>CHANGE is weirder still, because if you pass it a position in the series it changes <em>between</em> the current parse position and what you pass it.</p>
<pre><code>red&gt;&gt; parse blk: [a b c 1 2 3] [
    mark:
    some word!
    change mark "like so"
    some integer!
]
== true

red&gt;&gt; blk
== ["like so" 1 2 3]
</code></pre>
<p>Gabriele dropped mutating operators like CHANGE/INSERT/REMOVE from Topaz PARSE entirely.  They are troublemakers, for sure.  I've kept an open mind but this is of course the kind of debacle you're going to have with them.</p>
<p>But no matter how this is dealt with, I don't think variable-arity INSERT is the right answer.  This needs more careful thought if mutations are going to be allowed.</p>
<h2>Weird Implicit KEEP on Nested COLLECT</h2>
<p>This is the silly consequence of the fact that COLLECT doesn't really know where it's writing things when you don't use INTO.  It bubbles its result out the top of the parse if you merely mention COLLECT.  So if you have a nested collect and no INTO, where else would it go?</p>
<pre><code>red&gt;&gt; parse [a a [1 1] b b] [
     collect [while [
         keep word!
         | ahead block! into [collect [some keep integer!]]
     ]]
]
== [a a [1 1] b b]
</code></pre>
<p>It's nicer to have the option to do what you want with it.  In Ren-C, such a COLLECT would just be thrown out...you'd have to KEEP it in the outer collect.  At which point you could splice it, or not...</p>
<pre><code>ren-c&gt;&gt; uparse [a a [1 1] b b] [
     collect [while [
         keep ^ word!
         | into block! [keep collect [some keep integer!]]
     ]]
]
== [a a 1 1 b b]

ren-c&gt;&gt; uparse [a a [1 1] b b] [
     collect [while [
         keep ^ word!
         | into block! [keep ^ collect [some keep integer!]]
     ]]
]
== [a a [1 1] b b]
</code></pre>
<h2>Weird TO END Behavior With Strings</h2>
<p>In <a href="https://github.com/red/red/issues/2561">Red Issue #2561</a> it was observed that the null terminator of strings was getting captured by KEEP TO END in PARSE collect.  Clearly a bug.</p>
<p>But the fix yields this weird behavior:</p>
<pre><code>red&gt;&gt; parse "" [collect [keep to end]]|
== []

red&gt;&gt; parse "" [collect [keep pick to end]]|
== []
</code></pre>
<p>I ask the usual question of why KEEP should be different from anything else.  Let's try:</p>
<pre><code>red&gt;&gt; parse "" [test: to end]
== true

red&gt;&gt; test
== ""
</code></pre>
<p>So if that's what TO END synthesized, why isn't it what KEEP would keep?</p>
<p>For all the whining from the Red camp that I <em>"make things too complicated"</em> (or whatever they say, it's not true)--it would be <em>so much easier</em> if they'd just follow the UPARSE schematic.  Rules synthesize values, BLOCK! rules synthesize the value of their last synthesized alternate, GROUP!s consume no input and just synthesize a value.  And that value is what gets up to KEEP or set in a variable or returned from the overall operation.  Sheesh.</p>
          <p><a href="https://forum.rebol.info/t/dead-red-redemption-starting-uparse-on-the-right-foot/1649/1">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/dead-red-redemption-starting-uparse-on-the-right-foot/1649/1</link>
        <pubDate>Fri, 06 Aug 2021 21:56:33 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1649-1</guid>
        <source url="https://forum.rebol.info/t/dead-red-redemption-starting-uparse-on-the-right-foot/1649.rss">Dead Red Redemption: Starting UPARSE on the Right Foot</source>
      </item>
  </channel>
</rss>
