<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>What should do of empty block (`DO []`) do?</title>
    <link>https://forum.rebol.info/t/what-should-do-of-empty-block-do-do/1426</link>
    <description>I&#39;ve pointed out that the answer for things like &quot;what should a loop that never runs its body&quot; have varied.

    rebol2/r3-alpha&gt;&gt; type? while [false] [&quot;whatever&quot;]
    == none!

    red&gt;&gt; type? while [false] [&quot;whatever&quot;]
    == unset!

But it&#39;s consistent historically that if something runs **do []** then you get an &quot;UNSET!&quot;

    rebol2/r3-alpha/red&gt;&gt; type? do []
    == unset!

## New Names Available

One of the benefits of having lots of different labeled BAD-WORD!s is to stop collapsing all &quot;potentially error-triggering situations&quot; into the same uninformative name.

    &gt;&gt; do []
    == ~empty~  ; isotope

Or maybe that&#39;s considered to be where ~void~ isotopes comes from:

    &gt;&gt; do []
    == ~void~  ; isotope

In either case, you&#39;ve still got a type that will be &quot;ornery&quot; and neither true nor false, that errors if you try to access it.  But by not reporting `~unset~` you&#39;re helping to convey that this wasn&#39;t the by-product of encountering an unset variable somewhere.  It might help people get their bearings more easily.

I&#39;ve mentioned that this is a bit unfortunate in the sense of canonizing English into the evaluator mechanics.  But I&#39;m taking away the option by [removing `~` as a form of BAD-WORD!](https://forum.rebol.info/t/void-choices-the-role-of-english-in-the-evaluator/1413/6?u=hostilefork)...which is what this case had been before.

## Or Is This A Job For NULL ?

We have some cases where emptiness produces pure NULL.  With DELIMIT and its specializations, an all empty block produces the same thing that an all-NULL-producing block produces:

    &gt;&gt; unspaced [if false [&quot;a&quot;] if false [&quot;b&quot;]]
    ; null

    &gt;&gt; unspaced []
    ; null

    &gt;&gt; unspaced compose [(if false [&quot;a&quot;]) (if false [&quot;b&quot;])]
    ; null

There&#39;s some neat combining of this with PRINT.  Although PRINT draws your attention to calling with NULL via error, a BLANK! will get it to overlook that and just be a no-op:

    &gt;&gt; print unspaced compose [(if false [&quot;a&quot;]) (if false [&quot;b&quot;])]
    ** error, print doesn&#39;t take NULL

    &gt;&gt; print try unspaced compose [(if false [&quot;a&quot;]) (if false [&quot;b&quot;])]
    ; null

**Can anyone think of a case where there&#39;s a balance of provable value for something like a `do compose [...]` whose contents have all boiled away to be NULL instead of ~void~ ?**

You could get the same result by saying **do compose [null (...whatever...)]** so it&#39;s not far out of reach to have a default value of anything you like.</description>
    
    <lastBuildDate>Sat, 19 Jun 2021 22:52:35 +0000</lastBuildDate>
    <category>Internals</category>
    <atom:link href="https://forum.rebol.info/t/what-should-do-of-empty-block-do-do/1426.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>What should do of empty block (`DO []`) do?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="16" data-topic="1426">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Executive Summary: <strong><code>~void~ (isotope)</code></strong> is the right answer for <strong><code>do []</code></strong>.</p>
</blockquote>
</aside>
<aside class="quote no-group quote-modified" data-username="hostilefork" data-post="16" data-topic="1426">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Writing sound code based on these ideas (isotopes) is a new art form</p>
</blockquote>
</aside>
<h2>This is <em>indeed</em> a new art form! <img src="https://forum.rebol.info/images/emoji/twitter/art.png?v=9" title=":art:" class="emoji" alt=":art:"> <img src="https://forum.rebol.info/images/emoji/twitter/computer.png?v=9" title=":computer:" class="emoji" alt=":computer:">
</h2>
<p>And I've just done some work to bring it to bear on answering the age-old question of what <strong><code>any []</code></strong> and <strong><code>all []</code></strong> should be... in a way that brings back a whimsical-but-powerful feature that was tried in the early days of Ren-C...</p>
<p>First let's ask: what should this set RESULT to?</p>
<pre><code>code: []

result: all [
    2 = 1 + 1
    do code
    &lt;item&gt;
]
</code></pre>
<p>If it makes it any easier to think about, does the following influence your answer?</p>
<pre><code>code: [comment "does this make you change your answer?"]

result: all [
    2 = 1 + 1
    do code
    &lt;item&gt;
]
</code></pre>
<p>Should result be <code>&lt;item&gt;</code>, or NULL, or should the code error?</p>
<p>I've argued pretty clearly that DO must return a result that would be put into a variable, rather than vanishing unexpectedly.</p>
<p>But if that value is a <em>void isotope</em>, it is something that is known not to be able to be put into a block...and it is also something that intrinsically carries the idea of being a proxy for invisibility.  <em>"I'd be invisible if I could, but I didn't think it was safe to say so, by breaking things like assignments.</em></p>
<p><strong>I think ANY and ALL are the kinds of construct that become more interesting if they vaporize ~void~ isotopes...and if ALL returns a ~void~ isotope itself if its contents all vaporize!</strong></p>
<p>The idea this brings back is the concept of having a third option for value-returning functions... so truthy, falsey, and "opt out".  But opting out is not conflated with nullness or unsetness, and it doesn't force unsafe "vanishing" semantics.</p>
<pre><code>voter1: func [] [return true]
voter2: func [] [return ~void~]
voter3: func [] [return true]
voter4: func [] [return false]

&gt;&gt; all [voter1 voter2 voter3]
== #[true]  ; voter2 "abstained"

&gt;&gt; any [voter2 voter3]
== #[true]  ; voter 2 didn't make -or- break it

&gt;&gt; any [voter2 voter4]
== #[false]  ; voter 2 didn't make -or- break it
</code></pre>
<p>So voter2 gets to have invisible intent without the interface risks of being purely invisible (like COMMENT or ELIDE are).  You can't opt out of everything...</p>
<pre><code>&gt;&gt; if voter2 [print "IF expects a yes-or-no"]
** Script Error: if needs condition as ^META for ~void~ isotope
</code></pre>
<p>So to answer my original question, should you find a DO that returns invisible intent, that would be preserved...and even propagated through the ANY and ALLs themselves...</p>
<pre><code>&gt;&gt; all ["A", all [comment "hi", do []]]
== "A"

&gt;&gt; any [all [do [comment "hi"], elide print "Magic!"], 1 + 2]
Magic!
== 3
</code></pre>
<p>Although the <code>all []</code> disappeared above, this is specific to the situation.  We don't have a dangerous situation like:</p>
<pre><code>&gt;&gt; block: [comment "hi"]

&gt;&gt; x: all [do block], y: 1 + 2

&gt;&gt; x
== 3  ; !!! &lt;-- this would be crazy!
</code></pre>
<p>Instead we are letting the isotopes be semi-reified (reified enough to be stored in a variable, but not a block, without being de-isotoped).  Then special cases handle them.</p>
<h2><a href="https://github.com/metaeducation/ren-c/commit/fb11be60285e48e683233a786c0379b270d4c829"><strong>As I say, a new art!</strong></a></h2>
          <p><a href="https://forum.rebol.info/t/what-should-do-of-empty-block-do-do/1426/17">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/what-should-do-of-empty-block-do-do/1426/17</link>
        <pubDate>Sat, 19 Jun 2021 22:14:41 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1426-17</guid>
        <source url="https://forum.rebol.info/t/what-should-do-of-empty-block-do-do/1426.rss">What should do of empty block (`DO []`) do?</source>
      </item>
      <item>
        <title>What should do of empty block (`DO []`) do?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="rgchris" data-post="9" data-topic="1426">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/rgchris/40/14_2.png" class="avatar"> rgchris:</div>
<blockquote>
<p>I think if the explanation is sound, then it doesn't matter exactly which semantic model it adheres to.</p>
</blockquote>
</aside>
<p><strong>BAD-WORD! and its "isotopes" have introduced a kind of renaissance, that leads all the above to be rethought.</strong></p>
<p>One concept is the interchangeability of the <strong>~void~ isotope</strong> with vanishing.  This is distinct from the intent behind the <strong>~none~ isotope</strong>, or the <strong>~null~ isotope</strong>.</p>
<p>Due to this paradigm shift, I believe that the right answer for functions like DO of things that may be invisible is not to have some kind of DO/VANISHABLE, but rather to say that it is up to the caller to decide if the return of a ~void~ isotope should be vanished by a generic operator like DEVOID.</p>
<pre><code>&gt;&gt; 1020 do []
== ~void~  ; isotope

&gt;&gt; 1020 devoid do []
== 1020
</code></pre>
<p>This is the power of having named entities to represent <em>a value-based surrogate for intent</em>.  These entities have a form that is safe to use in blocks (their normal form) and a form that can only exist in variables (the isotope form).  Quoting discerns them in the evaluator:</p>
<pre><code>&gt;&gt; var: '~void~
== ~void~

&gt;&gt; var: ~void~
== ~void~  ; isotope

&gt;&gt; second [var: ~void~]
== ~void~
</code></pre>
<p><strong>Writing sound code based on these ideas is a new art form, and I am sure there is a lot to explore with this new design.</strong>  You have to become familiar with the <strong>^</strong> operator and how it goes "meta" on what you are working with, to move it into the concrete domain, then shift it back into the meta meanings again.</p>
<p>It's already showing its mettle in UPARSE, which is proving ground for how someone can write something sophisticated and composable without resorting to C.</p>
<p>Executive Summary: <strong><code>~void~ isotope</code></strong> is the right answer for <strong><code>do []</code></strong>.  I don't know yet what REDUCE's disposition should be, as it is making a BLOCK! it does not have the choice to preserve the isotope status of a ~void~ so it would be put in the result block as a non-isotope...or it could vanish.</p>
<p>So questions are still open, but I do think that NULL is now ruled out as the result of <strong>do []</strong></p>
          <p><a href="https://forum.rebol.info/t/what-should-do-of-empty-block-do-do/1426/16">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/what-should-do-of-empty-block-do-do/1426/16</link>
        <pubDate>Wed, 02 Jun 2021 21:04:09 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1426-16</guid>
        <source url="https://forum.rebol.info/t/what-should-do-of-empty-block-do-do/1426.rss">What should do of empty block (`DO []`) do?</source>
      </item>
      <item>
        <title>What should do of empty block (`DO []`) do?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="3" data-topic="1426">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>The historical rule is that nothing vaporizes by default in REDUCE. If you have N expressions in, you will have N values out. <a href="https://forum.rebol.info/t/why-or-why-not-have-unset-in-rebol-like-languages/113/2">There is a religiosity about it in Red </a>.</p>
</blockquote>
</aside>
<p>For better or worse, here is an example of where nulls not erroring (or turning into BAD-WORD!s bit me) when I changed some BLANK!s to NULLs:</p>
<p>It was some of Shixin's code from rebmake.</p>
<pre><code>    if not let suffix: find reduce [
        #application target-platform/exe-suffix
        #dynamic-library target-platform/dll-suffix
        #static-library target-platform/archive-suffix
        #object-library target-platform/archive-suffix
        #object-file target-platform/obj-suffix
    ] project/class [return]

    suffix: second suffix
</code></pre>
<p>I had changed the suffixes in the base class of some objects from BLANK! to NULL.  This was in order to be more likely to catch usage problems of those suffixes, when BLANK! is more quiet about many operations (e.g. now leaning to being a no-op for things like APPEND, but it is part of the "blank-in, null-out" convention many places).</p>
<p>So since BLANK! can be silent if it's not set when it's expected to be, NULL provides a gentle sort of alarm...in the sense that it is falsey and does not need special GET/ANY access to test it.  And you can transition it to a BLANK! with TRY.  This is good for callsite comprehension.</p>
<p>But with NULL vanishing here, code in this style has problems.  I'm not sure there's anything particularly wrong about code in this style.  So we still might want to think about this.</p>
<blockquote>
<p>Note: Under the new philosophy of BAD-WORD! this would be an interesting case, in the sense that if you allow it to put ~nulled~ into the block, you will wind up not immediately getting an error on it...because it will be "friendly" when it is picked via SECOND.  It will just be a type that won't be tolerated later on.</p>
</blockquote>
<p><strong>I may want to fall back to my previous stance that COMPOSE is the better choice for block-building with needs for full vaporization.</strong>  We should still be able to parameterize REDUCE for when you want handling other than erroring or turning into bad-words, as has been demonstrated.  I feel like that might give flexibility without letting people fall into traps here that don't really take advantage of NULL's potential for noticing use of things you didn't quite mean to use.</p>
          <p><a href="https://forum.rebol.info/t/what-should-do-of-empty-block-do-do/1426/15">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/what-should-do-of-empty-block-do-do/1426/15</link>
        <pubDate>Fri, 14 May 2021 13:50:32 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1426-15</guid>
        <source url="https://forum.rebol.info/t/what-should-do-of-empty-block-do-do/1426.rss">What should do of empty block (`DO []`) do?</source>
      </item>
      <item>
        <title>What should do of empty block (`DO []`) do?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="rgchris" data-post="9" data-topic="1426">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/rgchris/40/14_2.png" class="avatar"> rgchris:</div>
<blockquote>
<p>I think if the explanation is sound, then it doesn't matter exactly which semantic model it adheres to.</p>
</blockquote>
</aside>
<p><strong>I think I have a sound explanation for why DO resulting in invisibility should be an ornery value by default, but an invisible value when the caller requests it.</strong></p>
<p>The main reasoning isn't so much about DO of a BLOCK! as it is about DO of a FRAME! that represents an attempt to reliably capture (and possibly tunnel or manipulate) an arbitrary function invocation.</p>
<p>If a caller is not expecting it, invisibility can cause confusion when running a DO:</p>
<pre><code>f: make frame! :comment
f/discarded: "discard me"  ; the argument to comment

result: do f
foo: 1 + 2  ; example of code coming after this
</code></pre>
<p>If the DO behaved as invisible by default, we would wind up with RESULT being 1 + 2.  Clearly bad.</p>
<p>For clients who know what they're doing, a refinement (something like /VOID or /VANISHABLE) is useful, so that the DO can actually disappear...if that is what they meant.  This can come in handy for blocks as well.</p>
<p>But what I like about making it return <code>~void~</code> if used without /VOID is that it helps signal that information is being overlooked.  You asked for a result, so you were presumably interested in the result.  If the reason for using DO is writing some very generic code that operates on frames, then it's nice to have a tripwire to help you know when you've lost information in the exchange.  Returning NULL would gloss over that.</p>
<p>I think it's probably useful to make a "poor man's vanish", where you just assume ~void~ should turn into disappearance.</p>
<pre><code>&gt;&gt; vanish 1020
== 1020

&gt;&gt; 304 vanish print "PRINT returns ~void~, so vanish it"
== 304
</code></pre>
<p>This isn't a fully rigorous mechanism, you shouldn't use it when writing generic function-manipulating mezzanine-type things.  DO is a function that absolutely needs a refinement to get it right.  But it would be crazy if every function that called DO had to have such a refinement too.</p>
<p>Though I'm reviewing now whether the ^ branches should speak the quoted protocol:</p>
<pre><code>&gt;&gt; if true ^[1 + 2]
== '3

&gt;&gt; if false ^[print "Branch Not Run"]
; null

&gt;&gt; if true ^[null]
; null

&gt;&gt; if true [null]
== ~null~  ; isotope

&gt;&gt; if true ^[]
== ~void~  ; isotope

&gt;&gt; if true ^[do [comment "hi"]]
== ~void~
</code></pre>
<p>This makes them less likely to be useful in a mix-and-match scenario, where one branch is ^ convention and others aren't.  But it's more informative than putting the ^ around the IF as  a whole:</p>
<pre><code>&gt;&gt; ^(if true [1 + 2])
== '3

&gt;&gt; ^(if false [print "Branch Not Run"])
; null

&gt;&gt; ^(if true [null])
== ~null~

&gt;&gt; ^(if true [])
== '~void~

&gt;&gt; ^(if true [do [comment "hi"]])
== '~void~ 
</code></pre>
<p>But now that plain ^ exists, it's not a lexical burden to quote inside a block if you want to.  So the advantage of allowing ^-branches is precisely that mix-and-match ability.</p>
<p><strong>Anyway, long story short: I think the void result is the way to go, with a special mode for getting invisibility at the callsite if you want it.</strong></p>
          <p><a href="https://forum.rebol.info/t/what-should-do-of-empty-block-do-do/1426/14">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/what-should-do-of-empty-block-do-do/1426/14</link>
        <pubDate>Fri, 07 May 2021 07:57:38 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1426-14</guid>
        <source url="https://forum.rebol.info/t/what-should-do-of-empty-block-do-do/1426.rss">What should do of empty block (`DO []`) do?</source>
      </item>
      <item>
        <title>What should do of empty block (`DO []`) do?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group quote-modified" data-username="rgchris" data-post="7" data-topic="1426">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/rgchris/40/14_2.png" class="avatar"> rgchris:</div>
<blockquote>
<aside class="quote no-group" data-username="hostilefork" data-post="6" data-topic="1426">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I tried changing <strong><code>do []</code></strong> to be null (and related places where empty blocks had to have <em>an answer</em>) and I don't really see any particularly obvious bad side to it. Nothing crashed.</p>
</blockquote>
</aside>
<p>So we're through the looking glass then? I think it's the right thing to do, we'll see...</p>
</blockquote>
</aside>
<p>Where I'm having a little bit of buyer's remorse on this is actually not with DO, but with PARSE.</p>
<p>I've explained that I think we get a big leg up if we make it possible to use SET-WORD! in combination with a BLOCK! in a parse rule to mean <a href="https://forum.rebol.info/t/separating-parse-rules-across-contexts/313/6"><em>"assign the set-word! with the result of the last value-bearing rule in the block"</em></a>.  This aids in the separating-parse-rules across contexts, because you're bubbling out values...and doing so through the natural order of rules.  This feels like a good direction.</p>
<p>But I've also mentioned that we have to then be careful and <a href="https://forum.rebol.info/t/new-more-powerful-arity-2-into-in-uparse/1555/8">not make too many rules be "value-bearing"</a> in a way that synthesizes results and then discarding them for no reason.</p>
<p>When these two things bump against each other, you're likely going to get cases of people writing:</p>
<pre><code>parse ... [var: [thru ")"]]
</code></pre>
<p>...or something like that.  So we don't want your garden-variety THRU to be synthesizing results and then just throwing it away, hence it's invisible.</p>
<p>We've done the PARSE parallel to assigning the result of an invisible in a GROUP! in DO:</p>
<pre><code>do [..., var: (elide print ")")]
</code></pre>
<p>Something about having VAR be NULL in the parse case feels like you missed a chance to tell people something went wrong.</p>
<p>Having VAR be "ornery" (BAD-WORD!) seems like a sort of bare minimum way of getting a cue at the callsite.  Erroring on the assignment seems like it would be the most helpful.</p>
<p>But maybe the problem here is looking at things like THRU being invisible, vs themselves being returners of BAD-WORD! etc.  Perhaps that's "invisible abuse"; and only things that you are indoctrinated more obviously as invisible (like GROUP!, ELIDE) really return invisibly?</p>
<p>Maybe it's for the best that SOME and THRU return cheap garbage instead of be invisible, then you elide them:</p>
<pre><code> parse "((1))" [x: [some "(", integer!, elide some ")"]]
</code></pre>
<p>Food for thought.  But I do think we need to be careful about rules synthesizing big unwanted values too easily.</p>
<p><strong>We still would need to know what <strong><code>x: []</code></strong> should do, which would be the same as what <strong><code>x: [(print "hi")]</code></strong> would do... since plain GROUP!s are invisible in parse rules.</strong></p>
<p>Consistency here seems good.  Assigning a parse rule that's empty or where everything vaporizes seems it should line up with assigning a DO rule that's empty or where everything vaporizes.</p>
<p>I'll also point out that cascading invisibility through a GROUP! in DO is a parallel problem to cascading invisibility through a BLOCK! in PARSE.  It works in DO:</p>
<pre><code>&gt;&gt; do [1 + 2, elide print "Hi"]
Hi
== 3

&gt;&gt; do [1 + 2, (elide print "Hi")]  ; group around invisible code
Hi
== 3
</code></pre>
<p>The group makes no difference there so.  One would hope you could do a similar thing with a BLOCK! in PARSE:</p>
<pre><code>&gt;&gt; parse [1] [return [integer!, (print "Hi")]]
Hi
== 1

&gt;&gt; parse [1] [return [integer!, [(print "Hi")]]]  ; block around invisible rule
Hi
== 1
</code></pre>
<p>e.g. if a BLOCK! contains all vanishing rules, then the last result is left as is.</p>
<p>This should work with alternates too:</p>
<pre><code>&gt;&gt; parse [1 "a"] [return [integer!, [text! | (print "no text!")]]
== "a"

&gt;&gt; parse [1] [return [integer!, [text! | (print "no text!")]]
no text!
== 1 ; e.g. `[text! | (print "no text!")]` vaporized, leaving the 1
</code></pre>
<p>So I like how this stuff lines up.  Actually implementing it...well...that's another matter.</p>
          <p><a href="https://forum.rebol.info/t/what-should-do-of-empty-block-do-do/1426/13">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/what-should-do-of-empty-block-do-do/1426/13</link>
        <pubDate>Mon, 12 Apr 2021 01:47:24 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1426-13</guid>
        <source url="https://forum.rebol.info/t/what-should-do-of-empty-block-do-do/1426.rss">What should do of empty block (`DO []`) do?</source>
      </item>
      <item>
        <title>What should do of empty block (`DO []`) do?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="6" data-topic="1426">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Having nothing on the line after <code>do []</code> is unsettling to me; it doesn't feel like you've uttered the incantation to declare the "no meaningful result" intention. I prefer:</p>
<pre><code class="lang-auto">&gt;&gt; do []
; null

&gt;&gt;
</code></pre>
</blockquote>
</aside>
<p>So there's another set of equivalencies to consider here: how FUNC treats an empty body, vs. a RETURN with no argument, vs. a DO of an empty block.  Current behavior:</p>
<pre><code>&gt;&gt; one: func [] []
&gt;&gt; one
; null

&gt;&gt; two: func [] [do []]
&gt;&gt; two
; null

&gt;&gt; three: func [] [return]
&gt;&gt; three  ; ornery-but-not-printed-in-console result
</code></pre>
<p>Changing DO of an empty block to return NULL made ONE and TWO equivalent.  But THREE still returns the ornery-but-not-printed-by-the-console thing <em>(pending change: this would be the BAD-WORD! <strong><code>~none~</code></strong>)</em></p>
<h2>ONE and THREE Matching <em>seems</em> Important</h2>
<p>If you showed this to a random person who didn't know the language, they'd probably have a stronger opinion on the equivalencies of ONE and THREE than an opinion about TWO.</p>
<p>But being a less-random person... I can see this as an edge case of not passing RETURN an argument that it has made a concession for you with.  It isn't erroring.  But it's not giving you a full pass...by saying you've made it "under-specified".  So it's fabricating a hot-potato to make a note of that underspecification.</p>
<h2>The Typing Issue Is Worth Considering</h2>
<p>A good reason to make the RETURN case give back the meaningless result is that it's easy to return NULL if you want it:</p>
<pre><code>four: func [] [return null]
</code></pre>
<p>But it's a bit more awkward to return the bad word:</p>
<pre><code>five: func [] [return '~none~]
</code></pre>
<p>You could use this as an argument for saying that having RETURN around makes it easy to get the bad word if you want it, so the body being empty case should remain "pure" in the sense of acting like a DO of a block for substitutability purposes.</p>
<h2>Quick Reminder: NULL vs. ~NONE~ is Interesting</h2>
<p>Because ~NONE~ is notably <em>not</em> NULL, it can trigger THEN.  PRINT uses this distinction in NULL to accomplish an interesting effect:</p>
<pre><code> &gt;&gt; a: "Something", b: null, c: "Something Else"

 &gt;&gt; print [a b c] then [print "We know we output!"]
 Something Something Else
 We know we output!

 &gt;&gt; print [b]
 ; doesn't output anything
</code></pre>
<p>The ability to notice when a PRINT statement was opted out of...either by BLANK! or all its content opting out, is neat.</p>
<p>Another option might be that RETURN would return the isotope NULL ("NULL-2"), which would still give this particular effect without the ornery-ness.  But it wouldn't suppress console display, which is another nice feature.</p>
<h2>I've Thought Plain RETURN meaning "Invisible" is Sketchy</h2>
<p>It seems that a RETURN with no argument meaning that the function has no return value at all would provide an answer to the loophole of "how do I signify the return of absolutely nothing".</p>
<p>You get the tempting ability to chain functions that are invisible, even if you don't know ahead of time that they are:</p>
<pre><code>&gt;&gt; foo: func [action] [return action "Doing A Chain"]

&gt;&gt; 1 + 2, foo :print
"Doing A Chain"

&gt;&gt; 1 + 2, foo :comment
== 3
</code></pre>
<p>On top of my worries that was "weird", I also thought we might want to allow RETURN to take multiple arguments as a convenience...and having this feature wasn't compatible with that.</p>
<p><strong>But things may have changed a bit now that we've gone to saying that invisibility means "void".</strong>  We're taking a common understanding of what the term "void function is" and tying that to "really no value".  So if <code>return</code> gave back really no value...it would be acting like a void function.</p>
<p>And also, I've found that the <code>return @(...)</code> form is really awkward.</p>
<p>So maybe it's not so weird after all, and we should just accept that multi-returns are another way.</p>
<h2>The Right Answer isn't Plain RETURN Returning NULL ("NULL-1")</h2>
<p>That leads us to either a choice between the current state, or making <code>func [] []</code> give back <code>~none~</code> (or ~null~ isotope, if RETURN gave that), or be invisible.  :-/</p>
<p>I'm a bit torn over changing plain RETURN and empty function to be invisible.  Something about seeing the pieces all laid out like this makes that feel like the most elegant solution, with an empty function body (or body of all invisibles) meaning "void" (new sense).</p>
          <p><a href="https://forum.rebol.info/t/what-should-do-of-empty-block-do-do/1426/12">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/what-should-do-of-empty-block-do-do/1426/12</link>
        <pubDate>Sun, 17 Jan 2021 13:55:58 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1426-12</guid>
        <source url="https://forum.rebol.info/t/what-should-do-of-empty-block-do-do/1426.rss">What should do of empty block (`DO []`) do?</source>
      </item>
      <item>
        <title>What should do of empty block (`DO []`) do?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="rgchris" data-post="7" data-topic="1426">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/rgchris/40/14_2.png" class="avatar"> rgchris:</div>
<blockquote>
<p>I think it's the right thing to do, we'll see...</p>
</blockquote>
</aside>
<p>The one test that has me a little bit uneasy is this:</p>
<pre><code>&gt;&gt; do ""
; null
</code></pre>
<p><strong>On the one hand, being able to accept an empty string at face value as "hey, I meant that empty string" is part of the premise of the whole vocabulary of NULL/BLANK! in the first place:</strong></p>
<ul>
<li>
<strong>print null</strong> and thus <strong>print unspaced [() ()]</strong> are errors</li>
<li>
<strong>print _</strong> and thus <strong>print try unspaced [() ()]]</strong> is a no-op (returning NULL)</li>
<li>
<strong>print ""</strong> prints just a newline, assuming you meant no content for line</li>
<li>...hence so does <strong>print unspaced [() "" ()]</strong> etc.</li>
</ul>
<p>If you buy into all this, then instead of being paranoid about the historical ways in which empty strings might sneak in, you accept it for meaning what it does and cure the problem at the edges so that everywhere you have an empty string <em>you mean it</em>.  You have NULL, BLANK!, and now a whole family of BAD-WORD!/VOID! to express other shades of meaning if you had them...not to mention all the other types (tags or issues, etc. etc.)</p>
<p><strong>On the other hand, sometimes you are in a situation where strings are the only medium of exchange, and not reacting to the potential problem they represent feels a little wrong.</strong>  Think for example interfacing with C or JavaScript...(although they both have NULL too, arguably...and <code>rebValue(null)</code> is an error because NULLs can't evaluate).</p>
<p>But maybe NULL is the right balance of reaction to this, and <strong>do ""</strong> returning NULL...instead of being paranoid prickly in some worse way is the coherent behavior of handling what you asked.</p>
<p>Again with make your own safety, anyone who finds themselves running up against problems where DO of empty string is bad can redefine DO in their uses to handle it any way they like...e.g. by failing in the call rather than returning a void:</p>
<pre><code>do: adapt :lib/do [
    if (parse try match text! :source [any space]) [
        fail ["DO received all empty text input"]
    ]
]

&gt;&gt; do "   "
‌** Error: DO received all empty text input
</code></pre>
<p>Now that's <a href="https://www.youtube.com/watch?v=lTvHXnvmmCA">The Sauce</a>...</p>
<hr>
<p>I was curious what the JS console in Chrome and Firefox did when you just hit "enter", and found it interesting to see that neither let you; it has no response.  You have to at least hit "space".  I think that's a bit frustrating in terms of not giving you a way to test the responsiveness.  In any case, hitting space gives you the same response as <code>eval("")</code> which is <code>undefined</code>.</p>
<p>You don't get any particular safety from this:</p>
<pre><code>&gt;&gt; x = eval("")
&lt;- undefined

&gt;&gt; if (x) { console.log("doesn't complain on undefineds?"); }
&lt;- undefined
</code></pre>
<p>JavaScript does actually consider "undeclareds" as different from "undefineds", where a variable explicitly assigned undefined doesn't error on access (only attempts to dereference).  The "undeclared" state might be compared to "unbound".</p>
<p>Anyway, just something to hmm about.</p>
          <p><a href="https://forum.rebol.info/t/what-should-do-of-empty-block-do-do/1426/10">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/what-should-do-of-empty-block-do-do/1426/10</link>
        <pubDate>Thu, 10 Dec 2020 21:34:48 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1426-10</guid>
        <source url="https://forum.rebol.info/t/what-should-do-of-empty-block-do-do/1426.rss">What should do of empty block (`DO []`) do?</source>
      </item>
      <item>
        <title>What should do of empty block (`DO []`) do?</title>
        <dc:creator><![CDATA[rgchris]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="8" data-topic="1426">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I don't know how pivotal this particular point is.</p>
</blockquote>
</aside>
<p>To be clear, I was being a little glib with regard to the absolutism. I think if the explanation is sound, then it doesn't matter exactly which semantic model it adheres to.</p>
          <p><a href="https://forum.rebol.info/t/what-should-do-of-empty-block-do-do/1426/9">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/what-should-do-of-empty-block-do-do/1426/9</link>
        <pubDate>Thu, 10 Dec 2020 20:24:02 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1426-9</guid>
        <source url="https://forum.rebol.info/t/what-should-do-of-empty-block-do-do/1426.rss">What should do of empty block (`DO []`) do?</source>
      </item>
      <item>
        <title>What should do of empty block (`DO []`) do?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="rgchris" data-post="7" data-topic="1426">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/rgchris/40/14_2.png" class="avatar"> rgchris:</div>
<blockquote>
<p>So we're through the looking glass then?</p>
</blockquote>
</aside>
<p>I don't know how pivotal the particular point of <strong><code>do []</code></strong> is.  I don't really think we have code examples where this comes up all that often, which is probably why it hasn't been given that much thought.</p>
<p>OTOH the REDUCE default behavior does come up, I just don't tend to use REDUCE that often compared to COMPOSE.  <strong>reduce ['x: 1 + 2]</strong> seems awkward compared to <strong>compose [x: (1 + 2)]</strong>.  So it's like the only time I would use REDUCE would be to build the "block of precisely N values", and the protection offered by the <code>.non.null</code> has been fine with me so far.</p>
          <p><a href="https://forum.rebol.info/t/what-should-do-of-empty-block-do-do/1426/8">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/what-should-do-of-empty-block-do-do/1426/8</link>
        <pubDate>Thu, 10 Dec 2020 19:59:04 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1426-8</guid>
        <source url="https://forum.rebol.info/t/what-should-do-of-empty-block-do-do/1426.rss">What should do of empty block (`DO []`) do?</source>
      </item>
      <item>
        <title>What should do of empty block (`DO []`) do?</title>
        <dc:creator><![CDATA[rgchris]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="6" data-topic="1426">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I tried changing <strong><code>do []</code></strong> to be null (and related places where empty blocks had to have <em>an answer</em>) and I don't really see any particularly obvious bad side to it. Nothing crashed.</p>
</blockquote>
</aside>
<p>So we're through the looking glass then? I think it's the right thing to do, we'll see...</p>
<p>I'd be interested to dig into this a bit more: <em>"Redbol languages are based on denotational semantics, where the meaning of every expression needs to have a representation"</em>/<em>"I suppose he hasn't read Godel, Escher, Bach"</em>. The first statement seems quite inflexible and possibly restrictive.</p>
          <p><a href="https://forum.rebol.info/t/what-should-do-of-empty-block-do-do/1426/7">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/what-should-do-of-empty-block-do-do/1426/7</link>
        <pubDate>Thu, 10 Dec 2020 19:49:37 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1426-7</guid>
        <source url="https://forum.rebol.info/t/what-should-do-of-empty-block-do-do/1426.rss">What should do of empty block (`DO []`) do?</source>
      </item>
      <item>
        <title>What should do of empty block (`DO []`) do?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="rgchris" data-post="5" data-topic="1426">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/rgchris/40/14_2.png" class="avatar"> rgchris:</div>
<blockquote>
<p>I notice that Ren-C (in R3C as well as current) does vaporize in the case of <code>reduce [( )]</code> which to mind is the same thing.</p>
</blockquote>
</aside>
<p>That's a more universal rule about GROUP!:</p>
<p><a href="https://forum.rebol.info/t/permissive-group-invisibility/1153"><em>"groups just group things, they don't synthesize any VOID!s (or NULL) or artificial values of their own."</em></a></p>
<p>I tried changing <strong><code>do []</code></strong> to be null (and related places where empty blocks had to have <em>an answer</em>) and I don't really see any particularly obvious bad side to it.  Nothing crashed.</p>
<p>One thing that feels better is to have it show <code>null</code> in the console than to do the same thing that a "function without a meaningful return result" does;</p>
<pre><code>&gt;&gt; print "There's nothing on the next line, and that's okay for PRINT."
There's nothing on the next line, and that's okay for PRINT.

&gt;&gt; do []

&gt;&gt;
</code></pre>
<p>Having nothing on the line after <code>do []</code> is unsettling to me; it doesn't feel like you've uttered the incantation to declare the "no meaningful result" intention.  I prefer:</p>
<pre><code>&gt;&gt; do []
; null

&gt;&gt;</code></pre>
          <p><a href="https://forum.rebol.info/t/what-should-do-of-empty-block-do-do/1426/6">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/what-should-do-of-empty-block-do-do/1426/6</link>
        <pubDate>Thu, 10 Dec 2020 18:26:05 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1426-6</guid>
        <source url="https://forum.rebol.info/t/what-should-do-of-empty-block-do-do/1426.rss">What should do of empty block (`DO []`) do?</source>
      </item>
      <item>
        <title>What should do of empty block (`DO []`) do?</title>
        <dc:creator><![CDATA[rgchris]]></dc:creator>
        <description><![CDATA[
            <p>I hadn't pondered the absolutism of REDUCE. I've embraced your concept of vaporization for UNSPACED/SPACED/COMPOSE and don't see why REDUCE would be different. I notice that Ren-C (in R3C as well as current) does vaporize in the case of <code>reduce [( )]</code> which to mind is the same thing.</p>
          <p><a href="https://forum.rebol.info/t/what-should-do-of-empty-block-do-do/1426/5">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/what-should-do-of-empty-block-do-do/1426/5</link>
        <pubDate>Thu, 10 Dec 2020 14:06:24 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1426-5</guid>
        <source url="https://forum.rebol.info/t/what-should-do-of-empty-block-do-do/1426.rss">What should do of empty block (`DO []`) do?</source>
      </item>
      <item>
        <title>What should do of empty block (`DO []`) do?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>A post was split to a new topic: <a href="/t/the-naming-of-null-and-void/1427">The Naming of NULL and VOID!</a></p>
          <p><a href="https://forum.rebol.info/t/what-should-do-of-empty-block-do-do/1426/2">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/what-should-do-of-empty-block-do-do/1426/2</link>
        <pubDate>Thu, 10 Dec 2020 09:09:16 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1426-2</guid>
        <source url="https://forum.rebol.info/t/what-should-do-of-empty-block-do-do/1426.rss">What should do of empty block (`DO []`) do?</source>
      </item>
      <item>
        <title>What should do of empty block (`DO []`) do?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="rgchris" data-post="1" data-topic="1427">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/rgchris/40/14_2.png" class="avatar"><a href="https://forum.rebol.info/t/the-naming-of-null-and-void/1427/1">The Naming of NULL and VOID!</a>
</div>
<blockquote>
<p>Either way, I feel <code>do []</code> should vaporize:</p>
<pre><code>   reduce [do []] =&gt; []
</code></pre>
</blockquote>
</aside>
<p>The historical rule is that nothing vaporizes by default in REDUCE.  If you have N expressions in, you will have N values out.  <a href="https://forum.rebol.info/t/why-or-why-not-have-unset-in-rebol-like-languages/113/2">There is a religiosity about it in Red</a>.</p>
<p>Ren-C has one avenue for bending it with invisibles like ELIDE and COMMENT.  But if something returns NULL, the current way of preserving the rule is to default to an error:</p>
<pre><code>&gt;&gt; reduce [null]
** Script Error: [null] needs a value, can't be null
</code></pre>
<p>That's because the "default predicate" is <strong>.non.null</strong></p>
<p>But you can supply your own, asking REDUCE to do different transformation on your results before the new block is made:</p>
<pre><code>&gt;&gt; reduce .negate [1 + 1 2 + 2]
== [-2 -4]
</code></pre>
<p>If you use BADIFY then you will get ~null~ BAD-WORD!s instead of an error:</p>
<pre><code>&gt;&gt; reduce .badify [null]
== [~null~]
</code></pre>
<p>And if you use IDENTITY then you overrule the default .non.null predicate, and since NULLs are okay they pass through as-is and will vaporize:</p>
<pre><code>&gt;&gt; reduce .identity [null]
== []
</code></pre>
<p>Of course there's also TRY.</p>
<pre><code>&gt;&gt; reduce .try [null]
== [_]
</code></pre>
<p>I don't know what the best defaults are, but here we see all available options, pretty much.</p>
<p>If you think <strong>reduce [do []]</strong> should be <strong>[]</strong> then you should put that together as a complete thought, in light of all the information presented here.  That would require both DO [] to be NULL and REDUCE to default to the .identity predicate.</p>
<pre><code> &gt;&gt; reduce ["Bear in mind this will" if false ["not"] "make you a Red heretic"]
 == ["Bear in mind this will" "make you a Red heretic"]
</code></pre>
<p>The risks of choosing it as a default come when you are building blocks and you run up against something like a select that failed when you didn't know it was going to, throwing off your positions.  I felt it was a legitimate concern, so I didn't mind hiding it behind an option.</p>
<p>We could also give these operations distinct names, if we can think of them.</p>
<p>The "make your own safety" philosophy sort of biases this kind of decision to where you let people decide if they're tripping across a certain category of bug, and if so build their own responses to it.  As long as it's easy for people to use <strong>reduce .non.null [...]</strong> or specialize it that way, that might be te best answer.</p>
<h2>If <code>do []</code> returns NULL, should an empty function return NULL?</h2>
<pre><code>&gt;&gt; foo: func [] []

&gt;&gt; foo
; null

&gt;&gt; if foo [print "Does it matter this doesn't error?"]
; null
</code></pre>
<p>I don't know that I see a particularly strong case for why an error would be needed there.  But again, this is running against some historical behaviors</p>
<pre><code> rebol2&gt;&gt; foo: func [] []
 rebol2&gt;&gt; foo
 rebol2&gt;&gt; if foo [print "Does it matter if this doesn't error?"]
 ** Script Error: if is missing its condition argument
</code></pre>
<p>Although in bizarro Red land, unset! is truthy:</p>
<pre><code>&gt;&gt; foo: func [] []
&gt;&gt; foo
&gt;&gt; if foo [print "Red has truthy unsets, so no error here."]
Red has truthy unsets, so no error here.
</code></pre>
<p>If we're to glean any information out of that, it might be that there's no "must preserve" instinct on this particular avenue of error.</p>
<p>We no longer have to go down a line of reasoning which might have said <code>if true []</code> needed to discern its result from <code>if false []</code>, so that tying into what <code>do []</code> needs to produce to get that discernment.  That was already suspicious, and the issue is attacked another way now.</p>
<p>Anyway, going with the null instinct is a less "conservative" choice because it doesn't draw attention to the "strange" case and say "did you mean to do that?".  <strong>However, if nobody can think of a time when <code>do []</code> returning UNSET!/BAD-WORD!/VOID!-what-have-you saved your butt, then it must not have saved your butt very often.</strong></p>
          <p><a href="https://forum.rebol.info/t/what-should-do-of-empty-block-do-do/1426/3">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/what-should-do-of-empty-block-do-do/1426/3</link>
        <pubDate>Thu, 10 Dec 2020 05:19:49 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1426-3</guid>
        <source url="https://forum.rebol.info/t/what-should-do-of-empty-block-do-do/1426.rss">What should do of empty block (`DO []`) do?</source>
      </item>
      <item>
        <title>What should do of empty block (`DO []`) do?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>I've pointed out that the answer for things like "what should a loop that never runs its body" have varied.</p>
<pre><code>rebol2/r3-alpha&gt;&gt; type? while [false] ["whatever"]
== none!

red&gt;&gt; type? while [false] ["whatever"]
== unset!
</code></pre>
<p>But it's consistent historically that if something runs <strong>do []</strong> then you get an "UNSET!"</p>
<pre><code>rebol2/r3-alpha/red&gt;&gt; type? do []
== unset!
</code></pre>
<h2>New Names Available</h2>
<p>One of the benefits of having lots of different labeled BAD-WORD!s is to stop collapsing all "potentially error-triggering situations" into the same uninformative name.</p>
<pre><code>&gt;&gt; do []
== ~empty~  ; isotope
</code></pre>
<p>Or maybe that's considered to be where ~void~ isotopes comes from:</p>
<pre><code>&gt;&gt; do []
== ~void~  ; isotope
</code></pre>
<p>In either case, you've still got a type that will be "ornery" and neither true nor false, that errors if you try to access it.  But by not reporting <code>~unset~</code> you're helping to convey that this wasn't the by-product of encountering an unset variable somewhere.  It might help people get their bearings more easily.</p>
<p>I've mentioned that this is a bit unfortunate in the sense of canonizing English into the evaluator mechanics.  But I'm taking away the option by <a href="https://forum.rebol.info/t/void-choices-the-role-of-english-in-the-evaluator/1413/6">removing <code>~</code> as a form of BAD-WORD!</a>...which is what this case had been before.</p>
<h2>Or Is This A Job For NULL ?</h2>
<p>We have some cases where emptiness produces pure NULL.  With DELIMIT and its specializations, an all empty block produces the same thing that an all-NULL-producing block produces:</p>
<pre><code>&gt;&gt; unspaced [if false ["a"] if false ["b"]]
; null

&gt;&gt; unspaced []
; null

&gt;&gt; unspaced compose [(if false ["a"]) (if false ["b"])]
; null
</code></pre>
<p>There's some neat combining of this with PRINT.  Although PRINT draws your attention to calling with NULL via error, a BLANK! will get it to overlook that and just be a no-op:</p>
<pre><code>&gt;&gt; print unspaced compose [(if false ["a"]) (if false ["b"])]
** error, print doesn't take NULL

&gt;&gt; print try unspaced compose [(if false ["a"]) (if false ["b"])]
; null
</code></pre>
<p><strong>Can anyone think of a case where there's a balance of provable value for something like a <code>do compose [...]</code> whose contents have all boiled away to be NULL instead of ~void~ ?</strong></p>
<p>You could get the same result by saying <strong>do compose [null (...whatever...)]</strong> so it's not far out of reach to have a default value of anything you like.</p>
          <p><a href="https://forum.rebol.info/t/what-should-do-of-empty-block-do-do/1426/1">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/what-should-do-of-empty-block-do-do/1426/1</link>
        <pubDate>Wed, 09 Dec 2020 23:45:38 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1426-1</guid>
        <source url="https://forum.rebol.info/t/what-should-do-of-empty-block-do-do/1426.rss">What should do of empty block (`DO []`) do?</source>
      </item>
  </channel>
</rss>
