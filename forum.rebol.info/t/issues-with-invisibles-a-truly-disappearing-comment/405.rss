<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Issues with &quot;Invisibles&quot;: a truly disappearing COMMENT</title>
    <link>https://forum.rebol.info/t/issues-with-invisibles-a-truly-disappearing-comment/405</link>
    <description>So @MarkEye brought back up an idea that has crossed my mind every few months, about what it would take to make something that was truly &quot;less than null&quot;.  Some way of returning a complete-absence-of-information, *including even information about the absence of a value*.  :-/

The most &quot;obvious&quot; application most people would jump to *(which turns out--in fact--not to be so obvious at all)* would be COMMENT.  So imagine:

    9 = do [1 + comment &quot;a&quot; comment &quot;b&quot; 2 * 3]
    9 = do [1 comment &quot;a&quot; + comment &quot;b&quot; 2 * 3]
    9 = do [1 + comment &quot;a&quot; comment &quot;b&quot; + 2 * 3]

Despite the simple appearance, there&#39;s a lot of holistic concerns of such a thing showing up in the Rebol ecology.  Here&#39;s some:

**&quot;I&#39;ve made an acid that can eat through anything...&quot;**

This can&#39;t come down to returning a new type of value (e.g. a COMMENT!).  Because what would happen in your function when you said `return make comment! ...`?  It would be skipped.

How would you test for them?  `if comment? c [print &quot;it&#39;s a comment&quot;]` would turn into `if comment? [print &quot;it&#39;s a comment&quot;]`

Having it as a value type is not an option, so it would have to be some new character of the function definition itself.

**You can&#39;t &quot;GROUP! them&quot; and keep their semantics**

One might ask if there should be a difference between these two statements:

     1 + comment &quot;a&quot; 2
     1 + (comment &quot;a&quot;) 2

COMMENT isn&#39;t a very motivating scenario, it&#39;s single-arity and it quotes.  But what if you had a more complex operation in this class, with multiple arguments, including evaluated ones?

Rebol has used `()` as a &quot;null generator&quot; for a long time.  But might it be revisited so that GROUP!s that wound containing no content--or just comments--to vaporize?  That would mean all these were the same when running DO?

    1 + comment &quot;a&quot; 2
    1 + (comment &quot;a&quot;) 2
    1 + () 2
    1 + 2

The short answer is **No**.  The long answer is **N: (o)**

&gt; **UPDATE:** Later it was decided the real answer is actually much longer--it rules out these particular cases, [while allowing groups to vaporize in interstitial positions](https://forum.rebol.info/t/what-to-do-about-do-and/772).  Hence **you can group them and keep their (absence of) content**, but you can&#39;t put those invisibled groups in some spots you could have put them without the group.
&gt;
&gt; **UPDATED UPDATE**: In practice, having **N: (...invisible...) 1** be equivalent to **N: 1** does have meaningful applications.  This is due to the expanded scope of invisibles beyond commenting, they truly have turned out to be useful for non-invasive debug constructs.  The existence of **`do`** for always returning a value can help in scenarios where you are running generic code you don&#39;t understand and want to be sure it doesn&#39;t vaporize...such code is usually in a variable anyway!  So the use case of GROUP!s being more &quot;ghostly&quot; is actually something that makes their character unique.  [See expanded reasoning.](https://forum.rebol.info/t/permissive-group-invisibility/1153)

**1** key reason for using groups in the first place is to show the structure in a stream of varying arity.  It provides an anchor to be able to say &quot;that one GROUP! will turn into exactly one complete value, or it will error&quot;.  So if **o** vaporized in the **(o)** above, should **N** be 1 now?  :confused: 

Pulling the rug out from under that with &quot;zero or one values&quot; would have to be *very* worth it.  And it&#39;s very not.  If an expression wants to be invisible and look convenient, make it a dialect and let it take a block:

    1 i&#39;m-invisible a &lt;b&gt; #c &#39;d + 2    ;-- don&#39;t define it like this
    1 (i&#39;m-invisible a &lt;b&gt; #c &#39;d) + 2  ;-- b/c this is void, not invisible

    1 i&#39;m-invisible [a &lt;b&gt; #c &#39;d] + 2 ;-- define it like this

**Interaction with DO/NEXT..._all invisible functions are effectively enfix_**

This is the biggest issue.  Basically, a DO/NEXT cannot finish until it has consumed all these &quot;invisible&quot; expressions.  Consider:

    pos: _
    do/next [1 + 2 comment &quot;a&quot; * 3] &#39;pos

For COMMENT to be truly &quot;invisible&quot;, then that should act as `1 + 2 * 3`.  And the only way it can do so is if when it reaches the `comment &quot;a&quot;` that it eagerly continues processing, so it can find out if there&#39;s anything on the other side.

Furthermore, the only way to be actually &quot;invisible&quot; is not to damage the evaluator stack at all.  You don&#39;t want the presence of the comment above to suddenly turn `1 + 2 * 3` into the semantics of `1 + (2 * 3)`.  That means the comment needs to be dissolved right at the moment the 2 is evaluated, so it can be seen past.

Technically this is easy enough to do, but the results might surprise someone.  Let&#39;s imagine you think it would be cool to modify something like the variable DUMP function to be one of these &quot;invisibles&quot;.   So you might write:

     x: 1 + 2 dump [x] * 3

That seems pretty cool, and intuitive in this case that when you dump X it hasn&#39;t been assigned yet--the expression isn&#39;t completed.  But would it be as intuitive if you saw:

    x: 1 + 2
    dump [x]

One might expect 3.  But as the example above it shows, you can&#39;t get that invisible property that way.  If you did, then DO/NEXT would treat that as two expressions.

**Is it best to be honest and just call these enfix functions?**

Rather than getting into the complex details of defining a new category of functions that are &quot;kind of exactly like enfix functions&quot;, should we just say that&#39;s what they are?  They&#39;re basically enfix functions which can pipe their left hand argument to the output in a transparent way.  Says @MarkEye:

&gt; For the purposes of explication, can one consider COMMENT to be a tight infix operator that &quot;returns&quot; its left-hand side? (haha and its left-hand side is allowed to be empty!) Example: `do/next [comment &quot;thrillsville&quot;]` should behave exactly like `do/next []`, shouldn&#39;t it?

There are a few technical challenges to implementing true transparency in this way, given that there is no END! datatype (yet behaviors can be distinguished internally to the evaluator between end and null).  It could be worked past with some kind of `return/proxy` function that you just point at the argument you want to telegraph, and the evaluator takes care of it.

We don&#39;t want to increase the number of parts in the box unnecessarily, so piggybacking on ENFIX may be okay.  And also, making it a generic enfix mechanism means someone could design such an abstraction with non-tight semantics as well (if they&#39;re okay with non-total-invisibility).

But it may be &quot;weird&quot;, and surprise someone who types HELP COMMENT and wonders why it&#39;s not the &quot;naive&quot; form.  Or as @MarkEye says it &quot;explicates&quot; the situation.  Hiding the &quot;latching&quot; behavior on the previous result would only obscure the process. 

Thoughts??</description>
    
    <lastBuildDate>Fri, 03 Aug 2018 21:55:48 +0000</lastBuildDate>
    <category>Internals</category>
    <atom:link href="https://forum.rebol.info/t/issues-with-invisibles-a-truly-disappearing-comment/405.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Issues with &quot;Invisibles&quot;: a truly disappearing COMMENT</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group quote-modified" data-post="1" data-topic="405">
<div class="title">
<div class="quote-controls"></div>
<img alt width="20" height="20" src="//forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Rebol has used () as a “void generator” for a long time.  But might it be revisited so that GROUP!s that wound containing no content–or just comments–to vaporize?  That would mean all these were the same when running DO?</p>
<pre><code>1 + comment "a" 2
1 + (comment "a") 2
1 + () 2
1 + 2
</code></pre>
<p>The short answer is No.</p>
</blockquote>
</aside>
<p>So I do think these examples of GROUP!s vanishing without feedback are bad.  But the reason that they are bad is because they are in argument fulfillment positions.</p>
<p>When you are between expressions, it's not really an issue if something vaporizes or not.  And probably preferable if it does.</p>
<p>So what I've got going is this:</p>
<pre><code>&gt;&gt; 1 + comment "a" 2
== 3

&gt;&gt; 1 + (comment "a") 2
** Script Error: + is missing its value2 argument

&gt;&gt; 1 + () 2
** Script Error: + is missing its value2 argument

&gt;&gt; 1 + 2
== 3
</code></pre>
<p>But then, also, this...</p>
<pre><code>&gt;&gt; block: [1 + comment [2 * 3] 4 elide print "Outside" (comment "inside") | |]
== [1 + comment [2 * 3] 4 elide print "Outside" (comment "inside") | |]

&gt;&gt; do block
Outside
== 5

&gt;&gt; block: try evaluate/set block 'val
== [elide print "Outside" (comment "inside") | |]

&gt;&gt; val
== 5

&gt;&gt; block: try evaluate/set block 'val
Outside
== _

&gt;&gt; val
== 5
</code></pre>
<p>It may be the best of both worlds.  GROUP!s don't synthesize any values that aren't there and act like invisibles.  But if they're empty, they have the behavior of expression barriers.</p>
          <p><a href="https://forum.rebol.info/t/issues-with-invisibles-a-truly-disappearing-comment/405/7">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/issues-with-invisibles-a-truly-disappearing-comment/405/7</link>
        <pubDate>Fri, 03 Aug 2018 21:55:48 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-405-7</guid>
        <source url="https://forum.rebol.info/t/issues-with-invisibles-a-truly-disappearing-comment/405.rss">Issues with &quot;Invisibles&quot;: a truly disappearing COMMENT</source>
      </item>
      <item>
        <title>Issues with &quot;Invisibles&quot;: a truly disappearing COMMENT</title>
        <dc:creator><![CDATA[gchiu]]></dc:creator>
        <description><![CDATA[
            <p>One idea for using invisibles is to chain functions where you make some functions disappear from the chain if they're not needed.</p>
<p>Imagine an image processor where you apply sequential effects but only the ones specify as refinements.</p>
<pre><code>imagemagick: func [ data 
    /monochrome
    /sharpen
    /blur
    /pixelise
][
    ... code ..
    sharpen: me ?? :sharpenf !! :nilhil
    blur: me ?? :blurf !! :nihil
    pixelise: me ?? :pixelf !! :nihil

    return sharpen blur pixelise data
]

imagemagick/sharpen imagedata
</code></pre>
<p>giving a much cleaner look.  If the refinements are absent, the functions just disappear.</p>
          <p><a href="https://forum.rebol.info/t/issues-with-invisibles-a-truly-disappearing-comment/405/6">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/issues-with-invisibles-a-truly-disappearing-comment/405/6</link>
        <pubDate>Mon, 14 May 2018 21:20:56 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-405-6</guid>
        <source url="https://forum.rebol.info/t/issues-with-invisibles-a-truly-disappearing-comment/405.rss">Issues with &quot;Invisibles&quot;: a truly disappearing COMMENT</source>
      </item>
      <item>
        <title>Issues with &quot;Invisibles&quot;: a truly disappearing COMMENT</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="2" data-topic="405">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>If a user looks at the definition and implementation of ELIDE, and sees it's tricky with a grab and route of enfix left tight to output, they will feel they're getting what they pay for--and be impressed.  If they meet it someday in the debugger, they won't be shocked by what it does...because it has to do that.</p>
<p>But for the modest user who was just trying to use COMMENT, make plain-old COMMENT look plain-old, but back it with new tech</p>
</blockquote>
</aside>
<p>I wound up swapping my stance on this, in terms of which-operator-should-get-which-technique.</p>
<p>ELIDE's unpredictability of moment-of-evaluation made it really only useful if it had no side-effects.  Which is to say, it was really only useful when it acted like a truly-invisible comment.</p>
<p>When ELIDE was changed to use the "simpler" (yet not truly invisible) mechanic, it became easy to use...and it could drop the requirement for its argument to be in a GROUP!.  This simple mechanic is applicable to those who wish to study it and make things like DUMP...all they have to do is make it <code>return []</code>.</p>
<p>Meanwhile, the number of COMMENT-like abstractions is likely to be very few...because COMMENT pretty much covers it.  It can have a somewhat more wily definition with the argument that it needs to, because it seeks the "true invisibility".</p>
<blockquote>
<p><strong>UPDATE:</strong> It seems I spoke too soon on COMMENT being the only comment-like thing you need.  It turns out even that had more directions to go with <a href="https://forum.rebol.info/t/comment-to-end-of-line-with/920">being variadic and detecting to end of line</a>.  Who knows how many more uses might come up?</p>
</blockquote>
<p>This opened up a number of doors, including to retake ALSO and kill AFTER, since a usable ELIDE is more flexible than either:</p>
<aside class="onebox githubcommit">
  <header class="source">
      <a href="https://github.com/metaeducation/ren-c/commit/bc2b9ff75eb0ecd3824282533011b3481ac234af" target="_blank" rel="noopener">github.com/metaeducation/ren-c</a>
  </header>
  <article class="onebox-body">
    <div class="github-row">
  <div class="github-icon-container" title="Commit">
    <svg width="60" height="60" class="github-icon" viewBox="0 0 14 16" aria-hidden="true"><path d="M10.86 7c-.45-1.72-2-3-3.86-3-1.86 0-3.41 1.28-3.86 3H0v2h3.14c.45 1.72 2 3 3.86 3 1.86 0 3.41-1.28 3.86-3H14V7h-3.14zM7 10.2c-1.22 0-2.2-.98-2.2-2.2 0-1.22.98-2.2 2.2-2.2 1.22 0 2.2.98 2.2 2.2 0 1.22-.98 2.2-2.2 2.2z"></path></svg>
  </div>

  <div class="github-info-container">
    <h4>
      <a href="https://github.com/metaeducation/ren-c/commit/bc2b9ff75eb0ecd3824282533011b3481ac234af" target="_blank" rel="noopener">Repurpose ALSO, kill after, add THEN, swap ELIDE/COMMENT behavior</a>
    </h4>

    <div class="github-info">
      <div class="date">
        committed <span class="discourse-local-date" data-format="ll" data-date="2018-01-28" data-time="09:39:11" data-timezone="UTC">09:39AM - 28 Jan 18 UTC</span>
      </div>

      <div class="user">
        <a href="https://github.com/hostilefork" target="_blank" rel="noopener">
          <img alt="hostilefork" src="https://avatars1.githubusercontent.com/u/20440?v=4" class="onebox-avatar-inline" width="20" height="20">
          hostilefork
        </a>
        
      </div>

      <div class="lines" title="changed 17 files with 167 additions and 124 deletions">
        <a href="https://github.com/metaeducation/ren-c/commit/bc2b9ff75eb0ecd3824282533011b3481ac234af" target="_blank" rel="noopener">
          <span class="added">+167</span>
          <span class="removed">-124</span>
        </a>
      </div>
    </div>

  </div>
</div>


  <div class="github-row">
    <pre class="github-content" style="white-space: normal;">The ELIDE routine was originally designed as an attempt to create a
"truly invisible" comment. If given a BLOCK!, it would act...</pre>
  </div>


  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

          <p><a href="https://forum.rebol.info/t/issues-with-invisibles-a-truly-disappearing-comment/405/5">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/issues-with-invisibles-a-truly-disappearing-comment/405/5</link>
        <pubDate>Mon, 29 Jan 2018 07:06:19 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-405-5</guid>
        <source url="https://forum.rebol.info/t/issues-with-invisibles-a-truly-disappearing-comment/405.rss">Issues with &quot;Invisibles&quot;: a truly disappearing COMMENT</source>
      </item>
      <item>
        <title>Issues with &quot;Invisibles&quot;: a truly disappearing COMMENT</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>Both ELIDE and COMMENT <a href="https://github.com/metaeducation/ren-c/commit/1f284aaf7a8dafc398d7c158eff2a105710070c9" rel="nofollow noopener">seem to be working</a>, though the comment style is not as strict as to only work in expression-barrier slots.  It forces the left to completion as far as it can, but accepts being in a parameter slot when it reaches the limit.  We can decide if this is too permissive, and it should raise an error if it can't complete <em>all</em> the parameters of a function.</p>
<p>Though it only has <a href="https://github.com/metaeducation/ren-c/blob/master/tests/functions/invisible.test.reb" rel="nofollow noopener">a few explicit tests</a> at the moment, it has survived boot and a bootstrap build.  And some other abstractions, some of which are committed.  So please add more tests, or propose "can it do...this?" cases.</p>
<p><strong>I'm curious what kinds of ideas people have for what to do with these mechanics...besides just debug output / breakpoints / comments...</strong></p>
<p>It seems like it could be useful in code-generating systems, where you want a side-effect to happen at certain moments but you don't want to break the emitter stream of the expression you're building.  I don't know.</p>
<p>Maybe it could be getting more competitive with Forth in the stack area, with the ability to invisibly PUSH expressions without having to worry about that being observed by your current expression pipe.<br>
But then a non-invisible POP could get the expressions back off?</p>
<p>Hopefully food for thought.</p>
          <p><a href="https://forum.rebol.info/t/issues-with-invisibles-a-truly-disappearing-comment/405/4">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/issues-with-invisibles-a-truly-disappearing-comment/405/4</link>
        <pubDate>Sun, 03 Dec 2017 16:22:34 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-405-4</guid>
        <source url="https://forum.rebol.info/t/issues-with-invisibles-a-truly-disappearing-comment/405.rss">Issues with &quot;Invisibles&quot;: a truly disappearing COMMENT</source>
      </item>
      <item>
        <title>Issues with &quot;Invisibles&quot;: a truly disappearing COMMENT</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>I want to make a quick point:</p>
<pre><code>pos: _
do/next [1 + 2 comment "hi" 7 + 9] 'pos
</code></pre>
<p>You might think it's equally viable for POS to come back as <code>[comment "hi" 7 + 9]</code> and leave the comment for the next processing step, as it is for it to take care of the comment in the first step.  You can still have the first step evaluate to 3 and the second step evaluate to 16.</p>
<p>But that only works because there was something after it.  The stated goal is that <code>do [1 + 2 comment "hi"]</code> come back with 3.  So what if the <code>7 + 9</code> hadn't been there?  You'd wind up with POS as just <code>[comment "hi"]</code>, and that would become void...a DO/NEXT of that can't fabricate 3 out of thin air.  Hence running several DO/NEXTs on the block would have a different outcome from DO...<em>which is bad</em>.</p>
<p>It might seem a little weird to consider all COMMENTs as being part of an expression that precedes it.  But that's how the directional arrow of Rebol's evaluation dictates it.</p>
<blockquote>
<p><strong>UPDATE:</strong> This was overturned some months later with a <a href="https://forum.rebol.info/t/re-imagining-do-next-now-called-evaluate/767">clever reimagination of DO/NEXT</a>...allowing to <em>not</em> glue invisible constructs with the evaluation on their left.  It's an important development that has made invisibles act as one expects in control flow, making their use much easier.</p>
</blockquote>
          <p><a href="https://forum.rebol.info/t/issues-with-invisibles-a-truly-disappearing-comment/405/3">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/issues-with-invisibles-a-truly-disappearing-comment/405/3</link>
        <pubDate>Sun, 03 Dec 2017 10:49:08 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-405-3</guid>
        <source url="https://forum.rebol.info/t/issues-with-invisibles-a-truly-disappearing-comment/405.rss">Issues with &quot;Invisibles&quot;: a truly disappearing COMMENT</source>
      </item>
      <item>
        <title>Issues with &quot;Invisibles&quot;: a truly disappearing COMMENT</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>So the reason I'm asking these questions is I actually wrote a first take on "invisible" functions.  You would depict them by putting in their function spec that they really returned <em>no</em> type at all.  (e.g. <strong>return: []</strong>).  This necessarily meant that they couldn't return any other types... (this is why that doesn't mean void, because sometimes you want to return a void as well as other types as a set, hence <code>&lt;opt&gt;</code>).</p>
<p>The code I wrote is nuanced differently than enfix, and optimized, with interesting aspects.  I'm a bit loathe to backpedal on those developments and surrender to the kind-of-<em>meh</em>-excuse of "let them use ENFIX".</p>
<h1>a hybrid option...</h1>
<hr>
<p><strong>Introduce a tricky enfix operator, maybe with a tricky name like <code>ELIDE</code></strong></p>
<p>COMMENT was long ago changed to disallow active parameters like GROUP!, because <code>comment (1 + 2)</code> looks confusing.  So does <code>comment print x</code> (was that what you actually wanted?).  It's was easy enough to put things in blocks--so seemed better to put it in a block that shows more clearly what you meant.</p>
<p>So hybrid plan step one: make an enfix operator in the spirit that <a class="mention" href="/u/markeye">@MarkEye</a> was mentioning, that's fancy and pipes left tight to output regardless of args.  For now I'll call it <strong><a href="https://en.wikipedia.org/wiki/Elision" rel="nofollow noopener">ELIDE</a></strong>.</p>
<p>Imagine if you give it a BLOCK! it won't evaluate the contents, but if you give it a GROUP! it will, etc.  (More or less, a version of EVAL that "elides" its result value).  This could provide invisible injections in the middle of any location in your evaluation stream:</p>
<pre><code>x: 10
y: 1 + elide (print x) 2
</code></pre>
<p><em>(Tech note: To make ELIDE with today's enfix, one has to effectively "see an end" on its "left"--which is actually "up" into into the argument acquisition.  It needs to have special behavior w.r.t. simulating 2 as the only thing there.  We could imagine such magic telegraphing powers being given to all enfix, er, somehow.)</em></p>
<p>ELIDE can also be the multi-line arbitrary endpoint COMMENT you always wanted but were afraid to ask for:</p>
<pre><code> x: 10
 y: 1 elide [+ 2
 z: 30] + 7
</code></pre>
<p><em>(Note you cannot do that by wrapping the code in a curly-brace string.)</em></p>
<p>If a user looks at the definition and implementation of ELIDE, and sees it's tricky with a grab and route of enfix left tight to output, they will feel they're getting what they pay for--and be impressed.  If they meet it someday in the debugger, they won't be shocked by what it does...because it has to do that.</p>
<p>But for the modest user who was just trying to use COMMENT...</p>
<hr>
<p><strong>Make plain-old COMMENT look plain-old, but back it with new tech</strong></p>
<p>The above ELIDE operation can be done roughly with existing ENFIX, tweaked slightly.  But let's say COMMENT's definition is:</p>
<pre><code>comment: func [
    return: []
    :value [block! any-string! binary! any-scalar!]
][
    ; nada
]
</code></pre>
<p>And let's say since it has <code>return: []</code> (or however we want to spec this) means <strong>COMMENT forces completion of the left hand side, or it will error</strong>.  Like an expression barrier would.</p>
<p>So <em>unlike ELIDE</em>, COMMENT disrupts order of an in-progress evaluation, to the point where it never acts enfix.  This isn't going to jolt anyone's world--because no one used COMMENT mid-stream in evaluations before (it would leave behind voids and corrupt the expression).</p>
<p>But <em>like ELIDE</em>, this new COMMENT would not disrupt the value dropping out.</p>
<pre><code>&gt;&gt; do [x: 10 + 20 comment "KOY4GOFF"]
== 30
</code></pre>
<p>So rather than acting "enfix", it acts more like today's expression barrier.  Not only does today's expression barrier force left expressions to finish, it optimizes itself out by flushing... if you say <strong>do/next [| | | 1 + 2]</strong> they all get processed in that same DO/NEXT operation.)</p>
<hr>
<p><strong>An even deeper motivation: -avoiding- a new parameter type</strong></p>
<p>I've tried to sell the above on its plausible-merits-to-the-layman, without talking about the "esoteric" case that actually made me come up with it.  But in the beginning when I was making the <strong><code>&lt;|</code></strong> and <strong><code>|&gt;</code></strong>, I wanted:</p>
<pre><code> &gt;&gt; x: 1 + 2 * 3 &lt;| print ["x is" x] blah blah blah
 x is 9
 == 9
</code></pre>
<p>I wanted an operator that could ask for the left hand side to be completed fully, and this was my motivating case.  I didn't like this being interpreted as:</p>
<pre><code> x: 1 + 2 * (3 &lt;| print ["x is" x] blah blah blah)
</code></pre>
<p>And as <a class="mention" href="/u/markeye">@MarkEye</a> will remember, I very much wanted a model of enfix that permitted it.  But really, this is the only operator in that class, <em>and it doesn't even care what the right hand side evaluates to</em>, <em>nor does it want to see the left hand result</em>.  It doesn't want to be parameterized by the left hand side, it wants to elide itself.</p>
<p>Left-completion could be a way to do it.  But ordinary evaluative enfix could not force completion of the left, because of:</p>
<pre><code> return if x &lt; 10 [20] else [304]
</code></pre>
<p>If more than one unit of expression got evaluated on the left--taken to its logical conclusion--you'd get return happening before ELSE had a chance:</p>
<pre><code> (return if x &lt; 10 [20]) else [304]
</code></pre>
<p>And the <span class="hashtag">#tight</span> parameter class was deemed necessary for other reasons.  So would we be needing <span class="mention">@full</span> parameters?</p>
<pre><code> &gt;&gt; foo: func [@x] [print x]
 &gt;&gt; foo "a" "b" "c"
 == "c" ;-- Variadics can do this, but, @x... seriously?
</code></pre>
<p>With this proposal, we dodge a new left enfix convention, and get a perfectly sensible definition for <strong><code>&lt;|</code></strong>:</p>
<pre><code>&lt;|: func [
    {Evaluate any # of expressions, but completely elide the results.}

    return: []
        {Returns nothing, not even void (like COMMENT)}
    expressions [&lt;opt&gt; any-value! &lt;...&gt;]
         {Any number of expressions.}
][
    do expressions ;-- yes, you can DO or DO/NEXT a VARARGS!
]
</code></pre>
<hr>
<p><strong><a href="https://www.youtube.com/watch?v=56dRczBgMiA" rel="nofollow noopener">...Any questions?...</a></strong></p>
<p>I think this looks like the best of both worlds.</p>
          <p><a href="https://forum.rebol.info/t/issues-with-invisibles-a-truly-disappearing-comment/405/2">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/issues-with-invisibles-a-truly-disappearing-comment/405/2</link>
        <pubDate>Sun, 03 Dec 2017 03:11:03 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-405-2</guid>
        <source url="https://forum.rebol.info/t/issues-with-invisibles-a-truly-disappearing-comment/405.rss">Issues with &quot;Invisibles&quot;: a truly disappearing COMMENT</source>
      </item>
      <item>
        <title>Issues with &quot;Invisibles&quot;: a truly disappearing COMMENT</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>So <a class="mention" href="/u/markeye">@MarkEye</a> brought back up an idea that has crossed my mind every few months, about what it would take to make something that was truly "less than null".  Some way of returning a complete-absence-of-information, <em>including even information about the absence of a value</em>.  :-/</p>
<p>The most "obvious" application most people would jump to <em>(which turns out--in fact--not to be so obvious at all)</em> would be COMMENT.  So imagine:</p>
<pre><code>9 = do [1 + comment "a" comment "b" 2 * 3]
9 = do [1 comment "a" + comment "b" 2 * 3]
9 = do [1 + comment "a" comment "b" + 2 * 3]
</code></pre>
<p>Despite the simple appearance, there's a lot of holistic concerns of such a thing showing up in the Rebol ecology.  Here's some:</p>
<p><strong>"I've made an acid that can eat through anything..."</strong></p>
<p>This can't come down to returning a new type of value (e.g. a COMMENT!).  Because what would happen in your function when you said <code>return make comment! ...</code>?  It would be skipped.</p>
<p>How would you test for them?  <code>if comment? c [print "it's a comment"]</code> would turn into <code>if comment? [print "it's a comment"]</code></p>
<p>Having it as a value type is not an option, so it would have to be some new character of the function definition itself.</p>
<p><strong>You can't "GROUP! them" and keep their semantics</strong></p>
<p>One might ask if there should be a difference between these two statements:</p>
<pre><code> 1 + comment "a" 2
 1 + (comment "a") 2
</code></pre>
<p>COMMENT isn't a very motivating scenario, it's single-arity and it quotes.  But what if you had a more complex operation in this class, with multiple arguments, including evaluated ones?</p>
<p>Rebol has used <code>()</code> as a "null generator" for a long time.  But might it be revisited so that GROUP!s that wound containing no content--or just comments--to vaporize?  That would mean all these were the same when running DO?</p>
<pre><code>1 + comment "a" 2
1 + (comment "a") 2
1 + () 2
1 + 2
</code></pre>
<p>The short answer is <strong>No</strong>.  The long answer is <strong>N: (o)</strong></p>
<blockquote>
<p><strong>UPDATE:</strong> Later it was decided the real answer is actually much longer--it rules out these particular cases, <a href="https://forum.rebol.info/t/what-to-do-about-do-and/772">while allowing groups to vaporize in interstitial positions</a>.  Hence <strong>you can group them and keep their (absence of) content</strong>, but you can't put those invisibled groups in some spots you could have put them without the group.</p>
<p><strong>UPDATED UPDATE</strong>: In practice, having <strong>N: (...invisible...) 1</strong> be equivalent to <strong>N: 1</strong> does have meaningful applications.  This is due to the expanded scope of invisibles beyond commenting, they truly have turned out to be useful for non-invasive debug constructs.  The existence of <strong><code>do</code></strong> for always returning a value can help in scenarios where you are running generic code you don't understand and want to be sure it doesn't vaporize...such code is usually in a variable anyway!  So the use case of GROUP!s being more "ghostly" is actually something that makes their character unique.  <a href="https://forum.rebol.info/t/permissive-group-invisibility/1153">See expanded reasoning.</a></p>
</blockquote>
<p><strong>1</strong> key reason for using groups in the first place is to show the structure in a stream of varying arity.  It provides an anchor to be able to say "that one GROUP! will turn into exactly one complete value, or it will error".  So if <strong>o</strong> vaporized in the <strong>(o)</strong> above, should <strong>N</strong> be 1 now?  <img src="https://forum.rebol.info/images/emoji/twitter/confused.png?v=9" title=":confused:" class="emoji" alt=":confused:"></p>
<p>Pulling the rug out from under that with "zero or one values" would have to be <em>very</em> worth it.  And it's very not.  If an expression wants to be invisible and look convenient, make it a dialect and let it take a block:</p>
<pre><code>1 i'm-invisible a &lt;b&gt; #c 'd + 2    ;-- don't define it like this
1 (i'm-invisible a &lt;b&gt; #c 'd) + 2  ;-- b/c this is void, not invisible

1 i'm-invisible [a &lt;b&gt; #c 'd] + 2 ;-- define it like this
</code></pre>
<p><strong>Interaction with DO/NEXT...<em>all invisible functions are effectively enfix</em></strong></p>
<p>This is the biggest issue.  Basically, a DO/NEXT cannot finish until it has consumed all these "invisible" expressions.  Consider:</p>
<pre><code>pos: _
do/next [1 + 2 comment "a" * 3] 'pos
</code></pre>
<p>For COMMENT to be truly "invisible", then that should act as <code>1 + 2 * 3</code>.  And the only way it can do so is if when it reaches the <code>comment "a"</code> that it eagerly continues processing, so it can find out if there's anything on the other side.</p>
<p>Furthermore, the only way to be actually "invisible" is not to damage the evaluator stack at all.  You don't want the presence of the comment above to suddenly turn <code>1 + 2 * 3</code> into the semantics of <code>1 + (2 * 3)</code>.  That means the comment needs to be dissolved right at the moment the 2 is evaluated, so it can be seen past.</p>
<p>Technically this is easy enough to do, but the results might surprise someone.  Let's imagine you think it would be cool to modify something like the variable DUMP function to be one of these "invisibles".   So you might write:</p>
<pre><code> x: 1 + 2 dump [x] * 3
</code></pre>
<p>That seems pretty cool, and intuitive in this case that when you dump X it hasn't been assigned yet--the expression isn't completed.  But would it be as intuitive if you saw:</p>
<pre><code>x: 1 + 2
dump [x]
</code></pre>
<p>One might expect 3.  But as the example above it shows, you can't get that invisible property that way.  If you did, then DO/NEXT would treat that as two expressions.</p>
<p><strong>Is it best to be honest and just call these enfix functions?</strong></p>
<p>Rather than getting into the complex details of defining a new category of functions that are "kind of exactly like enfix functions", should we just say that's what they are?  They're basically enfix functions which can pipe their left hand argument to the output in a transparent way.  Says <a class="mention" href="/u/markeye">@MarkEye</a>:</p>
<blockquote>
<p>For the purposes of explication, can one consider COMMENT to be a tight infix operator that "returns" its left-hand side? (haha and its left-hand side is allowed to be empty!) Example: <code>do/next [comment "thrillsville"]</code> should behave exactly like <code>do/next []</code>, shouldn't it?</p>
</blockquote>
<p>There are a few technical challenges to implementing true transparency in this way, given that there is no END! datatype (yet behaviors can be distinguished internally to the evaluator between end and null).  It could be worked past with some kind of <code>return/proxy</code> function that you just point at the argument you want to telegraph, and the evaluator takes care of it.</p>
<p>We don't want to increase the number of parts in the box unnecessarily, so piggybacking on ENFIX may be okay.  And also, making it a generic enfix mechanism means someone could design such an abstraction with non-tight semantics as well (if they're okay with non-total-invisibility).</p>
<p>But it may be "weird", and surprise someone who types HELP COMMENT and wonders why it's not the "naive" form.  Or as <a class="mention" href="/u/markeye">@MarkEye</a> says it "explicates" the situation.  Hiding the "latching" behavior on the previous result would only obscure the process.</p>
<p>Thoughts??</p>
          <p><a href="https://forum.rebol.info/t/issues-with-invisibles-a-truly-disappearing-comment/405/1">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/issues-with-invisibles-a-truly-disappearing-comment/405/1</link>
        <pubDate>Sun, 03 Dec 2017 01:02:05 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-405-1</guid>
        <source url="https://forum.rebol.info/t/issues-with-invisibles-a-truly-disappearing-comment/405.rss">Issues with &quot;Invisibles&quot;: a truly disappearing COMMENT</source>
      </item>
  </channel>
</rss>
