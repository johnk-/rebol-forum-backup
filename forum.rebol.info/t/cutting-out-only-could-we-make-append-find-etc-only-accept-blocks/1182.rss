<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Cutting out /ONLY: Could we make APPEND, FIND, etc *only accept blocks*?</title>
    <link>https://forum.rebol.info/t/cutting-out-only-could-we-make-append-find-etc-only-accept-blocks/1182</link>
    <description>The following Redbol-ism long seemed unnatural to me, of defaulting to breaking paths apart unless you say /ONLY:

    rebol2&gt;&gt; append [a b c] first [d/e/f g/h/i]
    == [a b c d e f]

    rebol2&gt;&gt; append/only [a b c] first [d/e/f g/h/i]
    == [a b c d/e/f]

This raises people&#39;s questions about why blocks should default to that, which confuses many a newcomer...and which I was opposed to when I first saw it.

    rebol2&gt;&gt; append [a b c] first [[d e f] g/h/i]
    == [a b c d e f]

Ultimately it came to be that using Rebol in practice made me feel splicing was the natural default for many block operations.  **But something long remained uncomfortable with this pattern...** which applies to other routines with this kind of /ONLY (for instance, FIND)...is how it&#39;s hard to tell at the callsite what&#39;s going to happen when you are talking about data indirectly:

     rebol2&gt;&gt; item: [a b c]

     ;... then much later, callsite might suddenly stop working generically
     ;... when you suddenly switch item to a block from something else:

     rebol2&gt;&gt; find reduce [1 + 2 item 3 + 4] item
     == none

## The known existing schools of thought

1. **&quot;splicing should be the special operation&quot;** - you should have to ask for `append/splice` to get it, with all other appends defaulting to being /ONLY.  More generically the term might be something like `/multi` so it works e.g. with `find/multi`
2. **&quot;there&#39;s something special about BLOCK!&quot;** - this could be thought of as reinforced logographically by the distinction of using brackets in the **[o]**, that makes it work, so you just know they are weird.
2b. **&quot;there&#39;s something special about datatypes where space is the delimiter**, so BLOCK! and GROUP! *both* count
3. **&quot;it&#39;s too late to change any of it it, so leave it as is&quot;**

I was convinced #1 was probably not in Rebol&#39;s best interest.  But then I disliked auto-splicing of PATH! enough that I rejected #3 as a least-favorite option.  So at one point Ren-C was switched to using #2b.  But...

## Informing this further with a new use case

I just ran into a problem with [my proposed usage of @[...] to be an irreducible capture of a datatype, that can also carry a quoting level](https://forum.rebol.info/t/should-datatype-be-killed-off-in-favor-of-integer-word-etc/1177/7?u=hostilefork).  That doesn&#39;t work if @[...] blocks are considered a container that needs /ONLY for things like FIND:

     find reduce [integer! quoted-word!] quoted-word!

Becomes:

    find [@[integer] @[&#39;word]] @[&#39;word]

It today assumes the @[...] is to be handled the same a a regular block.  So this is morally equivalent to:

    find [@[integer] @[&#39;word]] [&#39;word]

Which acts the same as:

    find [@[integer] @[&#39;word]] lit &#39;word

That doesn&#39;t do what&#39;s intended, and doesn&#39;t match the datatype.  But it feels ever more haphazard to just pick a random reasoning.

**What it makes me feel is that there&#39;s just something fundamentally wrong being glossed over.**

## Concept: expect [...] *always*, splice *always*, leverage :[...]? 

It feels like &quot;at the source level&quot;, you want to be able to see whether what you&#39;re passing along is going to be treated atomically or not.  This is a parallel to other problems, like what caused [&quot;Backpedaling on non-block branches&quot;](https://forum.rebol.info/t/backpedaling-on-non-block-branches/476).  That was mitigated with [soft quoted branching](https://forum.rebol.info/t/soft-quoted-branching-light-elegant-fast/1020), which carries some other advantages.

One idea could be that *appends, insert, finds, etc. always take BLOCK! and always presume splicing semantics*. 

    &gt;&gt; append [a b c] [1 + 2 10 + 20]
    == [a b c 1 + 2 10 + 20]  ; compatible with history

    &gt;&gt; append [a b c] 3
    ** Error: APPEND does not accept INTEGER! for its value argument
    ; Not compatible, but at least an error and not random new behavior

    &gt;&gt; append [a b c] [3]
    == [a b c 3]  ; compatible with history

Also allow GET-BLOCK! to ask for reduction along with your splicing:

     &gt;&gt; append [a b c] :[1 + 2 10 + 20]
     == [a b c 3 30]

Block parameters (the only type which would be tolerated) passed in would be spliced--because as mentioned it always takes a block parameter, and they&#39;re always spliced:

     &gt;&gt; items: [1 [2 + 3] 4]
     &gt;&gt; append [a b c] (second items)
     == [a b c 2 + 3]

But you could slip past this by using a GET-BLOCK! that has your expression in it...thus it would reduce and get spliced, but leaving the original alone...effectively an /ONLY:

     &gt;&gt; items: [1 [2 + 3] 4]
     &gt;&gt; append [a b c] :[second items]
     == [a b c [2 + 3]]

## Further radicalization - soft quote the second argument?

If you&#39;d be willing to write **append [a b c] (second items)** always instead of **append [a b c] second items**, *then all of the above is compatible with soft-quoting*.  You could then use literal material as-is, which could work for BLOCK! and other things:

     &gt;&gt; append [a b c] &#39;[1 + 2 10 + 20]
     == [a b c [1 + 2 10 + 20]]

     &gt;&gt; append [a b c] &#39;3
     == [a b c 3]

As with branching, non-quoted things would complain if you didn&#39;t give it a BLOCK!:

    &gt;&gt; item: 10
    &gt;&gt; append [a b c] (item)
    ** Error: APPEND only takes BLOCK!, GET-BLOCK!, or QUOTED!

    &gt;&gt; append [a b c] [item]
    == [a b c item]

    &gt;&gt; append [a b c] :[item]
    == [a b c 10]

    &gt;&gt; append [a b c] &#39;10
    == [a b c 10]

    &gt;&gt; item: [1 + 2 10 + 20]
    &gt;&gt; append [a b c] (item)
    == [a b c 1 + 2 10 + 20]

It would work how an IF doesn&#39;t have the rule on its condition but only the branch, it&#39;s just the thing to be appended:

     &gt;&gt; target: &quot;abcd&quot;

     &gt;&gt; append target [&quot;efg&quot;]
     == &quot;abcdefg&quot;

     &gt;&gt; append target &#39;{ghi}
     == &quot;abcdefghi&quot;

## Pros

* **You aren&#39;t confused when you see `append x (y)` about what `y` is going to look up to.  Because if it weren&#39;t a block, that would be an error.**  Being introduced from day one to APPEND+INSERT+CHANGE as operations that expect a block of things to be appended... and FIND+SELECT as taking a block of things to be found, might seem strange to us now...but I think the net complexity drops compared to /ONLY and the problems it causes.
* **Kills off the idea of /ONLY and all the mire that accompanies it**.  It is so easy to make mistakes with that, no matter how experienced in Rebol code you are.  I don&#39;t feel any satisfying solution has been articulated about it.
* **Has a good alignment with the [o] meaning BLOCK! is a special datatype**.  Sets up a psychological basis for working coherently, and hopefully not making mistakes down the road.  Suggests people use blocks to represent groups of parameters as arguments to functions instead of single items *systemically*...a better principle to embrace than expecting them how to realize to design every routine with an /ONLY option...which was [a bit like the /INTO virus](https://forum.rebol.info/t/stopping-the-into-virus/705)
* **Can cover REPEND-style cases where the block being repended is source-level with expressions (likely most common)**.  If it&#39;s quoting the second argument, it could blend the evaluator into the operation, even if that evaluation is just to reduce a variable name for you to be the item to append.  There&#39;s been some amount of issue about performance when the natives are `reduce` and `append` and executed in two steps, whereas a reducing append that saw the source GET-BLOCK! could build a right-sized block more efficiently.
* **Single element blocks are pretty efficient; moreso than refinements**  I&#39;ve mentioned how the design has been set up such that `:[a]` fits in a single series node, so it&#39;s not horrible to need to say `append data :[item]` instead of `append data item`... it&#39;s actually *better* than `append/only data item`.  And quoted things are efficient too, so `append data &#39;10` costs the same as `append data 10`.

And across the range of allowed inputs, it would be compatible with historical code.  The Redbol emulation would be fairly trivial:

    redbol-append: function [series value /only] [
        append series case [
             only [:[value]]  ; evaluates to a spliced BLOCK! with one item in it 
             any-array? value [as block! value]  ; force path/group to block
             default [:[value]]  ; put anything else into a block
         ]
    ]

## Cons

Obviously asking people to write **`find data [&lt;x&gt;]`** instead of **`find data &lt;x&gt;`** seems blocky, and **find data :[var]** instead of **find data var** is uglier.  Plus **append string [&quot;stuff&quot;]** feels a bit wordy and **append string &#39;{stuff}** makes you change your string delimiter.  This might be mitigated some by being able to say **append string &#39;stuff** and allowing WORD!-based appends.

...Or perhaps being more lenient when the target is a string type, so the /ONLY distinction wouldn&#39;t exist in the first place...so allow any type?  e.g. enforce the &quot;must be a block rule&quot; for the argument *only when modifying or searching in arrays*?

While the soft quoting is not integral to the proposal, it has that problem of making you say **append data (second items)** instead of **append data second items**.  Regardless of whether one thinks the soft quoting is a good idea, there&#39;s much more information there... *you know the second thing in items is a block and it will be spliced*.  If you saw **append data :[second items]** you don&#39;t know what the thing is but you know it&#39;s not going to be spliced.

## For those not going with Redbol emulation, it could be a fresh start

Killing off /ONLY feels like a noble cause to me.

This line of thinking reminds me a bit of the train of thought behind saying that *if* you have an argument that can take ANY-VALUE!, then you do not use the blank-in-null-out convention for such arguments...you have to switch to thinking of null as some kind of nothing, or accept erroring on null. 

So maybe we could consider this a variant of 2 above:

**2c.** **BLOCK! has a special use by convention in the language as a &quot;generic container of N things&quot;.** You should generally not make a parameter take ANY-VALUE! if that argument intends to use this meaning of BLOCK!.  Instead you should *always* take a block, even if just to provide a single thing, for clarity at the callsites.
**2c.1.** If your use case fits it, you can use soft-quoting to allow QUOTED! values to indicate single items as a shorthand--at the cost of having to put expressions producing BLOCK!s into GROUP!s.
**2c.???.** (maybe?) If you have a span of target cases where multiple items cannot be handled differently from single items (e.g. **find** of a TEXT! in a TEXT! has no distinct meaning from **find** of a BLOCK! with that TEXT! in it, where an /ONLY refinement would have no meaning) then these cases may be tolerated as missing the BLOCK! container for single elements.</description>
    
    <lastBuildDate>Mon, 16 Aug 2021 05:26:13 +0000</lastBuildDate>
    <category>Internals</category>
    <atom:link href="https://forum.rebol.info/t/cutting-out-only-could-we-make-append-find-etc-only-accept-blocks/1182.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Cutting out /ONLY: Could we make APPEND, FIND, etc *only accept blocks*?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>A post was split to a new topic: <a href="/t/just-vs-lit-literal-literally/1453">JUST vs LIT/LITERAL/LITERALLY</a></p>
          <p><a href="https://forum.rebol.info/t/cutting-out-only-could-we-make-append-find-etc-only-accept-blocks/1182/15">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/cutting-out-only-could-we-make-append-find-etc-only-accept-blocks/1182/15</link>
        <pubDate>Sat, 02 Jan 2021 19:25:41 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1182-15</guid>
        <source url="https://forum.rebol.info/t/cutting-out-only-could-we-make-append-find-etc-only-accept-blocks/1182.rss">Cutting out /ONLY: Could we make APPEND, FIND, etc *only accept blocks*?</source>
      </item>
      <item>
        <title>Cutting out /ONLY: Could we make APPEND, FIND, etc *only accept blocks*?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="rgchris" data-post="12" data-topic="1182">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/rgchris/40/14_2.png" class="avatar"> rgchris:</div>
<blockquote>
<p>Over half of these should be a win</p>
</blockquote>
</aside>
<p><a href="https://forum.rebol.info/t/just-vs-lit-literal-literally/1453">I've split my reasoning for why ONLY should probably be the operation instead of JUST into a separate thread.</a></p>
<p>So this ONLY idea is probably the least ugly idea to come along so far.</p>
<pre><code> append/only data item
 append data only item
</code></pre>
<ul>
<li>
<p>You lose a slash, cutting down on visual noise (and it's cheaper at source level by virtue of not needing a series node for the path just one more cell in the parent array).</p>
</li>
<li>
<p>Unlike the modal argument concept, it can take full expressions without parentheses.  Compare <strong>append data @(first code)</strong> and <strong>append data only first code</strong>.</p>
</li>
<li>
<p>It can be cheap at the runtime level as well if the single-cell-block optimization works.  <em>(We can also make calling ONLY extremely fast...there are tricks for single arity functions like this that can bypass function invocation mechanics entirely, though debug modes should be taken into account to suppress such optimizations.)</em></p>
</li>
<li>
<p>The concept of ONLY as a modifier to the item--instead of a "different kind of append"--gives APPEND a more uniform behavior.</p>
</li>
<li>
<p>In the flow of words it feels better to place the intent not to splice on the item.</p>
</li>
</ul>
<h2>Question: What If The Target Is Not An Array?</h2>
<p>Historically, /ONLY was ignored if you appended to a string:</p>
<pre><code>rebol2&gt;&gt; append/only "abc" "def"
== "abcdef"

rebol2&gt;&gt; append "abc" ["d" "e" "f"]
== "abcdef"

rebol2&gt;&gt; append/only "abc" ["d" "e" "f"]
== "abcdef"
</code></pre>
<p>But now, we'd be saying that if you were running <strong>append "abc" only value</strong> and value happened to be a block, you'd be appending a block-within-a-block...and Rebol2 defined that differently:</p>
<pre><code>rebol2&gt;&gt; append/only "abc" [["d" "e" "f"]]
== "abcd e f"
</code></pre>
<p><strong><a href="https://forum.rebol.info/t/every-thought-on-array-splicing-has-been-had/1332/7">I tried to outline some foundations to think about this</a></strong>...but that was based on saying that there was a fundamental append for non-array types (APPEND/ONLY) distinct from the collection behavior.  JUST changes the game a bit.  So please weigh in there.</p>
<p>One could also ask if we're just asking for trouble with a fundamental operation that appends things to strings that aren't strings.  Maybe an error is better, and you're supposed to say <strong>append string form block</strong> or <strong>append string unspaced block</strong> or whatever.  <img src="https://forum.rebol.info/images/emoji/twitter/man_shrugging.png?v=9" title=":man_shrugging:" class="emoji" alt=":man_shrugging:"></p>
<h2>The Topic Question Still Remains...</h2>
<p>Originally this topic asked <strong>"Could we make APPEND, FIND, etc <em>only accept blocks</em>?"</strong>  Maybe ONLY would make such a policy more palatable?</p>
<p>The issue I still struggle with is that you might work with code and feel like something like this feels like an invariant:</p>
<pre><code>&gt;&gt; block: [#a {b} [c d e] %f]

&gt;&gt; pick block 2
== {b}

&gt;&gt; find block pick block 2
== [{b} [c d e] %f]

&gt;&gt; index of find block pick block 2
== 2
</code></pre>
<p>If you pick a (unique) thing out of a block, and then find that thing in the block, the index will be where you picked from.</p>
<p>But then you get a non-atomic default out of FIND.</p>
<pre><code>&gt;&gt; block: [#a {b} [c d e] %f]

&gt;&gt; pick block 3
== [c d e]

&gt;&gt; find block pick block 3
; null
</code></pre>
<p>In terms of a poster child for "this still seems problematic", I actually kind of feel FIND is a bit worse than APPEND for some reason.</p>
<p>The thing is that you're usually looking at a line of code like <strong>find blarg pick mumble index</strong> and you have very little to go on.  I make mistakes with this stuff constantly.</p>
<p>Our change to LOAD to always return a BLOCK! feels like it tightened things up, and LOAD-VALUE seemed to help.  I guess I'm just wondering about the real value in the "collection-or-item" polymorphism.  Any additional thoughts on the exploding brain thread appreciated.</p>
<hr>
<p><strong>Sidenote: I might have an idea for going another direction for cost saving with ONLY that wouldn't make the resulting block immutable.</strong>  Instead, it would be a rethinking of the GC management such that the block would be not GC managed, and become GC managed if it were moved into a "managed location".  This would mean that APPEND could release the small node without the GC ever seeing it.  It might be part of a general solution to reducing how many things have to be garbage collected.</p>
          <p><a href="https://forum.rebol.info/t/cutting-out-only-could-we-make-append-find-etc-only-accept-blocks/1182/13">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/cutting-out-only-could-we-make-append-find-etc-only-accept-blocks/1182/13</link>
        <pubDate>Wed, 30 Dec 2020 19:33:55 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1182-13</guid>
        <source url="https://forum.rebol.info/t/cutting-out-only-could-we-make-append-find-etc-only-accept-blocks/1182.rss">Cutting out /ONLY: Could we make APPEND, FIND, etc *only accept blocks*?</source>
      </item>
      <item>
        <title>Cutting out /ONLY: Could we make APPEND, FIND, etc *only accept blocks*?</title>
        <dc:creator><![CDATA[rgchris]]></dc:creator>
        <description><![CDATA[
            <p>JUST seems a good pick. On reflection, I think ONLY would have been a better choice than some of my other suggestions, but JUST seems more apt.</p>
<p>A quick enumeration of /ONLY functions crudely gathered:</p>
<pre><code class="lang-nohighlight">sort collect [
    for-each word words-of lib [
        all [
            action? get/any word
            find spec-of get word /only
            keep word
        ]
    ]
]
</code></pre>
<p>Using as the shim:</p>
<pre><code>just: func [val][compose [(val)]]
</code></pre>
<p>Against the current iteration of ReplPad:</p>
<pre><code>&gt;&gt; system/commit
== "646d3c4ec896f3bde06043b2535ab86d8981c4c7"
</code></pre>
<h2>append, repend</h2>
<pre><code>&gt;&gt; append [a b c] just [d e f]
== [a b c [d e f]]
</code></pre>
<h2>bind</h2>
<p><em>Not applicable</em></p>
<h2>change</h2>
<pre><code>&gt;&gt; head change next [a b c] just [d e f]
== [a [d e f] c]
</code></pre>
<h2>clean-path</h2>
<p><em>Not applicable</em></p>
<h2>compose</h2>
<p><em>Seemingly JUST is currently the default</em></p>
<pre><code>&gt;&gt; compose [a b c (just [d e f])]
== [a b c [[d e f]]]
</code></pre>
<h2>construct</h2>
<p><em>Not applicable</em></p>
<h2>do</h2>
<p><em>Not applicable</em></p>
<h2>find, find-last, find-reverse</h2>
<pre><code>&gt;&gt; find [a b c d e f [d e f]] just [d e f]
== [[d e f]]
</code></pre>
<h2>info?</h2>
<p><em>Not applicable</em></p>
<h2>insert</h2>
<pre><code>&gt;&gt; head insert [a b c] just [d e f]
== [[d e f] a b c]
</code></pre>
<h2>math</h2>
<p><em>Not applicable (also doesn't appear to be working)</em></p>
<h2>mold, remold</h2>
<p>Discussed <a href="https://forum.rebol.info/t/mold-and-load-parity/1429">elsewhere</a>.</p>
<pre><code>&gt;&gt; mold just [foo]
== "[[foo]]"
</code></pre>
<h2>random</h2>
<p><em>Not really sure if this is something that would apply.</em></p>
<h2>resolve</h2>
<p><em>Not exactly sure what this function does.</em></p>
<h2>select</h2>
<pre><code>&gt;&gt; select [a b c d e f [a b c] [d e f]] just [a b c]
== [d e f]
</code></pre>
<hr>
<p>One that wasn't picked up by LIB scouring:</p>
<h2>keep</h2>
<pre><code>&gt;&gt; collect [keep [a b c] keep just [d e f]]
== [a b c [d e f]]
</code></pre>
<hr>
<p>Over half of these should be a win</p>
          <p><a href="https://forum.rebol.info/t/cutting-out-only-could-we-make-append-find-etc-only-accept-blocks/1182/12">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/cutting-out-only-could-we-make-append-find-etc-only-accept-blocks/1182/12</link>
        <pubDate>Wed, 30 Dec 2020 16:49:07 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1182-12</guid>
        <source url="https://forum.rebol.info/t/cutting-out-only-could-we-make-append-find-etc-only-accept-blocks/1182.rss">Cutting out /ONLY: Could we make APPEND, FIND, etc *only accept blocks*?</source>
      </item>
      <item>
        <title>Cutting out /ONLY: Could we make APPEND, FIND, etc *only accept blocks*?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="rgchris" data-post="10" data-topic="1182">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/rgchris/40/14_2.png" class="avatar"> rgchris:</div>
<blockquote>
<p>I'm still fond of ENVELOP over BLOCKIFY as a name. I don't think ONLY would make the cut.</p>
</blockquote>
</aside>
<p>A name I think might work is <strong>just</strong>, as in "create a block which is immutable at its shallowest level, containing <em>just</em> this one value".</p>
<pre><code>&gt;&gt; test: just [d]
== [[d]]

&gt;&gt; append test &lt;not-legal&gt;
*** Error: [[d]] was made with JUST and is top-level immutable

&gt;&gt; append first test &lt;legal&gt;
== [[d &lt;legal&gt;]]  ; legal as long as input array was mutable

 &gt;&gt; append [a b c] just [d]
 == [a b c [d]]
</code></pre>
<p>The particular optimization concept I have in mind (to make no GC-visible allocations) might or might not be possible.  Some aspects of it may benefit from <a href="https://forum.rebol.info/t/moving-away-from-null-termination-end-of-block-s/1445">getting rid of END markers</a>...which will likely happen anyway.</p>
<p>There are limits, of course.  You can't apply this efficiency more than once, so <strong><code>just just [d]</code></strong> would have to allocate at least one array node.</p>
<p>You also can't store an arbitrary position.  The cell bits are nearly all used for the contained cell.  So <strong>at just [d] 10</strong> would have to make a real array cell with an array node.  Once allocated, it could patch that node into the bit pattern of the optimized cell it had in its hand, effectively deoptimizing it...since you're now paying the cost.  This way you wouldn't wind up paying for the node every time you subsequently skipped around in it.</p>
<p>It might be possible to compact the 0 and 1 position knowledge into the optimized form.  Anyway, there would be tons of places that would deoptimize this...so its main value would be with the operations like APPEND or FIND.</p>
<p>That's all presuming that the error-prone block-semantics-are-different-from-everything-else is considered unchangeable.  I still feel it's awfully easy to forget the JUST and write code that "works until it doesn't".  But as my post said, "every thought has been had".  It's only the foundations...and if you find yourself tripping up then build your own helpers.</p>
<p>Anyway, wanted to mention JUST, as it seems like a pretty reasonable use of the word in this particular language context.</p>
          <p><a href="https://forum.rebol.info/t/cutting-out-only-could-we-make-append-find-etc-only-accept-blocks/1182/11">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/cutting-out-only-could-we-make-append-find-etc-only-accept-blocks/1182/11</link>
        <pubDate>Wed, 30 Dec 2020 14:18:53 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1182-11</guid>
        <source url="https://forum.rebol.info/t/cutting-out-only-could-we-make-append-find-etc-only-accept-blocks/1182.rss">Cutting out /ONLY: Could we make APPEND, FIND, etc *only accept blocks*?</source>
      </item>
      <item>
        <title>Cutting out /ONLY: Could we make APPEND, FIND, etc *only accept blocks*?</title>
        <dc:creator><![CDATA[rgchris]]></dc:creator>
        <description><![CDATA[
            <p>Forgive me if this was mentioned, but if single-element blocks are more efficient than refinements, you could have a function that wrapped a value in a block (like BLOCKIFY, but optimized for single element block and equivalent to what BLOCKIFY/ONLY would do). This would be a little like <code>'[quoting]</code> but could be applied to a word:</p>
<pre><code class="lang-auto">; calling it ONLY 😈
&gt;&gt; append [a b c] only block: [d e f]
== [a b c [d e f]]

&gt;&gt; append [a b c] only block
== [a b c [d e f]]
</code></pre>
<p>Correct me if I'm wrong, but this proposed ONLY function would simply create a single value cell with the block reference, which would seem pretty efficient.</p>
<p>It'd be very easy to shim:</p>
<pre><code class="lang-auto">only: func [value][
    reduce [value]
]
</code></pre>
<p>I'm still fond of ENVELOP over BLOCKIFY as a name. I don't think ONLY would make the cut. Naming is tricky as it is sort of a hack—it's purpose is to make a block a singular value but in actuality it is creating a new value of which the old one just happens to be the only content.</p>
          <p><a href="https://forum.rebol.info/t/cutting-out-only-could-we-make-append-find-etc-only-accept-blocks/1182/10">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/cutting-out-only-could-we-make-append-find-etc-only-accept-blocks/1182/10</link>
        <pubDate>Wed, 09 Dec 2020 14:18:09 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1182-10</guid>
        <source url="https://forum.rebol.info/t/cutting-out-only-could-we-make-append-find-etc-only-accept-blocks/1182.rss">Cutting out /ONLY: Could we make APPEND, FIND, etc *only accept blocks*?</source>
      </item>
      <item>
        <title>Cutting out /ONLY: Could we make APPEND, FIND, etc *only accept blocks*?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>As an additional twist on this idea, I wondered if we could take the same tactic as with PRINT and decide that TEXT! strings are an exception.</p>
<p>That idea was <a href="https://forum.rebol.info/t/limiting-print-to-block-text-perhaps-blank-to-opt-out/855">"Limiting PRINT to BLOCK! and TEXT!"</a> (with modifications of BLANK! to opt out, and the single CHAR! of NEWLINE accepted).</p>
<p>This is because PRINT wants to break you of the habit of saying <strong>print x</strong> and getting the "surprise!" of when that suddenly runs code one day when it's a block.  It wanted to discourage you from thinking that PRINT is some kind of <em>generic</em> debug dumper... and guide you to using DUMP (<code>--</code>).</p>
<p>But might the same simple exception of TEXT! be worth it in this rule, as well?</p>
<pre><code>&gt;&gt; b: [d e]
&gt;&gt; t: "de"
&gt;&gt; o: make object! [x: 1020]

&gt;&gt; append [a b c] b
== [a b c d e]

&gt;&gt; append [a b c] t
== [a b c "de"]

&gt;&gt; append [a b c] o
** Error: must use /ONLY unless splicing block or text
</code></pre>
<p>This still gets you to break the habit.  If you're writing <em>generic</em> code, what are the odds that everything you are dealing with is a TEXT!?  you're likely to be appending INTEGER! and TAG! and lots of other things.  Letting the narrow case of text strings slip through without complaint covers the most common case of what people try to do, e.g. <strong>collect [keep "this"]</strong>.</p>
<p>I mention this as I think the gamble actually has worked pretty well for PRINT, on balance.</p>
          <p><a href="https://forum.rebol.info/t/cutting-out-only-could-we-make-append-find-etc-only-accept-blocks/1182/9">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/cutting-out-only-could-we-make-append-find-etc-only-accept-blocks/1182/9</link>
        <pubDate>Thu, 29 Aug 2019 16:17:49 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1182-9</guid>
        <source url="https://forum.rebol.info/t/cutting-out-only-could-we-make-append-find-etc-only-accept-blocks/1182.rss">Cutting out /ONLY: Could we make APPEND, FIND, etc *only accept blocks*?</source>
      </item>
      <item>
        <title>Cutting out /ONLY: Could we make APPEND, FIND, etc *only accept blocks*?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-post="7" data-topic="1182">
<div class="title">
<div class="quote-controls"></div>
<img alt width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I quickly turned my test around to work this way for APPEND/INSERT/CHANGE and it feels far less disruptive, while seeming to have the effect of helping avoid most of the surprising categories of error that I want to stop.</p>
</blockquote>
</aside>
<p>Back to Reboling, and pushing this idea through, <strong>I think this idea is a winner</strong>.</p>
<p>New users would get in the rhythm of working with ANY-ARRAY! with block arguments.  This looks only a little more verbose for literals:</p>
<pre><code>append block [&lt;failure&gt;]
; instead of
append block &lt;failure&gt;
</code></pre>
<p>But setting the pattern early means people will read:</p>
<pre><code>append block thing
</code></pre>
<p>As knowing that thing is a block and it will be spliced.  If you then say:</p>
<pre><code>append/only block thing
; or
append block @thing
</code></pre>
<p>Here you're consciously knowing that whatever it is, it's appending <em>one and only one item</em>.  Classic bugs just won't happen due to better conventions, helping newbies and old school users alike.</p>
<p>This leads to a question about whether using /only if the target is a string series should be an error.  What use is the polymorphism?  How often does one write code that operates on <em>either</em> a string or a block, <em>that wants /only semantics on the block, but just wants it ignored on the strings?</em>  I think it's rare enough to write such code in the first place, but to me it seems any polymorphic code would be splicing the blocks just as it would the strings.</p>
<p>On the other hand, it seems oppressive to only allow strings to be appended to ANY-STRING!, making you write:</p>
<pre><code>append text unspaced reduce [{"} name {"}]
; instead of
append text reduce [{"} name {"}]
</code></pre>
<p>In fact, if we believe that <a href="https://forum.rebol.info/t/get-block-get-and-reduce/1183">GET-BLOCK! should represent a reduction</a>, you have another option:</p>
<pre><code>append text :[{"} name {"}]
</code></pre>
<p>It seems the benefits of prohibiting /ONLY (or the equivalent @ modal parameters for string destinations) could have a strength outweighing any possible inconvenience: <strong>If you saw /ONLY or @ at the callsite, then you know the destination is an ANY-ARRAY!</strong>.</p>
<p>I haven't implemented this rule to see how much pain it would cause.  But I'm guessing not much.</p>
<p>Anyway--this aims to resolve one of the most fundamental and enduring frustrations of the language.  If it fails, at least there is documentation of why the perpetually bug-causing behavior has been chosen as "just the way it is."  But right now, I don't think it's failing.</p>
<p><strong>Odds are keeping the name as /ONLY is beneficial to continue to allow people to write code that works in Ren-C but is backwards compatible elsewhere.</strong>  I'm hard pressed to think of a name change where the name is so much of an obvious win.  But it's always fun to think of parallel universes where the better option was chosen.  Since it would now apply solely to the case of the target being an ANY-ARRAY!, maybe... /ONE?  Saves a letter, even:</p>
<pre><code>&gt;&gt; append [a b c] [d e]
== [a b c d e]

&gt;&gt; append/one [a b c] [d e]
== [a b c [d e]]
</code></pre>
<p>Other ideas could be /SINGLE, /ATOM, /VALUE, /CELL, /WHOLE, /UNIT, etc. etc.</p>
          <p><a href="https://forum.rebol.info/t/cutting-out-only-could-we-make-append-find-etc-only-accept-blocks/1182/8">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/cutting-out-only-could-we-make-append-find-etc-only-accept-blocks/1182/8</link>
        <pubDate>Sat, 24 Aug 2019 21:39:02 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1182-8</guid>
        <source url="https://forum.rebol.info/t/cutting-out-only-could-we-make-append-find-etc-only-accept-blocks/1182.rss">Cutting out /ONLY: Could we make APPEND, FIND, etc *only accept blocks*?</source>
      </item>
      <item>
        <title>Cutting out /ONLY: Could we make APPEND, FIND, etc *only accept blocks*?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>While implementing a trial of the new APPEND+INSERT+CHANGE logic for "modal parameters", I managed to get the system to boot without having to force every call to have either a /SPLICE or an /ONLY.  I did it by restricting the rule to saying you only had to disambiguate if the second arg was an ANY-ARRAY!.</p>
<p>In light of modal parameters making a <a href="https://forum.rebol.info/t/an-append-for-a-dont-splice-by-default-world/1185/3">nice test case uglier</a>, this got me to wondering if there is a compromise on the "always append blocks" rule this post was conceived with...</p>
<p>What if you were restricted to appending BLOCK! to ANY-ARRAY!s, unless you used /ONLY ?</p>
<pre><code>&gt;&gt; append "abc" "def"
== "abcdef"  ; target is not array, no restriction

&gt;&gt; append [a b c] "def"
** Error: Must splice BLOCK! arguments with ANY-ARRAY! unless /ONLY is used

&gt;&gt; append [a b c] ["def"]
== [a b c "def"]

&gt;&gt; append/only [a b c] "def"
== [a b c "def"]

&gt;&gt; append [a b c] [d e f]
== [a b c d e f]

&gt;&gt; append/only [a b c] [d e f]
== [a b c [d e f]]
</code></pre>
<p>This is a curious thought.  It seems like it would be more annoying for the likes of SELECT and FIND, if what you were looking in was an ANY-ARRAY! to make you put everything you were going to search for in a block, unless you used /ONLY.  Maybe modal parameters could help with that:</p>
<pre><code>&gt;&gt; item: 'b

&gt;&gt; find [a b c] item
** Error: FIND in a BLOCK! requires searched for item a BLOCK! if not /ONLY

&gt;&gt; find/only [a b c] item
== [b c]

&gt;&gt; find [a b c] @item
== [b c]
</code></pre>
<p>This matches a bit more the sense of "literally this" that the name LIT-WORD! might suggest here.</p>
<p>Perhaps this suggests a hybrid solution that would be less failure prone.  Code that you saw work once would be unlikely to mysteriously fail.</p>
<hr>
<p><strong>UPDATE: I quickly turned my test around to work this way for APPEND/INSERT/CHANGE and it feels far less disruptive, while seeming to have the effect of helping avoid most of the surprising categories of error that I want to stop.</strong>  It doesn't get rid of /ONLY...but leaves it unnecessary for string targets (as today) and then makes it a requirement if you don't want the argument to a block to be forced as a spliced block.  Modal arguments make it more palatable, especially for things like FIND.  This seems to be closing in on "definitely better".</p>
          <p><a href="https://forum.rebol.info/t/cutting-out-only-could-we-make-append-find-etc-only-accept-blocks/1182/7">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/cutting-out-only-could-we-make-append-find-etc-only-accept-blocks/1182/7</link>
        <pubDate>Mon, 29 Jul 2019 07:35:14 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1182-7</guid>
        <source url="https://forum.rebol.info/t/cutting-out-only-could-we-make-append-find-etc-only-accept-blocks/1182.rss">Cutting out /ONLY: Could we make APPEND, FIND, etc *only accept blocks*?</source>
      </item>
      <item>
        <title>Cutting out /ONLY: Could we make APPEND, FIND, etc *only accept blocks*?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-post="2" data-topic="1182">
<div class="title">
<div class="quote-controls"></div>
<img alt width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/blackattr/40/204_2.png" class="avatar"> BlackATTR:</div>
<blockquote>
<p>I was never a big fan of /only. The refinement name didn't seem intuitive to me. Easy enough to learn it, but not intuitive.</p>
</blockquote>
</aside>
<p>The status-quo choice that solves my current problem is <strong>2a</strong>...which would be to keep /ONLY but limit aggregate default behavior to plain old BLOCK!...not GROUP! or PATH! or anything else.</p>
<p>Over time I guess I've absorbed through osmosis that <strong>append [a b c] [d e]</strong> should not be <strong>[a b c [d e]]</strong>.  Though in reality that comes up much less than "repend" or "join" does.  There's definite friction I feel with having to say <strong>append/multi [a b c] [d e]</strong> to get <strong>[a b c d e]</strong>.</p>
<blockquote>
<p>It may go against the anti-line noise philosophy of rebol, but for my eyes I prefer  <strong>append data (second items)</strong>  and  <strong>append data :[second items]</strong>  over  <strong>append data second items</strong> .</p>
</blockquote>
<p>It's a pretty important Rebol property to avoid noise, but if for every piece of correct code you pretty much have to say <strong>append/only data second items</strong> the noise is just getting pushed around.</p>
<blockquote>
<p>I also like that this proposal feels more consistent, and it will encourage (force?) people more in the direction of using quoting, which I think is a new/enhanced feature worthy of embracing in this version of the language.</p>
</blockquote>
<p>I was feeling somewhat good about the proposal until realizing <strong>:[...]</strong> is not acting like REDUCE.</p>
<p>This thread is a brainstorm to try and see if there's any other option.</p>
<p>Fundmentally the contention we're facing here is that <em>it feels</em> like there's a difference between what people can reasonably think they mean by <strong>append [a b c] [d e]</strong> from <strong>append [a b c] item</strong>.  The former seems like no problem to say "oh of course you meant splice, because you see that is a block".   The latter being generic runs you into frequent risk of failing to make the appropriate discernment.</p>
<p>The question is if any potential tricks to cure the /ONLY illness are worse than the disease.  I don't know, but it's worth having a strong statement of why a problem can't be solved, vs. that it just wasn't because of technical laziness!  <img src="https://forum.rebol.info/images/emoji/twitter/sloth.png?v=9" title=":sloth:" class="emoji" alt=":sloth:"></p>
          <p><a href="https://forum.rebol.info/t/cutting-out-only-could-we-make-append-find-etc-only-accept-blocks/1182/5">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/cutting-out-only-could-we-make-append-find-etc-only-accept-blocks/1182/5</link>
        <pubDate>Mon, 22 Jul 2019 15:30:31 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1182-5</guid>
        <source url="https://forum.rebol.info/t/cutting-out-only-could-we-make-append-find-etc-only-accept-blocks/1182.rss">Cutting out /ONLY: Could we make APPEND, FIND, etc *only accept blocks*?</source>
      </item>
      <item>
        <title>Cutting out /ONLY: Could we make APPEND, FIND, etc *only accept blocks*?</title>
        <dc:creator><![CDATA[BlackATTR]]></dc:creator>
        <description><![CDATA[
            <p>Yikes.<br>
And agreed, <strong>append data :[(second items)]</strong> is definitely a bridge too far.<br>
I get nervous about changes like this and how they might impact Beta/One.</p>
          <p><a href="https://forum.rebol.info/t/cutting-out-only-could-we-make-append-find-etc-only-accept-blocks/1182/4">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/cutting-out-only-could-we-make-append-find-etc-only-accept-blocks/1182/4</link>
        <pubDate>Mon, 22 Jul 2019 15:02:45 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1182-4</guid>
        <source url="https://forum.rebol.info/t/cutting-out-only-could-we-make-append-find-etc-only-accept-blocks/1182.rss">Cutting out /ONLY: Could we make APPEND, FIND, etc *only accept blocks*?</source>
      </item>
      <item>
        <title>Cutting out /ONLY: Could we make APPEND, FIND, etc *only accept blocks*?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>I realized a problem with this, which is that <a href="https://forum.rebol.info/t/get-block-get-and-reduce/1183">GET-BLOCK! does not mean REDUCE anymore</a>.  That's what it did <em>at first</em>, but it was converted into being fully identical to GET of a BLOCK!.  This fetches functions as-is and does not execute them (and has no meaning for GET of 3 or other literals, as r3-alpha allowed).</p>
<p>That means under this concept that <strong>append data :[item]</strong> would actually be a synonym for <strong>append/only data :item</strong>.  If you wanted to run code, you'd be stuck with <strong>append data reduce [second items]</strong>, or even worse <strong>append data (reduce [second items])</strong> if soft-quoting were used.</p>
<p>I mention a compromise that GET of GROUP!s be allowed to work, along with possibly GET of any iert literals:</p>
<pre><code>append data :[(second items)]
</code></pre>
<p>Not great.  Further in the wacky ideas category, it could be that GET of a GROUP! be given its own meaning as REDUCE, e.g. "the executed form of GETting a BLOCK"</p>
<pre><code> &gt;&gt; get '(1 + 2 10 + 20)
 == [3 30]

 &gt;&gt; :(1 + 2 10 + 20)
 == [3 30]
</code></pre>
<p>But I don't like that much either.</p>
<h2>More wacky ideas: built in evaluation to block ops unless you quote</h2>
<p>I looked at this idea briefly, which is:</p>
<pre><code> &gt;&gt; append [a b c] [1 + 2 10 + 20]
 == [a b c 3 30]   ; acts as repend...splicing

 &gt;&gt; append [a b c] '[1 + 2 10 + 20]
 == [a b c 1 + 2 10 + 20]
</code></pre>
<p>While this might look a bit odd, it has the advantage that there don't need to be separate names for the reducing forms of such operations.</p>
<p>Outside of oddity it doesn't solve all the problems.  You have an issue of <em>what to do when you want to splice a block as-is that you have in an expression</em>.  There's no way to do it:</p>
<pre><code>append block1 block2  ; would splice, but would reduce block2

append block1 [block2]  ; would not splice (effectively an /ONLY)

append block1 'block2  ; would append just the word block2
</code></pre>
<h2>This is a tough circle to square, certainly.</h2>
<p>Part of me wonders if the ability of functions like APPEND to see the @ on things without quoting could be leveraged:</p>
<pre><code> &gt;&gt; append [a b c] [d e]
 == [a b c [d e]]

 &gt;&gt; append [a b c] @[d e]
 == [a b c d e]

 &gt;&gt; append [a b c] reverse [d e]
 == [a b c [e d]]

 &gt;&gt; append [a b c] @(reverse [d e])
 == [a b c e d]

 &gt;&gt; item: [d e]

 &gt;&gt; append [a b c] item
 == [a b c [d e]]

 &gt;&gt; append [a b c] @item
 == [a b c d e]
</code></pre>
<p>But that is completely at odds with the problem I found using @ for datatypes, and actually backwards of what you'd think a LIT-XXX! would do (I said "literally" that).  Picking a rarer type that's easy to type for the splice rule sounds tempting on the surface, but maybe even raises the chances of esoteric failure.</p>
<blockquote>
<p><strong>UPDATE:</strong> The esoteric failure I propose being a problem can be taken care of by only allowing the behavior when the source is <em>literally</em> an @-value (not some expression incidentally evaluating to an @-value).  The parameter can remain evaluative, and @-values can be passed as their actual value using quoting.  See <a href="https://forum.rebol.info/t/new-parameter-convention-concept-modal-arguments-or-the-arg/1187">Modal Parameters</a>.</p>
</blockquote>
          <p><a href="https://forum.rebol.info/t/cutting-out-only-could-we-make-append-find-etc-only-accept-blocks/1182/3">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/cutting-out-only-could-we-make-append-find-etc-only-accept-blocks/1182/3</link>
        <pubDate>Mon, 22 Jul 2019 14:59:01 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1182-3</guid>
        <source url="https://forum.rebol.info/t/cutting-out-only-could-we-make-append-find-etc-only-accept-blocks/1182.rss">Cutting out /ONLY: Could we make APPEND, FIND, etc *only accept blocks*?</source>
      </item>
      <item>
        <title>Cutting out /ONLY: Could we make APPEND, FIND, etc *only accept blocks*?</title>
        <dc:creator><![CDATA[BlackATTR]]></dc:creator>
        <description><![CDATA[
            <p>A few quick reactions.</p>
<ol>
<li>
<p>I was never a big fan of /only. The refinement name didn't seem intuitive to me. Easy enough to learn it, but not intuitive.</p>
</li>
<li>
<p>It may go against the anti-line noise philosophy of rebol, but for my eyes I prefer <strong>append data (second items)</strong> and <strong>append data :[second items]</strong> over <strong>append data second items</strong>. I think the added line-noise improves legibility rather than hinders it.</p>
</li>
<li>
<p>I also like that this proposal feels more consistent, and it will encourage (force?) people more in the direction of using quoting, which I think is a new/enhanced feature worthy of embracing in this version of the language.</p>
</li>
</ol>
<p>On the other side of things, I could see how this might feel like a deep change for some developers...</p>
          <p><a href="https://forum.rebol.info/t/cutting-out-only-could-we-make-append-find-etc-only-accept-blocks/1182/2">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/cutting-out-only-could-we-make-append-find-etc-only-accept-blocks/1182/2</link>
        <pubDate>Mon, 22 Jul 2019 14:45:56 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1182-2</guid>
        <source url="https://forum.rebol.info/t/cutting-out-only-could-we-make-append-find-etc-only-accept-blocks/1182.rss">Cutting out /ONLY: Could we make APPEND, FIND, etc *only accept blocks*?</source>
      </item>
      <item>
        <title>Cutting out /ONLY: Could we make APPEND, FIND, etc *only accept blocks*?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>The following Redbol-ism long seemed unnatural to me, of defaulting to breaking paths apart unless you say /ONLY:</p>
<pre><code>rebol2&gt;&gt; append [a b c] first [d/e/f g/h/i]
== [a b c d e f]

rebol2&gt;&gt; append/only [a b c] first [d/e/f g/h/i]
== [a b c d/e/f]
</code></pre>
<p>This raises people's questions about why blocks should default to that, which confuses many a newcomer...and which I was opposed to when I first saw it.</p>
<pre><code>rebol2&gt;&gt; append [a b c] first [[d e f] g/h/i]
== [a b c d e f]
</code></pre>
<p>Ultimately it came to be that using Rebol in practice made me feel splicing was the natural default for many block operations.  <strong>But something long remained uncomfortable with this pattern...</strong> which applies to other routines with this kind of /ONLY (for instance, FIND)...is how it's hard to tell at the callsite what's going to happen when you are talking about data indirectly:</p>
<pre><code> rebol2&gt;&gt; item: [a b c]

 ;... then much later, callsite might suddenly stop working generically
 ;... when you suddenly switch item to a block from something else:

 rebol2&gt;&gt; find reduce [1 + 2 item 3 + 4] item
 == none
</code></pre>
<h2>The known existing schools of thought</h2>
<ol>
<li>
<strong>"splicing should be the special operation"</strong> - you should have to ask for <code>append/splice</code> to get it, with all other appends defaulting to being /ONLY.  More generically the term might be something like <code>/multi</code> so it works e.g. with <code>find/multi</code>
</li>
<li>
<strong>"there's something special about BLOCK!"</strong> - this could be thought of as reinforced logographically by the distinction of using brackets in the <strong>[o]</strong>, that makes it work, so you just know they are weird.<br>
2b. <strong>"there's something special about datatypes where space is the delimiter</strong>, so BLOCK! and GROUP! <em>both</em> count</li>
<li><strong>"it's too late to change any of it it, so leave it as is"</strong></li>
</ol>
<p>I was convinced <span class="hashtag">#1</span> was probably not in Rebol's best interest.  But then I disliked auto-splicing of PATH! enough that I rejected <span class="hashtag">#3</span> as a least-favorite option.  So at one point Ren-C was switched to using <span class="hashtag">#2b</span>.  But...</p>
<h2>Informing this further with a new use case</h2>
<p>I just ran into a problem with <a href="https://forum.rebol.info/t/should-datatype-be-killed-off-in-favor-of-integer-word-etc/1177/7">my proposed usage of @[...] to be an irreducible capture of a datatype, that can also carry a quoting level</a>.  That doesn't work if @[...] blocks are considered a container that needs /ONLY for things like FIND:</p>
<pre><code> find reduce [integer! quoted-word!] quoted-word!
</code></pre>
<p>Becomes:</p>
<pre><code>find [@[integer] @['word]] @['word]
</code></pre>
<p>It today assumes the @[...] is to be handled the same a a regular block.  So this is morally equivalent to:</p>
<pre><code>find [@[integer] @['word]] ['word]
</code></pre>
<p>Which acts the same as:</p>
<pre><code>find [@[integer] @['word]] lit 'word
</code></pre>
<p>That doesn't do what's intended, and doesn't match the datatype.  But it feels ever more haphazard to just pick a random reasoning.</p>
<p><strong>What it makes me feel is that there's just something fundamentally wrong being glossed over.</strong></p>
<h2>Concept: expect [...] <em>always</em>, splice <em>always</em>, leverage :[...]?</h2>
<p>It feels like "at the source level", you want to be able to see whether what you're passing along is going to be treated atomically or not.  This is a parallel to other problems, like what caused <a href="https://forum.rebol.info/t/backpedaling-on-non-block-branches/476">"Backpedaling on non-block branches"</a>.  That was mitigated with <a href="https://forum.rebol.info/t/soft-quoted-branching-light-elegant-fast/1020">soft quoted branching</a>, which carries some other advantages.</p>
<p>One idea could be that <em>appends, insert, finds, etc. always take BLOCK! and always presume splicing semantics</em>.</p>
<pre><code>&gt;&gt; append [a b c] [1 + 2 10 + 20]
== [a b c 1 + 2 10 + 20]  ; compatible with history

&gt;&gt; append [a b c] 3
** Error: APPEND does not accept INTEGER! for its value argument
; Not compatible, but at least an error and not random new behavior

&gt;&gt; append [a b c] [3]
== [a b c 3]  ; compatible with history
</code></pre>
<p>Also allow GET-BLOCK! to ask for reduction along with your splicing:</p>
<pre><code> &gt;&gt; append [a b c] :[1 + 2 10 + 20]
 == [a b c 3 30]
</code></pre>
<p>Block parameters (the only type which would be tolerated) passed in would be spliced--because as mentioned it always takes a block parameter, and they're always spliced:</p>
<pre><code> &gt;&gt; items: [1 [2 + 3] 4]
 &gt;&gt; append [a b c] (second items)
 == [a b c 2 + 3]
</code></pre>
<p>But you could slip past this by using a GET-BLOCK! that has your expression in it...thus it would reduce and get spliced, but leaving the original alone...effectively an /ONLY:</p>
<pre><code> &gt;&gt; items: [1 [2 + 3] 4]
 &gt;&gt; append [a b c] :[second items]
 == [a b c [2 + 3]]
</code></pre>
<h2>Further radicalization - soft quote the second argument?</h2>
<p>If you'd be willing to write <strong>append [a b c] (second items)</strong> always instead of <strong>append [a b c] second items</strong>, <em>then all of the above is compatible with soft-quoting</em>.  You could then use literal material as-is, which could work for BLOCK! and other things:</p>
<pre><code> &gt;&gt; append [a b c] '[1 + 2 10 + 20]
 == [a b c [1 + 2 10 + 20]]

 &gt;&gt; append [a b c] '3
 == [a b c 3]
</code></pre>
<p>As with branching, non-quoted things would complain if you didn't give it a BLOCK!:</p>
<pre><code>&gt;&gt; item: 10
&gt;&gt; append [a b c] (item)
** Error: APPEND only takes BLOCK!, GET-BLOCK!, or QUOTED!

&gt;&gt; append [a b c] [item]
== [a b c item]

&gt;&gt; append [a b c] :[item]
== [a b c 10]

&gt;&gt; append [a b c] '10
== [a b c 10]

&gt;&gt; item: [1 + 2 10 + 20]
&gt;&gt; append [a b c] (item)
== [a b c 1 + 2 10 + 20]
</code></pre>
<p>It would work how an IF doesn't have the rule on its condition but only the branch, it's just the thing to be appended:</p>
<pre><code> &gt;&gt; target: "abcd"

 &gt;&gt; append target ["efg"]
 == "abcdefg"

 &gt;&gt; append target '{ghi}
 == "abcdefghi"
</code></pre>
<h2>Pros</h2>
<ul>
<li>
<strong>You aren't confused when you see <code>append x (y)</code> about what <code>y</code> is going to look up to.  Because if it weren't a block, that would be an error.</strong>  Being introduced from day one to APPEND+INSERT+CHANGE as operations that expect a block of things to be appended... and FIND+SELECT as taking a block of things to be found, might seem strange to us now...but I think the net complexity drops compared to /ONLY and the problems it causes.</li>
<li>
<strong>Kills off the idea of /ONLY and all the mire that accompanies it</strong>.  It is so easy to make mistakes with that, no matter how experienced in Rebol code you are.  I don't feel any satisfying solution has been articulated about it.</li>
<li>
<strong>Has a good alignment with the [o] meaning BLOCK! is a special datatype</strong>.  Sets up a psychological basis for working coherently, and hopefully not making mistakes down the road.  Suggests people use blocks to represent groups of parameters as arguments to functions instead of single items <em>systemically</em>...a better principle to embrace than expecting them how to realize to design every routine with an /ONLY option...which was <a href="https://forum.rebol.info/t/stopping-the-into-virus/705">a bit like the /INTO virus</a>
</li>
<li>
<strong>Can cover REPEND-style cases where the block being repended is source-level with expressions (likely most common)</strong>.  If it's quoting the second argument, it could blend the evaluator into the operation, even if that evaluation is just to reduce a variable name for you to be the item to append.  There's been some amount of issue about performance when the natives are <code>reduce</code> and <code>append</code> and executed in two steps, whereas a reducing append that saw the source GET-BLOCK! could build a right-sized block more efficiently.</li>
<li>
<strong>Single element blocks are pretty efficient; moreso than refinements</strong>  I've mentioned how the design has been set up such that <code>:[a]</code> fits in a single series node, so it's not horrible to need to say <code>append data :[item]</code> instead of <code>append data item</code>... it's actually <em>better</em> than <code>append/only data item</code>.  And quoted things are efficient too, so <code>append data '10</code> costs the same as <code>append data 10</code>.</li>
</ul>
<p>And across the range of allowed inputs, it would be compatible with historical code.  The Redbol emulation would be fairly trivial:</p>
<pre><code>redbol-append: function [series value /only] [
    append series case [
         only [:[value]]  ; evaluates to a spliced BLOCK! with one item in it 
         any-array? value [as block! value]  ; force path/group to block
         default [:[value]]  ; put anything else into a block
     ]
]
</code></pre>
<h2>Cons</h2>
<p>Obviously asking people to write <strong><code>find data [&lt;x&gt;]</code></strong> instead of <strong><code>find data &lt;x&gt;</code></strong> seems blocky, and <strong>find data :[var]</strong> instead of <strong>find data var</strong> is uglier.  Plus <strong>append string ["stuff"]</strong> feels a bit wordy and <strong>append string '{stuff}</strong> makes you change your string delimiter.  This might be mitigated some by being able to say <strong>append string 'stuff</strong> and allowing WORD!-based appends.</p>
<p>...Or perhaps being more lenient when the target is a string type, so the /ONLY distinction wouldn't exist in the first place...so allow any type?  e.g. enforce the "must be a block rule" for the argument <em>only when modifying or searching in arrays</em>?</p>
<p>While the soft quoting is not integral to the proposal, it has that problem of making you say <strong>append data (second items)</strong> instead of <strong>append data second items</strong>.  Regardless of whether one thinks the soft quoting is a good idea, there's much more information there... <em>you know the second thing in items is a block and it will be spliced</em>.  If you saw <strong>append data :[second items]</strong> you don't know what the thing is but you know it's not going to be spliced.</p>
<h2>For those not going with Redbol emulation, it could be a fresh start</h2>
<p>Killing off /ONLY feels like a noble cause to me.</p>
<p>This line of thinking reminds me a bit of the train of thought behind saying that <em>if</em> you have an argument that can take ANY-VALUE!, then you do not use the blank-in-null-out convention for such arguments...you have to switch to thinking of null as some kind of nothing, or accept erroring on null.</p>
<p>So maybe we could consider this a variant of 2 above:</p>
<p><strong>2c.</strong> <strong>BLOCK! has a special use by convention in the language as a "generic container of N things".</strong> You should generally not make a parameter take ANY-VALUE! if that argument intends to use this meaning of BLOCK!.  Instead you should <em>always</em> take a block, even if just to provide a single thing, for clarity at the callsites.<br>
<strong>2c.1.</strong> If your use case fits it, you can use soft-quoting to allow QUOTED! values to indicate single items as a shorthand--at the cost of having to put expressions producing BLOCK!s into GROUP!s.<br>
<strong>2c.???.</strong> (maybe?) If you have a span of target cases where multiple items cannot be handled differently from single items (e.g. <strong>find</strong> of a TEXT! in a TEXT! has no distinct meaning from <strong>find</strong> of a BLOCK! with that TEXT! in it, where an /ONLY refinement would have no meaning) then these cases may be tolerated as missing the BLOCK! container for single elements.</p>
          <p><a href="https://forum.rebol.info/t/cutting-out-only-could-we-make-append-find-etc-only-accept-blocks/1182/1">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/cutting-out-only-could-we-make-append-find-etc-only-accept-blocks/1182/1</link>
        <pubDate>Mon, 22 Jul 2019 05:28:25 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1182-1</guid>
        <source url="https://forum.rebol.info/t/cutting-out-only-could-we-make-append-find-etc-only-accept-blocks/1182.rss">Cutting out /ONLY: Could we make APPEND, FIND, etc *only accept blocks*?</source>
      </item>
  </channel>
</rss>
