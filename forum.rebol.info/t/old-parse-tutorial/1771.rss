<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Old Parse Tutorial</title>
    <link>https://forum.rebol.info/t/old-parse-tutorial/1771</link>
    <description>&gt;This is an old tutorial which originally appeared on codeconscious.com. It has been posted here in the expectation that codeconscious.com will be decommissioned early 2022. Other old articles on REBOL can be found at [REBOL by codeconscious.com on archive.org](https://web.archive.org/web/*/https://codeconscious.com/rebol/)

Introduction
============

&gt;Note: This article is a revised version written for open sourced Rebol (Rebol 3), the original Rebol 2 version is here: [Parse Tutorial for Rebol 2](https://codeconscious.com/rebol/parse-tutorial.html).

If you want to extract data from strings (like HTML, TXT, CSV, etc.) consider Parse.

If you want to just check some user data against a specific format consider using Parse.

If you want to validate some message written in your new dialect use Parse.

Parse is useful.

Parse is quick.

Parse operates on string, binary and block input.  Using Parse you can process these types of input in some way, overlaying the input with new meaning. That is you have a string or block and you are perhaps identifying fields of records, tokens of a language or even identifying sections of a message protocol.

This document is a very rough show by example description of Parse with a few warnings thrown in.

Parse Dialect
================

You give Parse a rule block containing instructions to follow written in the Parse dialect. These instructions allow you to utilise Parse to interpret custom external formats or protocols. These instructions can be as simple or as complex as you need. A simple example would be to check that some input against postal code format. A sophisticated example is Rebol&#39;s URL parser (help sys/*parse-url/rules).

The instructions are written using the Parse dialect and tell Parse how to read through your input. In actual fact, the instructions describe the patterns that the input should take. Parse attempts to match the input against your patterns. Parse will return a TRUE result if your instructions accurately describe the input. If your instructions fail to describe the input (or looking at it the other way, the input fails to follow your rules) Parse will return FALSE. You also have the ability to carry out normal Rebol operations as Parse traverses the input and your rules.

It is very important to realise that the keywords of the Parse dialect are interpreted by Parse in a specific way and should be considered as being different in meaning to Rebol words when used at the console.

Let&#39;s start at the end
----------------------

    &gt;&gt; input-string: {}
    &gt;&gt; parse input-string [end]
    == true

Ah success! Here I am parsing an empty string. My rule says to Parse &quot;check that we are at the end&quot;. The result is of course TRUE because the string was empty to begin with.

This is similar in normal Rebol script to:

    &gt;&gt; tail? input-string
    == true

Baby steps
----------

Next up, let&#39;s test that a string matches our expectations:

    &gt;&gt; input-string: &quot;fox&quot;
    == &quot;fox&quot;
    &gt;&gt; parse input-string [&quot;fox&quot; end]
    == true

We successfully tested that the input started with &quot;fox&quot; and then finished. Ok, no big deal.

But reflect a moment. This is a sequence - first &quot;fox&quot; then END. As Parse traverses the input

and your rule block, it keeps track of a current position for both. So at the start, the current position in the input is at the head of the string. After the rule &quot;fox&quot; was matched the current position in the input string will be directly after the &quot;x&quot; of &quot;fox&quot;.

In this example, this happens to be the tail of the string, so the very next match rule END will succeed.

We do not always have to supply an END in the rule block. You can omit it in the last example because Parse effectively slaps one on at the end anyway.

    &gt;&gt; parse input-string [&quot;fox&quot;]
    == true

While you can do this for simple examples, remember you&#39;ll likely need to add it in

explicitly for more complex rules.

Ok, back to the example again. In an ordinary Rebol session the above example is similar to the following:

    &gt;&gt; input-string: find/match input-string &quot;fox&quot;
    == &quot;&quot;
    &gt;&gt; tail? input-string
    == true

Note that the ordinary Rebol code examples through this article are provided to help learn Parse. There are enough important differences between the Parse examples and the ordinary code examples that you cannot alway treat them as exactly equivalent.

Failures / challenges
---------------------

For contrast let&#39;s look at an unsuccessful match:

    &gt;&gt; input-string: &quot;dog&quot;
    == &quot;dog&quot;
    &gt;&gt; parse input-string [&quot;fox&quot;]
    == false

The meaning of this is pretty obvious. Hang on though, what actually happens when Parse encounters a failure with one of the rules? Well it backtracks the input to the point it was at when the rule started. So in Rebol code what happens is actually more like this:

    input-string: &quot;dog&quot;
    If position: Find/match input-string &quot;fox&quot; [input-string: position]
    Tail? input-string

Keep this little idea in the back of your mind, it becomes more meaningful with more complex rules.

Optional matching and Compound Rules
------------------------------------

What if we want to check for a number of common pet alternatives?

Let&#39;s accept a &quot;dog&quot; or a &quot;cat&quot; or indeed a &quot;bird&quot;:

    &gt;&gt; input-string: &quot;dog&quot;
    == &quot;dog&quot;
    &gt;&gt; parse input-string [&quot;dog&quot; | &quot;cat&quot; | &quot;bird&quot;]
    == true

In ordinary Rebol this is like coding:

    input-string: any [
        find/match input-string &quot;dog&quot;
        find/match input-string &quot;cat&quot;
        find/match input-string &quot;bird&quot;
    ]
    tail? input-string

Now, Rebol can be pretty concise and the ANY function definitely helps in writing concise code, but you can see already that the Parse dialect is looking to be better suited to matching than ordinary scripting.

Reflecting on this a bit. We have here a more interesting rule, a compound rule. Our compound rule is composed of three subrules. Each of the three subrules here are very basic but subrules are allowed to be compound rules themselves. The basic rules perform the lowest level matching of the input, the compound rules check the overall structure/grammar of your data.

Back to options. What about something that may or may not exist at all? Using OPT we can indicate that a bird could be big or just leave it out:

    &gt;&gt;  input-string: &quot;bigbird&quot;
    == &quot;bigbird&quot;
    &gt;&gt;  parse input-string [opt &quot;big&quot; &quot;bird&quot;]
    == true
    &gt;&gt; input-string: &quot;bird&quot;
    == &quot;bird&quot;
    &gt;&gt; parse input-string [opt &quot;big&quot; &quot;bird&quot;]
    == true

There are more Parse options such as NOT which give you greater flexibility in specifying your rules. We&#39;ll cover this later.

Spaces and Split
----------------

Parse treats spaces like any other character. Note that Rebol 3 acts differently here to Rebol 2 as whitespace is now parsed by default without needing the /ALL refinement

    &gt;&gt;  input-string: &quot;black dog&quot;
    == &quot;black dog&quot;
    &gt;&gt;  parse input-string [&quot;black&quot; &quot; &quot; &quot;dog&quot;]
    == true

There are constants defined for common characters such as SPACE, NEWLINE and TAB which can be used instead.

    &gt;&gt;  parse input-string [&quot;black&quot; space &quot;dog&quot;]
    == true

To make things easier we can use the SPLIT function to pre-process the input string. SPLIT breaks up the string based on a given delimeter or other rules.

    &gt;&gt; parse split &quot;brown dog&quot; &quot; &quot; [&quot;brown&quot; &quot;dog&quot;]
    == true

If we look at the output of split we see the following.

    &gt;&gt; split &quot;brown dog&quot; &quot; &quot;
    == [ &quot;brown&quot; &quot;dog&quot; ]

In this case split is returning a block of strings simplifying our work with Parse.

Blocks, repetition and more
===========================

Using Parse for strings is good, but using parse on native Rebol datatypes really shows its power.

Rebol has a rich set of datatypes which simplify parsing data, and code.

This mode is used when the value to be parsed is actually a block not a string. You use this mode when you have already loaded data into Rebol values. You write Parse instructions in a rule block using the parse dialect in a similar way to that described for parsing strings except when parsing blocks the semantics are different and you have a couple more keywords to use.

This is the mode of Parse that deserves the attention of anyone using Rebol. The reason is that you are free to store your data in a form understandable by yourself and others and yet is still computer readable.

First steps parsing blocks
--------------------------

As we move from strings to blocks we can start to use some of the Rebol datatypes to make our lives much easier.

    &gt;&gt; parse [1234.16] [number!]
    == true

   

Processing dates and times are a good example. You can see how the datatypes support a wide range of input formats. It is worth noting for Americans that Rebol always assumes day/month/year order.

    &gt;&gt; parse [12/Dec/2012 2:30pm ] [date! time!]
    == true

There are many more datatypes although that does not stop you from using strings for datatypes which do not map to Rebol types.

   

    &gt;&gt; parse [&lt;div&gt; &quot;Hello&quot; http://rebol.com $1.00 &lt;/div&gt; bob@test.com ] [ tag! &quot;Hello&quot; url! money! tag! email!]
    == true

Repetition - known range of occurrences
---------------------------------------

Time for some more compound rules.

Here&#39;s how to check for exactly two dogs.

    &gt;&gt; parse &quot;dogdog&quot; [2 &quot;dog&quot;]
    == true

I can specify between 1 and 4 Zs (inclusive) too:

    &gt;&gt;  parse &quot;Zzzz&quot; [1 4 &quot;z&quot;]
    == true

Note that by default Parse is not case sensitive unless you want it to be by using the /CASE refinement:

    &gt;&gt; parse/case &quot;ZZ&quot; [2 &quot;Z&quot;]
    == true

This is also very powerful for parsing blocks:

    &gt;&gt; parse [ http://rebolsource.net http://rebol.org http://rebol.com ] [ 3 url! ]
    == true

Repetition again :) - unknown number of occurrences
---------------------------------------------------

What if we grab a net and go prawning? We may not know how many prawns are caught by the net when we catch them:

    &gt;&gt; loop random 100 [append input-string: &quot;&quot; &quot;prawn&quot;]
    == &quot;prawnprawnprawnprawn&quot;
    &gt;&gt; parse input-string [some &quot;prawn&quot;]
    == true

Excellent, we have some prawns but we don&#39;t know how many.

The SOME keyword means &quot;match one or more of the following&quot;. Again it is a compound rule because I could have as easily done this if it was &quot;raining cats and dogs&quot;:

    &gt;&gt; input-string: &quot;dogdogcatdogcat&quot;
    == &quot;dogdogcatdogcat&quot;
    &gt;&gt; parse input-string [some [ &quot;dog&quot; | &quot;cat&quot;] ]
    == true

If it fines up:

    &gt;&gt; input-string: {}
    == &quot;&quot;
    &gt;&gt; parse input-string [some [ &quot;dog&quot; | &quot;cat&quot;]  ]
    == false

It returns false because SOME requires at least one instance to be matched. If however, we don&#39;t actually care whether we get some or not we can use ANY:

    &gt;&gt; input-string: {}
    == &quot;&quot;
    &gt;&gt; parse input-string [any [ &quot;dog&quot; | &quot;cat&quot; ] ]
    == true
    &gt;&gt; input-string: &quot;dog&quot;
    == &quot;dog&quot;
    &gt;&gt; parse input-string [any [ &quot;dog&quot; | &quot;cat&quot;] ]
    == true

Here is another example of one of those Rebol words with a new meaning in the context of Parse. In ordinary Rebol ANY is a function that return the first non-false or non-none value in the block it is given. In Parse, by contrast, ANY is a keyword that introduces a compound rule that means, &quot;match zero or more of the following&quot;.

Repetition works equally well for blocks:

    &gt;&gt; parse [Fibonacci 1 1 2 3 5 8 13] [some [number! | word!] ]
    == true

Moving right along...
----------------------

Sometimes we really couldn&#39;t care less what lies between things of interest.

This example does not &quot;skip c&quot; it reads &quot;match a, skip a character, match c, tail?&quot;.

    &gt;&gt; parse {abc} [&quot;a&quot; skip &quot;c&quot; end]
    == true

You want to skip 5 characters? Use repetition:

    &gt;&gt; parse {1234567890} [&quot;123&quot; 5 skip &quot;90&quot; end]
    == true

Sometimes we don&#39;t know how much is in between but we do know what is the next interesting bit:

    &gt;&gt; input-string: {1234 fox}
    == &quot;1234 fox&quot;
    &gt;&gt; parse input-string [thru &quot;fox&quot; end]
    == true

This is like the Rebol code of:

    &gt;&gt; input-string: find/tail input-string &quot;fox&quot;
    == &quot;&quot;
    &gt;&gt; tail? input-string
    == true

We can stop where fox starts using TO:

    &gt;&gt;  input-string: &quot;1234 fox&quot;
    == &quot;1234 fox&quot;
    &gt;&gt;  parse input-string [to &quot;fox&quot; &quot;fox&quot; end]
    == true

And the Rebol code that performs similarly:

    input-string: {1234 fox}
    input-string: find input-string &quot;fox&quot;
    input-string: find/match input-string &quot;fox&quot;
    tail? input-string

   

We can skip to the end as well:

    &gt;&gt;  parse {123456} [&quot;123&quot; to end end]
    == true

This says &quot;match 123, move to the tail, test tail&quot;. Pretty obvious we would get a true result if you think of it in these terms.

While we&#39;re here how about a warning. The rule [to end] moves to the tail and reports

success every time.

All these characters
--------------------

Charset. Stands for character set. It is a bitset which makes it fast for pattern matching operations.

Let&#39;s say you only want to check that your input contains the digits 0 to 9.

    &gt;&gt; digit: charset [#&quot;0&quot; - #&quot;9&quot;]

Now parse can use this directly as a pattern matching instruction. It will match one character (byte) only of those in the set 0 - 9.

    &gt;&gt; parse {1} [digit]
    == true

Naturally enough you can use these in compound rules too:

An Australian postcode consists of 4 numeric digits so:

    &gt;&gt; parse {2069} [4 digit]
    == true

Charsets (bitsets) are sets and you can apply the set operations union, intersection, exclude, etc

on them:

    letter: charset [#&quot;a&quot; - #&quot;z&quot; #&quot;A&quot; - #&quot;Z&quot;]
    digit: charset [#&quot;0&quot; - #&quot;9&quot;]
    letter-or-digit: union letter digit
    valid-name: [letter any letter-or-digit]
    &gt;&gt;  parse {1abc} valid-name
    == false
    &gt;&gt;  parse {rebol} valid-name
    == true
    &gt;&gt;  parse {xyz1234} valid-name
    == true

Maybe you want everything but digits:

    &gt;&gt; parse {A} [not digit skip]
    == true

Notice how we needed to SKIP forward as NOT simply inverses the following rule and does not advance the input.

This is different from the Rebol 2 approach of creating a COMPLEMENT of a charset. This may work in some situations, but will not always give you the desired result due to the use of UNICODE in Rebol 3.

But I want some information from it!
------------------------------------

Up to this point I&#39;ve concentrated on the various matching functionality of Parse. Of course though you want to extract information from your data. The keyword of note for this purpose is COPY. Also of use is the ability to execute Rebol code within the Parse rules (actions) and thereby set and maintain Rebol variables (eg. Counters) using that code.

Ok COPY.

Copy is really really simple really. It is a compound rule that takes two arguments a variable and a subrule. Whatever input the subrule matches gets copied into the variable. If the subrule doesn&#39;t match anything (fails) COPY returns the failure but leaves the variable unchanged.

Here the subrule is to match an &quot;A&quot; which obviously fails.

    &gt;&gt; parse {123} [copy some-text &quot;A&quot;]
    == false
    &gt;&gt; some-text
    ** Script error: some-text has no value

Here the subrule is a simple skip:

    &gt;&gt; parse {123} [copy some-text skip to end]
    == true
    &gt;&gt; some-text
    == &quot;1&quot;

And here the subrule is to match nothing NONE which is always successful so copy copies that which was matched...an empty string:

    &gt;&gt; parse &quot;123&quot; [copy some-text none]
    == false
    &gt;&gt; some-text
    == &quot;&quot;

Another way of getting data is by using SET:

    &gt;&gt; parse [ $100 ] [ set wallet money! ]
    == true
    &gt;&gt; wallet
    == $100

Bring on the code (actions)
---------------------------

Ordinary Rebol code can be used inside the parse dialect via the use of &quot;(&quot; and &quot;)&quot; i.e. a Paren! series:

    &gt;&gt; parse {} [(print &quot;some code just executed&quot;) end]
    some code just executed
    == true

Obviously this is very handy. Even nicer is that it runs according to its placement in the rule. Note though that even if the rule ultimately fails your code may have already run:

    &gt;&gt; parse {123} [
         &quot;1&quot; (print &quot;found 1!&quot;)
         &quot;2&quot; (print &quot;found 2!&quot;)
         &quot;A&quot; (print &quot;found an A!&quot;)
        end
    ]
    found 1!
    found 2!
    == false

So the upshot is you can maintain counters and take actions based on your Parse rules.

During development it can be useful to put print statements in these allowing you to see what is happening.

&lt;!---

;## Add a better wrap up to this section and introduce the advanced section

;##Complete advanced section later

;##

;## NOTES:

;##Notes - I didn&#39;t know about all of these. Found them in base-constants.r (https://github.com/rebol/rebol/blob/master/src/mezz/base-constants.r)

;;-- Char constants:

;null:      #&quot;^(NULL)&quot;

;space:     #&quot; &quot;

;sp:        space

;backspace: #&quot;^(BACK)&quot;

;bs:        backspace

;tab:       #&quot;^-&quot;

;newline:   #&quot;^/&quot;

;newpage:   #&quot;^l&quot;

;slash:     #&quot;/&quot;

;backslash: #&quot;\&quot;

;escape:    #&quot;^(ESC)&quot;

;cr:        #&quot;^M&quot;

;lf:        newline

;crlf:      &quot;^M^J&quot;

;Part 2

--&gt;

Advanced section
================

Repeated Repetition
-------------------

Now that I&#39;ve introduced repetition and compound rules, what happens if I create a compound rule made up of nested repetition rules? Hmm, tricky.

This next example put Parse into a spin - an infinite loop. The escape key will not work, but you can break out with Ctrl+c:

    &gt;&gt; input-string: {}
    == {}
    &gt;&gt; parse input-string [while [any &quot;dog&quot;] ]

&lt;!---
;#note:  Answer above must include that While does not check to see if input position has advanced, but Any does so will need to introduce the concept that parse checks to see if input position is advanced.

;#note: perhaps AND can be introduced before the infinite loop - because it does not advance the input position - need a good example for it.
--&gt;

To understand why this infinite loop happens you need to know when the ANY rule returns success and when it completes.

Here&#39;s the major answer: WHILE ALWAYS returns success.

WHILE will keep calling its subrule while that subrule returns success regardless of if the input position advances. WHILE gives up on receipt of bad news (failure) but it itself always returns success. Now if WHILE always receives a success because it&#39;s subrule in fact is another WHILE or ANY... Well I think that explains it.

Remember OPT. It always returns success just like WHILE. So putting an OPT inside an WHILE is bound to lead to trouble as well.

The point then is that your repetition compound rules must be carefully written because of the possibility of creating these infinite loops. It is not a bug in Rebol, it is consequence of having a flexible Parse dialect.

Sometimes these infinite loops start only after traversing lots of other complex rules and therefore can become hard to catch. I create these loops less often now since I started considering how I want Parse&#39;s input position to move. When writing your rules consider how the input is consumed by the rules.

That&#39;s part of the reason why I&#39;ve been demonstrating the Rebol code similar to the various Parse examples.

Not all combinations of repetition rules create infinite loops:

    &gt;&gt;  input-string: {}
    == &quot;&quot;
    &gt;&gt;  parse input-string [while [some &quot;dog&quot;] ]
    == true

This last example is ok because the SOME does not always return success - it must consume some input. If SOME does not have at least one success it

returns a failure result. So you can see that at some point, given that we can assume that the input is

finite, the overall rule must terminate.

Quoting Ladislav, &quot;The dangerous rules are rules, that don&#39;t consume any input, yet they return success.&quot;

There is another way to escape when you don&#39;t want your rule to progress further - the BREAK keyword. BREAK terminates the rule when it is encountered.

This could be used to improve performance by stopping evaluation of unnecessary rules.

    &gt;&gt; parse [1 2 end 3 4 5 7 8 9] [some [integer! | &#39;end break]]
    == false

This rule will exist as soon as it reaches the end keyword improving the performance.

Debugging parse rules
---------------------

The ?? command is invaluable in debugging Parse rules.

    &gt;&gt; parse &quot;dog&quot; [ ?? &quot;d&quot; ?? [ &quot;i&quot; | &quot;o&quot; ] ?? &quot;g&quot; ?? ]
    &quot;d&quot;: &quot;dog&quot;
    [&quot;i&quot; | &quot;o&quot;]: &quot;og&quot;
    &quot;g&quot;: &quot;g&quot;
    end!: &quot;&quot;
    == true

It displays the next rule and the current position in the series being parsed.

The current index and manipulating it
-------------------------------------

Parse maintains a reference to the input. The reference is a series and so has a current index.

Some special Parse dialect syntax allows you to get and set this reference. You use a set-word and get-word syntax respectively.

In this example I set the word &quot;mark&quot; to the input series at the current index that Parse has, don&#39;t worry about the false - it is just saying we didn&#39;t get all the way through the input:

    &gt;&gt;  parse {123456} [&quot;123&quot; mark:]
    == false
    &gt;&gt; mark
    == &quot;456&quot;

I can manipulate the current index that Parse uses too:

    &gt;&gt;  parse {1234567} [&quot;123&quot; mark: (mark: next next mark) :mark &quot;67&quot;]
    == true

To explain. First &quot;123&quot; is matched, then the word mark is set to the reference.

Then the Rebol code between the parentheses is evaluated. This code manipulates the reference we hold by two characters. I return this modified reference to Parse using the get-word syntax. Parse seeing the get-word syntax knows that it must update it&#39;s reference to that given. Finally I match the &quot;67&quot;.

More Block examples ...
-----------------------

&lt;!---
;## we&#39;ll need a section on INTO for block parsing (just found out I never covered that before), note that it has to come after AND (see INTO comments here http://www.codeconscious.com/rebol/r2-to-r3.html#parse)

;    &gt;&gt; letter: charset [#&quot;a&quot; - #&quot;z&quot; #&quot;A&quot; - #&quot;Z&quot;]

;    &gt;&gt; parse [1 &quot;plus&quot; 2] [integer! and string! into [some letter] integer!]

;    == true
--&gt;

An example that shows what can be achieved is Carl Sassenrath&#39;s stock transaction example which you can see below. Now what if &quot;sell 300 shares at $89.08&quot; came in via email?

If you study this example you will see that Carl, in a very small space, has created a small interpreter that parses, validates and performs computations. This is very powerful technology that is easily underestimated because it is so small and simple.

    rule: [
        set action [&#39;buy | &#39;sell]
        set number integer!
        &#39;shares &#39;at
        set price money!
        (either action = &#39;sell [
                print [&quot;income&quot; price * number]
                total: total + (price * number)
            ] [
                print [&quot;cost&quot; price * number]
                total: total - (price * number)
            ]
        )
    ]
    total: 0
    parse [sell 100 shares at $123.45] rule
    print [&quot;total:&quot; total]
    total: 0
    parse [
        sell 300 shares at $89.08
        buy 100 shares at $120.45
        sell 400 shares at $270.89
    ] [some rule]
    print [&quot;total:&quot; total]

Another powerful example of this is the VID dialect of Rebol/View 2. VID describes in a
effective but simple way what should appear on screen. VID is actually a block using normal
Rebol values such as words and strings. The LAYOUT function of Rebol/View 2 takes a VID
block as an argument to construct the visual objects. Layout uses Parse to process the
VID specification.

Special situations
==================

When you do NOT want to match a pattern
---------------------------------------

&lt;!---

;##Introduce basic NOT, need to fix this.

--&gt;

NOT does not consume input, so you can use it one ore more times before matching something else:

    &gt;&gt; parse &quot;bird&quot; [not &quot;big&quot; &quot;bird&quot;]
    == true

One situation where you might do this is when you have a sub rule that might &quot;consume&quot; something needed by an enclosing rule.

For my example, I&#39;ll Parse a block rather than text but the concept still applies.

I want to Parse the following block, and print out every word, but if I encounter a bar (&quot;|&quot;) I&#39;ll print out the text &quot;**********&quot;:

    my-block: [ the quick brown fox | jumped | over the lazy]

This next bit of code will not work. If you try it you will see that no &quot;*&quot; is printed, instead you will see the &quot;|&quot;:

    single-word: [set item word! (print mold item)]
    phrase: [some single-word]
    parse my-block [ phrase some [&#39;| (print &quot;**********&quot;) phrase] ]

The thing to note is that the bar &quot;|&quot; is a word too. Therefore the bar is &quot;consumed&quot; by the rule called SINGLE-WORD.

So one way to solve this is to give SINGLE-WORD some indigestion (make it fail) when it encounters a bar.

You can force a rule to fail using the FAIL keyword but here we use AND and NOT to make the rule fail under a specific condition.

To make it clear what is happening here, I wrap SINGLE-WORD with a rule I call WORD-EXCEPT-BAR. The

purpose of this new rule is to fail if it finds the &quot;|&quot; word otherwise it goes ahead and runs SINGLE-WORD.

I&#39;ve added comments to clarify how WORD-EXCEPT-BAR works:

    word-except-bar: [
        and not &#39;| ; Without advancing the input position, is this not a bar?
        single-word ; Match single-word
    ]

The point to note here is that the rule AND NOT &#39;| is a &quot;guard&quot; - it guards the next rule from consuming input under a specific condition.

I also need to modify PHRASE to call WORD-EXCEPT-BAR.

    phrase: [some word-except-bar]

   

Another way to describe the PHRASE rule, as it is now, is &quot;a rule that matches a series of words which does not contain the word |.&quot;

To finish off I&#39;ll create a function to call parse with the correct rule and

wrap the whole lot in an object just to be tidy:

    word-parsing-object: context [
        single-word: [set item word! (print mold item)]
        word-except-bar: [and not &#39;| single-word]
        phrase: [some word-except-bar]
        set &#39;parse-words func[ a-block [block!] ] [
            parse a-block [phrase some [&#39;| (print &quot;**********&quot;) phrase] ]
        ]
    ]

Here is a test run:

    &gt;&gt; parse-words [the quick brown fox | jumped | over the lazy]
    the
    quick
    brown
    fox
    **********
    jumped
    **********
    over
    the
    lazy
    == true

In summary in this section I have demonstrated how one can match a specific pattern even when a more general pattern (that includes the specific pattern) gets to see the input first.

Why didn&#39;t you just write...
----------------------------

    parse-words: func [a-block [block!]] [
        parse a-block [
            some [
                &#39;| (print &quot;**********&quot;) |
                set item word! (print mold item)
            ]
        ]
    ]

That is the better way to solve the problem, but the point is to demonstrate the concept of preventing a subrule from consuming certain input and how to use AND as a guard. There are situations when you need these ideas.

The BREAK keyword
-----------------

&lt;!---

;##Needs a practical example rather than the contrived ones here. Perhaps introduce after IF?

--&gt;

From RT&#39;s changes document:

    When the BREAK word is encountered within a rule block, the block is
    immediately terminated regardless of the current input pointer.
    Expressions that follow the BREAK within the same rule block will not
    be evaluated.

   

BREAK is usually used with repetition. In this example the SOME rule is exited early:

    &gt;&gt; parse &quot;X&quot; [some [ (print &quot;*Break*&quot;) break] &quot;X&quot;]
    *Break*
    == true

Here again the SOME rule is exited early just like the previous example. In this case the rule that SOME is processing is referred to by a word:

    &gt;&gt; rule-to-break: [(print &quot;*Break*&quot;) break]
    == [(print &quot;*Break*&quot;) break]
    &gt;&gt; parse &quot;X&quot; [some rule-to-break &quot;X&quot;]
    *Break*
    == true

Related toolset
===============

I have written &quot;Parse Analysis Toolset&quot; to help learn and analyse the way Parse works. The Explain-parse function of the toolset should help with learning Parse. The script has related documentation. You can find the script and a linkg to the documentation at:

[parse-analysis.r (at REBOL.org Script Library)](http://www.rebol.org/cgi-bin/cgiwrap/rebol/view-script.r?script=parse-analysis.r)

One more program I&#39;ve made can return a parse tree of your input:

[load-parse-tree.r (at REBOL.org Script Library)](http://www.rebol.org/cgi-bin/cgiwrap/rebol/documentation.r?script=load-parse-tree.r)

Comments
========

Parse is a key component Rebol. Rebol is promoted as a messaging
language. Messages can come in many formats (syntaxes). Parse allows
you to define the syntax of a message so that you can interpret the message and transform
it to something else or act on it directly. That may sound complex, but it isn&#39;t really.

What are messages? Lots of things can be considered as messages. Basically if you can
put it into a file and the format of the file has some rule to it, then I think you have
a message. You don&#39;t have to put it in a file though to use Parse. Rebol&#39;s networking
functions use Parse to interpret many of the internet protocols that Rebol provides
access to.

With Rebol you can define a mini-language for a specific purpose - a dialect. Outside Rebol this would be called a domain-specific language or DSL.

Parse helps you to validate and process such dialects. You might want to design a dialect for creating web pages on your internet site. Or perhaps for controlling a special device you have attached to your computer.

Acknowledgement
===============

Thank you to John Kenyon for his initiative, edits and effort as we updated this article from the original.</description>
    
    <lastBuildDate>Sun, 12 Dec 2021 00:08:48 +0000</lastBuildDate>
    <category>Parsing</category>
    <atom:link href="https://forum.rebol.info/t/old-parse-tutorial/1771.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Old Parse Tutorial</title>
        <dc:creator><![CDATA[Brett]]></dc:creator>
        <description><![CDATA[
            <blockquote>
<p>This is an old tutorial which originally appeared on <a href="http://codeconscious.com">codeconscious.com</a>. It has been posted here in the expectation that <a href="http://codeconscious.com">codeconscious.com</a> will be decommissioned early 2022. Other old articles on REBOL can be found at <a href="https://web.archive.org/web/*/https://codeconscious.com/rebol/">REBOL by codeconscious.com on archive.org</a></p>
</blockquote>
<h1>Introduction</h1>
<blockquote>
<p>Note: This article is a revised version written for open sourced Rebol (Rebol 3), the original Rebol 2 version is here: <a href="https://codeconscious.com/rebol/parse-tutorial.html">Parse Tutorial for Rebol 2</a>.</p>
</blockquote>
<p>If you want to extract data from strings (like HTML, TXT, CSV, etc.) consider Parse.</p>
<p>If you want to just check some user data against a specific format consider using Parse.</p>
<p>If you want to validate some message written in your new dialect use Parse.</p>
<p>Parse is useful.</p>
<p>Parse is quick.</p>
<p>Parse operates on string, binary and block input.  Using Parse you can process these types of input in some way, overlaying the input with new meaning. That is you have a string or block and you are perhaps identifying fields of records, tokens of a language or even identifying sections of a message protocol.</p>
<p>This document is a very rough show by example description of Parse with a few warnings thrown in.</p>
<h1>Parse Dialect</h1>
<p>You give Parse a rule block containing instructions to follow written in the Parse dialect. These instructions allow you to utilise Parse to interpret custom external formats or protocols. These instructions can be as simple or as complex as you need. A simple example would be to check that some input against postal code format. A sophisticated example is Rebol's URL parser (help sys/*parse-url/rules).</p>
<p>The instructions are written using the Parse dialect and tell Parse how to read through your input. In actual fact, the instructions describe the patterns that the input should take. Parse attempts to match the input against your patterns. Parse will return a TRUE result if your instructions accurately describe the input. If your instructions fail to describe the input (or looking at it the other way, the input fails to follow your rules) Parse will return FALSE. You also have the ability to carry out normal Rebol operations as Parse traverses the input and your rules.</p>
<p>It is very important to realise that the keywords of the Parse dialect are interpreted by Parse in a specific way and should be considered as being different in meaning to Rebol words when used at the console.</p>
<h2>Let's start at the end</h2>
<pre><code>&gt;&gt; input-string: {}
&gt;&gt; parse input-string [end]
== true
</code></pre>
<p>Ah success! Here I am parsing an empty string. My rule says to Parse "check that we are at the end". The result is of course TRUE because the string was empty to begin with.</p>
<p>This is similar in normal Rebol script to:</p>
<pre><code>&gt;&gt; tail? input-string
== true
</code></pre>
<h2>Baby steps</h2>
<p>Next up, let's test that a string matches our expectations:</p>
<pre><code>&gt;&gt; input-string: "fox"
== "fox"
&gt;&gt; parse input-string ["fox" end]
== true
</code></pre>
<p>We successfully tested that the input started with "fox" and then finished. Ok, no big deal.</p>
<p>But reflect a moment. This is a sequence - first "fox" then END. As Parse traverses the input</p>
<p>and your rule block, it keeps track of a current position for both. So at the start, the current position in the input is at the head of the string. After the rule "fox" was matched the current position in the input string will be directly after the "x" of "fox".</p>
<p>In this example, this happens to be the tail of the string, so the very next match rule END will succeed.</p>
<p>We do not always have to supply an END in the rule block. You can omit it in the last example because Parse effectively slaps one on at the end anyway.</p>
<pre><code>&gt;&gt; parse input-string ["fox"]
== true
</code></pre>
<p>While you can do this for simple examples, remember you'll likely need to add it in</p>
<p>explicitly for more complex rules.</p>
<p>Ok, back to the example again. In an ordinary Rebol session the above example is similar to the following:</p>
<pre><code>&gt;&gt; input-string: find/match input-string "fox"
== ""
&gt;&gt; tail? input-string
== true
</code></pre>
<p>Note that the ordinary Rebol code examples through this article are provided to help learn Parse. There are enough important differences between the Parse examples and the ordinary code examples that you cannot alway treat them as exactly equivalent.</p>
<h2>Failures / challenges</h2>
<p>For contrast let's look at an unsuccessful match:</p>
<pre><code>&gt;&gt; input-string: "dog"
== "dog"
&gt;&gt; parse input-string ["fox"]
== false
</code></pre>
<p>The meaning of this is pretty obvious. Hang on though, what actually happens when Parse encounters a failure with one of the rules? Well it backtracks the input to the point it was at when the rule started. So in Rebol code what happens is actually more like this:</p>
<pre><code>input-string: "dog"
If position: Find/match input-string "fox" [input-string: position]
Tail? input-string
</code></pre>
<p>Keep this little idea in the back of your mind, it becomes more meaningful with more complex rules.</p>
<h2>Optional matching and Compound Rules</h2>
<p>What if we want to check for a number of common pet alternatives?</p>
<p>Let's accept a "dog" or a "cat" or indeed a "bird":</p>
<pre><code>&gt;&gt; input-string: "dog"
== "dog"
&gt;&gt; parse input-string ["dog" | "cat" | "bird"]
== true
</code></pre>
<p>In ordinary Rebol this is like coding:</p>
<pre><code>input-string: any [
    find/match input-string "dog"
    find/match input-string "cat"
    find/match input-string "bird"
]
tail? input-string
</code></pre>
<p>Now, Rebol can be pretty concise and the ANY function definitely helps in writing concise code, but you can see already that the Parse dialect is looking to be better suited to matching than ordinary scripting.</p>
<p>Reflecting on this a bit. We have here a more interesting rule, a compound rule. Our compound rule is composed of three subrules. Each of the three subrules here are very basic but subrules are allowed to be compound rules themselves. The basic rules perform the lowest level matching of the input, the compound rules check the overall structure/grammar of your data.</p>
<p>Back to options. What about something that may or may not exist at all? Using OPT we can indicate that a bird could be big or just leave it out:</p>
<pre><code>&gt;&gt;  input-string: "bigbird"
== "bigbird"
&gt;&gt;  parse input-string [opt "big" "bird"]
== true
&gt;&gt; input-string: "bird"
== "bird"
&gt;&gt; parse input-string [opt "big" "bird"]
== true
</code></pre>
<p>There are more Parse options such as NOT which give you greater flexibility in specifying your rules. We'll cover this later.</p>
<h2>Spaces and Split</h2>
<p>Parse treats spaces like any other character. Note that Rebol 3 acts differently here to Rebol 2 as whitespace is now parsed by default without needing the /ALL refinement</p>
<pre><code>&gt;&gt;  input-string: "black dog"
== "black dog"
&gt;&gt;  parse input-string ["black" " " "dog"]
== true
</code></pre>
<p>There are constants defined for common characters such as SPACE, NEWLINE and TAB which can be used instead.</p>
<pre><code>&gt;&gt;  parse input-string ["black" space "dog"]
== true
</code></pre>
<p>To make things easier we can use the SPLIT function to pre-process the input string. SPLIT breaks up the string based on a given delimeter or other rules.</p>
<pre><code>&gt;&gt; parse split "brown dog" " " ["brown" "dog"]
== true
</code></pre>
<p>If we look at the output of split we see the following.</p>
<pre><code>&gt;&gt; split "brown dog" " "
== [ "brown" "dog" ]
</code></pre>
<p>In this case split is returning a block of strings simplifying our work with Parse.</p>
<h1>Blocks, repetition and more</h1>
<p>Using Parse for strings is good, but using parse on native Rebol datatypes really shows its power.</p>
<p>Rebol has a rich set of datatypes which simplify parsing data, and code.</p>
<p>This mode is used when the value to be parsed is actually a block not a string. You use this mode when you have already loaded data into Rebol values. You write Parse instructions in a rule block using the parse dialect in a similar way to that described for parsing strings except when parsing blocks the semantics are different and you have a couple more keywords to use.</p>
<p>This is the mode of Parse that deserves the attention of anyone using Rebol. The reason is that you are free to store your data in a form understandable by yourself and others and yet is still computer readable.</p>
<h2>First steps parsing blocks</h2>
<p>As we move from strings to blocks we can start to use some of the Rebol datatypes to make our lives much easier.</p>
<pre><code>&gt;&gt; parse [1234.16] [number!]
== true
</code></pre>
<p>Processing dates and times are a good example. You can see how the datatypes support a wide range of input formats. It is worth noting for Americans that Rebol always assumes day/month/year order.</p>
<pre><code>&gt;&gt; parse [12/Dec/2012 2:30pm ] [date! time!]
== true
</code></pre>
<p>There are many more datatypes although that does not stop you from using strings for datatypes which do not map to Rebol types.</p>
<pre><code>&gt;&gt; parse [&lt;div&gt; "Hello" http://rebol.com $1.00 &lt;/div&gt; bob@test.com ] [ tag! "Hello" url! money! tag! email!]
== true
</code></pre>
<h2>Repetition - known range of occurrences</h2>
<p>Time for some more compound rules.</p>
<p>Here's how to check for exactly two dogs.</p>
<pre><code>&gt;&gt; parse "dogdog" [2 "dog"]
== true
</code></pre>
<p>I can specify between 1 and 4 Zs (inclusive) too:</p>
<pre><code>&gt;&gt;  parse "Zzzz" [1 4 "z"]
== true
</code></pre>
<p>Note that by default Parse is not case sensitive unless you want it to be by using the /CASE refinement:</p>
<pre><code>&gt;&gt; parse/case "ZZ" [2 "Z"]
== true
</code></pre>
<p>This is also very powerful for parsing blocks:</p>
<pre><code>&gt;&gt; parse [ http://rebolsource.net http://rebol.org http://rebol.com ] [ 3 url! ]
== true
</code></pre>
<h2>Repetition again <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"> - unknown number of occurrences</h2>
<p>What if we grab a net and go prawning? We may not know how many prawns are caught by the net when we catch them:</p>
<pre><code>&gt;&gt; loop random 100 [append input-string: "" "prawn"]
== "prawnprawnprawnprawn"
&gt;&gt; parse input-string [some "prawn"]
== true
</code></pre>
<p>Excellent, we have some prawns but we don't know how many.</p>
<p>The SOME keyword means "match one or more of the following". Again it is a compound rule because I could have as easily done this if it was "raining cats and dogs":</p>
<pre><code>&gt;&gt; input-string: "dogdogcatdogcat"
== "dogdogcatdogcat"
&gt;&gt; parse input-string [some [ "dog" | "cat"] ]
== true
</code></pre>
<p>If it fines up:</p>
<pre><code>&gt;&gt; input-string: {}
== ""
&gt;&gt; parse input-string [some [ "dog" | "cat"]  ]
== false
</code></pre>
<p>It returns false because SOME requires at least one instance to be matched. If however, we don't actually care whether we get some or not we can use ANY:</p>
<pre><code>&gt;&gt; input-string: {}
== ""
&gt;&gt; parse input-string [any [ "dog" | "cat" ] ]
== true
&gt;&gt; input-string: "dog"
== "dog"
&gt;&gt; parse input-string [any [ "dog" | "cat"] ]
== true
</code></pre>
<p>Here is another example of one of those Rebol words with a new meaning in the context of Parse. In ordinary Rebol ANY is a function that return the first non-false or non-none value in the block it is given. In Parse, by contrast, ANY is a keyword that introduces a compound rule that means, "match zero or more of the following".</p>
<p>Repetition works equally well for blocks:</p>
<pre><code>&gt;&gt; parse [Fibonacci 1 1 2 3 5 8 13] [some [number! | word!] ]
== true
</code></pre>
<h2>Moving right along...</h2>
<p>Sometimes we really couldn't care less what lies between things of interest.</p>
<p>This example does not "skip c" it reads "match a, skip a character, match c, tail?".</p>
<pre><code>&gt;&gt; parse {abc} ["a" skip "c" end]
== true
</code></pre>
<p>You want to skip 5 characters? Use repetition:</p>
<pre><code>&gt;&gt; parse {1234567890} ["123" 5 skip "90" end]
== true
</code></pre>
<p>Sometimes we don't know how much is in between but we do know what is the next interesting bit:</p>
<pre><code>&gt;&gt; input-string: {1234 fox}
== "1234 fox"
&gt;&gt; parse input-string [thru "fox" end]
== true
</code></pre>
<p>This is like the Rebol code of:</p>
<pre><code>&gt;&gt; input-string: find/tail input-string "fox"
== ""
&gt;&gt; tail? input-string
== true
</code></pre>
<p>We can stop where fox starts using TO:</p>
<pre><code>&gt;&gt;  input-string: "1234 fox"
== "1234 fox"
&gt;&gt;  parse input-string [to "fox" "fox" end]
== true
</code></pre>
<p>And the Rebol code that performs similarly:</p>
<pre><code>input-string: {1234 fox}
input-string: find input-string "fox"
input-string: find/match input-string "fox"
tail? input-string
</code></pre>
<p>We can skip to the end as well:</p>
<pre><code>&gt;&gt;  parse {123456} ["123" to end end]
== true
</code></pre>
<p>This says "match 123, move to the tail, test tail". Pretty obvious we would get a true result if you think of it in these terms.</p>
<p>While we're here how about a warning. The rule [to end] moves to the tail and reports</p>
<p>success every time.</p>
<h2>All these characters</h2>
<p>Charset. Stands for character set. It is a bitset which makes it fast for pattern matching operations.</p>
<p>Let's say you only want to check that your input contains the digits 0 to 9.</p>
<pre><code>&gt;&gt; digit: charset [#"0" - #"9"]
</code></pre>
<p>Now parse can use this directly as a pattern matching instruction. It will match one character (byte) only of those in the set 0 - 9.</p>
<pre><code>&gt;&gt; parse {1} [digit]
== true
</code></pre>
<p>Naturally enough you can use these in compound rules too:</p>
<p>An Australian postcode consists of 4 numeric digits so:</p>
<pre><code>&gt;&gt; parse {2069} [4 digit]
== true
</code></pre>
<p>Charsets (bitsets) are sets and you can apply the set operations union, intersection, exclude, etc</p>
<p>on them:</p>
<pre><code>letter: charset [#"a" - #"z" #"A" - #"Z"]
digit: charset [#"0" - #"9"]
letter-or-digit: union letter digit
valid-name: [letter any letter-or-digit]
&gt;&gt;  parse {1abc} valid-name
== false
&gt;&gt;  parse {rebol} valid-name
== true
&gt;&gt;  parse {xyz1234} valid-name
== true
</code></pre>
<p>Maybe you want everything but digits:</p>
<pre><code>&gt;&gt; parse {A} [not digit skip]
== true
</code></pre>
<p>Notice how we needed to SKIP forward as NOT simply inverses the following rule and does not advance the input.</p>
<p>This is different from the Rebol 2 approach of creating a COMPLEMENT of a charset. This may work in some situations, but will not always give you the desired result due to the use of UNICODE in Rebol 3.</p>
<h2>But I want some information from it!</h2>
<p>Up to this point I've concentrated on the various matching functionality of Parse. Of course though you want to extract information from your data. The keyword of note for this purpose is COPY. Also of use is the ability to execute Rebol code within the Parse rules (actions) and thereby set and maintain Rebol variables (eg. Counters) using that code.</p>
<p>Ok COPY.</p>
<p>Copy is really really simple really. It is a compound rule that takes two arguments a variable and a subrule. Whatever input the subrule matches gets copied into the variable. If the subrule doesn't match anything (fails) COPY returns the failure but leaves the variable unchanged.</p>
<p>Here the subrule is to match an "A" which obviously fails.</p>
<pre><code>&gt;&gt; parse {123} [copy some-text "A"]
== false
&gt;&gt; some-text
** Script error: some-text has no value
</code></pre>
<p>Here the subrule is a simple skip:</p>
<pre><code>&gt;&gt; parse {123} [copy some-text skip to end]
== true
&gt;&gt; some-text
== "1"
</code></pre>
<p>And here the subrule is to match nothing NONE which is always successful so copy copies that which was matched...an empty string:</p>
<pre><code>&gt;&gt; parse "123" [copy some-text none]
== false
&gt;&gt; some-text
== ""
</code></pre>
<p>Another way of getting data is by using SET:</p>
<pre><code>&gt;&gt; parse [ $100 ] [ set wallet money! ]
== true
&gt;&gt; wallet
== $100
</code></pre>
<h2>Bring on the code (actions)</h2>
<p>Ordinary Rebol code can be used inside the parse dialect via the use of "(" and ")" i.e. a Paren! series:</p>
<pre><code>&gt;&gt; parse {} [(print "some code just executed") end]
some code just executed
== true
</code></pre>
<p>Obviously this is very handy. Even nicer is that it runs according to its placement in the rule. Note though that even if the rule ultimately fails your code may have already run:</p>
<pre><code>&gt;&gt; parse {123} [
     "1" (print "found 1!")
     "2" (print "found 2!")
     "A" (print "found an A!")
    end
]
found 1!
found 2!
== false
</code></pre>
<p>So the upshot is you can maintain counters and take actions based on your Parse rules.</p>
<p>During development it can be useful to put print statements in these allowing you to see what is happening.</p>

<h1>Advanced section</h1>
<h2>Repeated Repetition</h2>
<p>Now that I've introduced repetition and compound rules, what happens if I create a compound rule made up of nested repetition rules? Hmm, tricky.</p>
<p>This next example put Parse into a spin - an infinite loop. The escape key will not work, but you can break out with Ctrl+c:</p>
<pre><code>&gt;&gt; input-string: {}
== {}
&gt;&gt; parse input-string [while [any "dog"] ]
</code></pre>

<p>To understand why this infinite loop happens you need to know when the ANY rule returns success and when it completes.</p>
<p>Here's the major answer: WHILE ALWAYS returns success.</p>
<p>WHILE will keep calling its subrule while that subrule returns success regardless of if the input position advances. WHILE gives up on receipt of bad news (failure) but it itself always returns success. Now if WHILE always receives a success because it's subrule in fact is another WHILE or ANY... Well I think that explains it.</p>
<p>Remember OPT. It always returns success just like WHILE. So putting an OPT inside an WHILE is bound to lead to trouble as well.</p>
<p>The point then is that your repetition compound rules must be carefully written because of the possibility of creating these infinite loops. It is not a bug in Rebol, it is consequence of having a flexible Parse dialect.</p>
<p>Sometimes these infinite loops start only after traversing lots of other complex rules and therefore can become hard to catch. I create these loops less often now since I started considering how I want Parse's input position to move. When writing your rules consider how the input is consumed by the rules.</p>
<p>That's part of the reason why I've been demonstrating the Rebol code similar to the various Parse examples.</p>
<p>Not all combinations of repetition rules create infinite loops:</p>
<pre><code>&gt;&gt;  input-string: {}
== ""
&gt;&gt;  parse input-string [while [some "dog"] ]
== true
</code></pre>
<p>This last example is ok because the SOME does not always return success - it must consume some input. If SOME does not have at least one success it</p>
<p>returns a failure result. So you can see that at some point, given that we can assume that the input is</p>
<p>finite, the overall rule must terminate.</p>
<p>Quoting Ladislav, "The dangerous rules are rules, that don't consume any input, yet they return success."</p>
<p>There is another way to escape when you don't want your rule to progress further - the BREAK keyword. BREAK terminates the rule when it is encountered.</p>
<p>This could be used to improve performance by stopping evaluation of unnecessary rules.</p>
<pre><code>&gt;&gt; parse [1 2 end 3 4 5 7 8 9] [some [integer! | 'end break]]
== false
</code></pre>
<p>This rule will exist as soon as it reaches the end keyword improving the performance.</p>
<h2>Debugging parse rules</h2>
<p>The ?? command is invaluable in debugging Parse rules.</p>
<pre><code>&gt;&gt; parse "dog" [ ?? "d" ?? [ "i" | "o" ] ?? "g" ?? ]
"d": "dog"
["i" | "o"]: "og"
"g": "g"
end!: ""
== true
</code></pre>
<p>It displays the next rule and the current position in the series being parsed.</p>
<h2>The current index and manipulating it</h2>
<p>Parse maintains a reference to the input. The reference is a series and so has a current index.</p>
<p>Some special Parse dialect syntax allows you to get and set this reference. You use a set-word and get-word syntax respectively.</p>
<p>In this example I set the word "mark" to the input series at the current index that Parse has, don't worry about the false - it is just saying we didn't get all the way through the input:</p>
<pre><code>&gt;&gt;  parse {123456} ["123" mark:]
== false
&gt;&gt; mark
== "456"
</code></pre>
<p>I can manipulate the current index that Parse uses too:</p>
<pre><code>&gt;&gt;  parse {1234567} ["123" mark: (mark: next next mark) :mark "67"]
== true
</code></pre>
<p>To explain. First "123" is matched, then the word mark is set to the reference.</p>
<p>Then the Rebol code between the parentheses is evaluated. This code manipulates the reference we hold by two characters. I return this modified reference to Parse using the get-word syntax. Parse seeing the get-word syntax knows that it must update it's reference to that given. Finally I match the "67".</p>
<h2>More Block examples ...</h2>

<p>An example that shows what can be achieved is Carl Sassenrath's stock transaction example which you can see below. Now what if "sell 300 shares at $89.08" came in via email?</p>
<p>If you study this example you will see that Carl, in a very small space, has created a small interpreter that parses, validates and performs computations. This is very powerful technology that is easily underestimated because it is so small and simple.</p>
<pre><code>rule: [
    set action ['buy | 'sell]
    set number integer!
    'shares 'at
    set price money!
    (either action = 'sell [
            print ["income" price * number]
            total: total + (price * number)
        ] [
            print ["cost" price * number]
            total: total - (price * number)
        ]
    )
]
total: 0
parse [sell 100 shares at $123.45] rule
print ["total:" total]
total: 0
parse [
    sell 300 shares at $89.08
    buy 100 shares at $120.45
    sell 400 shares at $270.89
] [some rule]
print ["total:" total]
</code></pre>
<p>Another powerful example of this is the VID dialect of Rebol/View 2. VID describes in a<br>
effective but simple way what should appear on screen. VID is actually a block using normal<br>
Rebol values such as words and strings. The LAYOUT function of Rebol/View 2 takes a VID<br>
block as an argument to construct the visual objects. Layout uses Parse to process the<br>
VID specification.</p>
<h1>Special situations</h1>
<h2>When you do NOT want to match a pattern</h2>

<p>NOT does not consume input, so you can use it one ore more times before matching something else:</p>
<pre><code>&gt;&gt; parse "bird" [not "big" "bird"]
== true
</code></pre>
<p>One situation where you might do this is when you have a sub rule that might "consume" something needed by an enclosing rule.</p>
<p>For my example, I'll Parse a block rather than text but the concept still applies.</p>
<p>I want to Parse the following block, and print out every word, but if I encounter a bar ("|") I'll print out the text "**********":</p>
<pre><code>my-block: [ the quick brown fox | jumped | over the lazy]
</code></pre>
<p>This next bit of code will not work. If you try it you will see that no "*" is printed, instead you will see the "|":</p>
<pre><code>single-word: [set item word! (print mold item)]
phrase: [some single-word]
parse my-block [ phrase some ['| (print "**********") phrase] ]
</code></pre>
<p>The thing to note is that the bar "|" is a word too. Therefore the bar is "consumed" by the rule called SINGLE-WORD.</p>
<p>So one way to solve this is to give SINGLE-WORD some indigestion (make it fail) when it encounters a bar.</p>
<p>You can force a rule to fail using the FAIL keyword but here we use AND and NOT to make the rule fail under a specific condition.</p>
<p>To make it clear what is happening here, I wrap SINGLE-WORD with a rule I call WORD-EXCEPT-BAR. The</p>
<p>purpose of this new rule is to fail if it finds the "|" word otherwise it goes ahead and runs SINGLE-WORD.</p>
<p>I've added comments to clarify how WORD-EXCEPT-BAR works:</p>
<pre><code>word-except-bar: [
    and not '| ; Without advancing the input position, is this not a bar?
    single-word ; Match single-word
]
</code></pre>
<p>The point to note here is that the rule AND NOT '| is a "guard" - it guards the next rule from consuming input under a specific condition.</p>
<p>I also need to modify PHRASE to call WORD-EXCEPT-BAR.</p>
<pre><code>phrase: [some word-except-bar]
</code></pre>
<p>Another way to describe the PHRASE rule, as it is now, is "a rule that matches a series of words which does not contain the word |."</p>
<p>To finish off I'll create a function to call parse with the correct rule and</p>
<p>wrap the whole lot in an object just to be tidy:</p>
<pre><code>word-parsing-object: context [
    single-word: [set item word! (print mold item)]
    word-except-bar: [and not '| single-word]
    phrase: [some word-except-bar]
    set 'parse-words func[ a-block [block!] ] [
        parse a-block [phrase some ['| (print "**********") phrase] ]
    ]
]
</code></pre>
<p>Here is a test run:</p>
<pre><code>&gt;&gt; parse-words [the quick brown fox | jumped | over the lazy]
the
quick
brown
fox
**********
jumped
**********
over
the
lazy
== true
</code></pre>
<p>In summary in this section I have demonstrated how one can match a specific pattern even when a more general pattern (that includes the specific pattern) gets to see the input first.</p>
<h2>Why didn't you just write...</h2>
<pre><code>parse-words: func [a-block [block!]] [
    parse a-block [
        some [
            '| (print "**********") |
            set item word! (print mold item)
        ]
    ]
]
</code></pre>
<p>That is the better way to solve the problem, but the point is to demonstrate the concept of preventing a subrule from consuming certain input and how to use AND as a guard. There are situations when you need these ideas.</p>
<h2>The BREAK keyword</h2>

<p>From RT's changes document:</p>
<pre><code>When the BREAK word is encountered within a rule block, the block is
immediately terminated regardless of the current input pointer.
Expressions that follow the BREAK within the same rule block will not
be evaluated.
</code></pre>
<p>BREAK is usually used with repetition. In this example the SOME rule is exited early:</p>
<pre><code>&gt;&gt; parse "X" [some [ (print "*Break*") break] "X"]
*Break*
== true
</code></pre>
<p>Here again the SOME rule is exited early just like the previous example. In this case the rule that SOME is processing is referred to by a word:</p>
<pre><code>&gt;&gt; rule-to-break: [(print "*Break*") break]
== [(print "*Break*") break]
&gt;&gt; parse "X" [some rule-to-break "X"]
*Break*
== true
</code></pre>
<h1>Related toolset</h1>
<p>I have written "Parse Analysis Toolset" to help learn and analyse the way Parse works. The Explain-parse function of the toolset should help with learning Parse. The script has related documentation. You can find the script and a linkg to the documentation at:</p>
<p><a href="http://www.rebol.org/cgi-bin/cgiwrap/rebol/view-script.r?script=parse-analysis.r">parse-analysis.r (at REBOL.org Script Library)</a></p>
<p>One more program I've made can return a parse tree of your input:</p>
<p><a href="http://www.rebol.org/cgi-bin/cgiwrap/rebol/documentation.r?script=load-parse-tree.r">load-parse-tree.r (at REBOL.org Script Library)</a></p>
<h1>Comments</h1>
<p>Parse is a key component Rebol. Rebol is promoted as a messaging<br>
language. Messages can come in many formats (syntaxes). Parse allows<br>
you to define the syntax of a message so that you can interpret the message and transform<br>
it to something else or act on it directly. That may sound complex, but it isn't really.</p>
<p>What are messages? Lots of things can be considered as messages. Basically if you can<br>
put it into a file and the format of the file has some rule to it, then I think you have<br>
a message. You don't have to put it in a file though to use Parse. Rebol's networking<br>
functions use Parse to interpret many of the internet protocols that Rebol provides<br>
access to.</p>
<p>With Rebol you can define a mini-language for a specific purpose - a dialect. Outside Rebol this would be called a domain-specific language or DSL.</p>
<p>Parse helps you to validate and process such dialects. You might want to design a dialect for creating web pages on your internet site. Or perhaps for controlling a special device you have attached to your computer.</p>
<h1>Acknowledgement</h1>
<p>Thank you to John Kenyon for his initiative, edits and effort as we updated this article from the original.</p>
          <p><a href="https://forum.rebol.info/t/old-parse-tutorial/1771/1">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/old-parse-tutorial/1771/1</link>
        <pubDate>Sun, 12 Dec 2021 00:08:48 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1771-1</guid>
        <source url="https://forum.rebol.info/t/old-parse-tutorial/1771.rss">Old Parse Tutorial</source>
      </item>
  </channel>
</rss>
