<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>The Case for Literal (or soft-quoted?) branches in CASE</title>
    <link>https://forum.rebol.info/t/the-case-for-literal-or-soft-quoted-branches-in-case/590</link>
    <description>Rebol2, R3-Alpha, and Red are all quite a bit of a smattering of behaviors for CASE.  Ren-C has progressively racheted up the control and semantics, which is particularly important given how free-form case statements are (enforcing pairs of conditions and branches).

But one loose aspect that is still in CASE is the ability to run a block branch evaluatively:

    x: true
    code: [print &quot;This runs because X is true&quot;]
    case [
        false [print &quot;This doesn&#39;t run&quot;]
        x code
    ]

One has slightly less confidence that code is a branch than if it said `x [do code]`.  But really, only slightly less...given that X could be a FUNCTION! either way.

So it seems to just tie into the freeform nature of Rebol, all things being equal.  If there&#39;s no reason to prohibit it, why prohibit it?

### But there may be a good reason...

There&#39;s a common pattern in case statements where if you reach a certain point in the processing, you want to run some code non-conditionally.  With CASE/ALL, you can do this with TRUE in a branch slot, which it will run the branch as it passes by:

    case/all [
        condition1 [...]
        condition2 [...]
        true [
            ;-- some code that runs at this point, always
            ;-- (assuming there wasn&#39;t a throw/return/fail...)
        ]
        condition3 [...]
        condition4 [...]
    ]

It&#39;s a clunky way to express it... kind of like having a TRUE condition as your last branch in an ordinary CASE is a clunky way of saying default.  But, it works, and people used it.

But what if you have just a normal case?  How could you run some processing after some number of cases didn&#39;t match, and then resume matching the following conditions?

*Technically* speaking, you can do it...but in a kind of ugly way that splices the code before the next condition in a GROUP!, so the result of that evaluation is thrown away, and then the result of the group is the condition you actually wanted:

    case [
        condition1 [...]
        condition2 [...]
        (
            ;-- some code that runs at this point, if condition1
            ;-- and condition2 didn&#39;t match

            condition3 ;-- now process the condition
        ) [...]
        condition4 [...]
    ]

That&#39;s extremely inelegant.  So much so that people don&#39;t do it...they fiddle some variable, exit the case, check the variable and start a new case.

But with the [rise of ELIDE](https://trello.com/c/snnG8xwW/173-elide-can-invisibly-evaluate-an-expression-almost-anywhere), I thought it could save the day:

    case [
        condition1 [...]
        condition2 [...]
        elide (
            ;-- some code that runs at this point, if condition1
            ;-- and condition2 didn&#39;t match
        )
        condition3 [...]
        condition4 [...]
    ]

Beautiful!  But there&#39;s just one problem.  Since the blocks are in evaluative slots, they force the hand of ELIDE so it runs *when the block after condition2 is processed*.  This happens whether the branch is taken or not.  So you could wind up running the code if condition2 is taken and it never makes it to condition3.  :frowning:

*(If you don&#39;t understand the mechanics of why the left-to-right evaluation forces ELIDE in this way, [read about it here](https://forum.rebol.info/t/issues-with-invisibles-a-truly-disappearing-comment/405/3?u=hostilefork))*

If CASE only accepted literal blocks for branches, the problem would go away.  And you&#39;d be able to use the ELIDE pattern.

Having pushed the various degrees of freedom around and seeing the tradeoffs, it seems to me that having to say **case [true [do code]]** instead of **case [true code]** is a small price to pay.

* CASE structure becomes clearer (though not 100% so, as not all blocks may be assumed to be branches, they could be arguments to a function in the condition)
* Performance goes up...not having to call into the evaluator potentially twice per branch.
* You get the awesome use of ELIDE, and it works in CASE/ALL too (so you don&#39;t need to use the TRUE condition &quot;hack&quot;)

I think it&#39;s a winning proposition.  Any objections?

Note that CHOOSE exists now if you are just picking values:

    x: 20
    result: choose [
        x &lt; 10 &lt;thing&gt;
        x &gt; 10 [literal block]
    ]

That gets you `result = [literal block]`.  I&#39;d argue this should not be evaluative for the same reasons, and if you need the thing you&#39;re choosing to have some evaluation before choosing use COMPOSE.

    text: &quot;thing&quot;
    x: 20
    choose compose [
       x &lt; 10 (to tag! text)
       x &gt; 10 [literal block]
    ]

### We could compromise, with soft quoted slots...

If the slots were soft quoted, then they would evaluate only if a GROUP! or GET-PATH! or GET-WORD!.  That would give some flexibility, without needing to worry about participation &quot;in the stream&quot; of the evaluation beyond that single element.  This might be a good tradeoff, since as mentioned, the &quot;it&#39;s a literal block&quot; doesn&#39;t *actually* guarantee you it&#39;s a branch anyway.

*(Basically, this just means you&#39;d not need to say COMPOSE in the example above... and you couldn&#39;t get literal GROUP!s or GET-WORD!s or GET-PATH!s, you&#39;d have to put them in GROUP!s and quote them.)*

This might even suggest an idea for branching in general for IFs, etc...to soft quote the branch slots, which might be safer overall while permitting most of the expressivity people would need.</description>
    
    <lastBuildDate>Tue, 19 Jun 2018 19:19:42 +0000</lastBuildDate>
    <category>Internals</category>
    <atom:link href="https://forum.rebol.info/t/the-case-for-literal-or-soft-quoted-branches-in-case/590.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>The Case for Literal (or soft-quoted?) branches in CASE</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>With my decision to <a href="https://forum.rebol.info/t/the-fallout-from-the-switch-fallout-feature/312/8">endorse SWITCH fallout</a>, the idea of "CASE fallout" has come up:</p>
<pre><code>&gt;&gt; case [
       1 &gt; 2 [...]
       3 &gt; 4 [...]
       10 + 20
   ]
== 30
</code></pre>
<p>One of the things that makes it more palatable is the change needed to support elide...basically that you will be "seeing" the branches in the form of blocks (or ACTION! literals, if you composed them in, but you probably knew what you were doing if you did that).</p>
<p>But then, there was this question:</p>
<aside class="quote no-group quote-modified" data-post="1" data-topic="590">
<div class="title">
<div class="quote-controls"></div>
<img alt width="20" height="20" src="//forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>We could compromise, with soft quoted slotsâ€¦</p>
</blockquote>
</aside>
<p>This lets you say:</p>
<pre><code> block1: [...]
 case [
     1 &gt; 2 (block1)
     3 &gt; 4 (func [x] [...])
     10 + 20
 ]
</code></pre>
<p>You could do that with a COMPOSE (or a COMPOSEII).  Which would be a slight performance cost, but arguably more clear...and we're trying not to stress out too much over performance at that level.</p>
<p>But the point is that it makes one a little less comfortable with the CASE fallout, because the blocks aren't as obvious in the structure.  Of course, blocks can be arguments to the expressions in a case, so it's not a slam dunk anyway.</p>
<p>An argument against soft quoting would be based on what you would want CHOOSE to do with GET-PATH!, SET-PATH!, and group:</p>
<pre><code>choose [
    1 &gt; 2 [literal block]
    3 &gt; 4 &lt;tag&gt;
    5 &lt; 6 (10 + 20)
]
</code></pre>
<p>Should that be <code>(10 + 20)</code> the literal group, or a way of choosing 30?  If you want it to be the literal group, that seems to strongly suggest the branches in a CASE should not be soft quoted.  And I kind of think I like the literal GROUP! outcome for CHOOSE, it feels more "solid" and predictable to really let you pick <em>anything</em> out of that slot.</p>
<p>I think I want to say that you need to use literal blocks in CASE, and if you have a non-literal one that should be done with COMPOSE.  The performance argument doesn't hold up under scrutiny, because if you just use a BLOCK! with CASE that is going to be nearly as fast (within the noise, compared to the COMPOSE which would actually cost slightly more).</p>
          <p><a href="https://forum.rebol.info/t/the-case-for-literal-or-soft-quoted-branches-in-case/590/2">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/the-case-for-literal-or-soft-quoted-branches-in-case/590/2</link>
        <pubDate>Tue, 19 Jun 2018 19:19:42 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-590-2</guid>
        <source url="https://forum.rebol.info/t/the-case-for-literal-or-soft-quoted-branches-in-case/590.rss">The Case for Literal (or soft-quoted?) branches in CASE</source>
      </item>
      <item>
        <title>The Case for Literal (or soft-quoted?) branches in CASE</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>Rebol2, R3-Alpha, and Red are all quite a bit of a smattering of behaviors for CASE.  Ren-C has progressively racheted up the control and semantics, which is particularly important given how free-form case statements are (enforcing pairs of conditions and branches).</p>
<p>But one loose aspect that is still in CASE is the ability to run a block branch evaluatively:</p>
<pre><code>x: true
code: [print "This runs because X is true"]
case [
    false [print "This doesn't run"]
    x code
]
</code></pre>
<p>One has slightly less confidence that code is a branch than if it said <code>x [do code]</code>.  But really, only slightly less...given that X could be a FUNCTION! either way.</p>
<p>So it seems to just tie into the freeform nature of Rebol, all things being equal.  If there's no reason to prohibit it, why prohibit it?</p>
<h3>But there may be a good reason...</h3>
<p>There's a common pattern in case statements where if you reach a certain point in the processing, you want to run some code non-conditionally.  With CASE/ALL, you can do this with TRUE in a branch slot, which it will run the branch as it passes by:</p>
<pre><code>case/all [
    condition1 [...]
    condition2 [...]
    true [
        ;-- some code that runs at this point, always
        ;-- (assuming there wasn't a throw/return/fail...)
    ]
    condition3 [...]
    condition4 [...]
]
</code></pre>
<p>It's a clunky way to express it... kind of like having a TRUE condition as your last branch in an ordinary CASE is a clunky way of saying default.  But, it works, and people used it.</p>
<p>But what if you have just a normal case?  How could you run some processing after some number of cases didn't match, and then resume matching the following conditions?</p>
<p><em>Technically</em> speaking, you can do it...but in a kind of ugly way that splices the code before the next condition in a GROUP!, so the result of that evaluation is thrown away, and then the result of the group is the condition you actually wanted:</p>
<pre><code>case [
    condition1 [...]
    condition2 [...]
    (
        ;-- some code that runs at this point, if condition1
        ;-- and condition2 didn't match

        condition3 ;-- now process the condition
    ) [...]
    condition4 [...]
]
</code></pre>
<p>That's extremely inelegant.  So much so that people don't do it...they fiddle some variable, exit the case, check the variable and start a new case.</p>
<p>But with the <a href="https://trello.com/c/snnG8xwW/173-elide-can-invisibly-evaluate-an-expression-almost-anywhere" rel="nofollow noopener">rise of ELIDE</a>, I thought it could save the day:</p>
<pre><code>case [
    condition1 [...]
    condition2 [...]
    elide (
        ;-- some code that runs at this point, if condition1
        ;-- and condition2 didn't match
    )
    condition3 [...]
    condition4 [...]
]
</code></pre>
<p>Beautiful!  But there's just one problem.  Since the blocks are in evaluative slots, they force the hand of ELIDE so it runs <em>when the block after condition2 is processed</em>.  This happens whether the branch is taken or not.  So you could wind up running the code if condition2 is taken and it never makes it to condition3.  <img src="//forum.rebol.info/images/emoji/twitter/frowning.png?v=7" title=":frowning:" class="emoji" alt=":frowning:"></p>
<p><em>(If you don't understand the mechanics of why the left-to-right evaluation forces ELIDE in this way, <a href="https://forum.rebol.info/t/issues-with-invisibles-a-truly-disappearing-comment/405/3?u=hostilefork">read about it here</a>)</em></p>
<p>If CASE only accepted literal blocks for branches, the problem would go away.  And you'd be able to use the ELIDE pattern.</p>
<p>Having pushed the various degrees of freedom around and seeing the tradeoffs, it seems to me that having to say <strong>case [true [do code]]</strong> instead of <strong>case [true code]</strong> is a small price to pay.</p>
<ul>
<li>CASE structure becomes clearer (though not 100% so, as not all blocks may be assumed to be branches, they could be arguments to a function in the condition)</li>
<li>Performance goes up...not having to call into the evaluator potentially twice per branch.</li>
<li>You get the awesome use of ELIDE, and it works in CASE/ALL too (so you don't need to use the TRUE condition "hack")</li>
</ul>
<p>I think it's a winning proposition.  Any objections?</p>
<p>Note that CHOOSE exists now if you are just picking values:</p>
<pre><code>x: 20
result: choose [
    x &lt; 10 &lt;thing&gt;
    x &gt; 10 [literal block]
]
</code></pre>
<p>That gets you <code>result = [literal block]</code>.  I'd argue this should not be evaluative for the same reasons, and if you need the thing you're choosing to have some evaluation before choosing use COMPOSE.</p>
<pre><code>text: "thing"
x: 20
choose compose [
   x &lt; 10 (to tag! text)
   x &gt; 10 [literal block]
]
</code></pre>
<h3>We could compromise, with soft quoted slots...</h3>
<p>If the slots were soft quoted, then they would evaluate only if a GROUP! or GET-PATH! or GET-WORD!.  That would give some flexibility, without needing to worry about participation "in the stream" of the evaluation beyond that single element.  This might be a good tradeoff, since as mentioned, the "it's a literal block" doesn't <em>actually</em> guarantee you it's a branch anyway.</p>
<p><em>(Basically, this just means you'd not need to say COMPOSE in the example above... and you couldn't get literal GROUP!s or GET-WORD!s or GET-PATH!s, you'd have to put them in GROUP!s and quote them.)</em></p>
<p>This might even suggest an idea for branching in general for IFs, etc...to soft quote the branch slots, which might be safer overall while permitting most of the expressivity people would need.</p>
          <p><a href="https://forum.rebol.info/t/the-case-for-literal-or-soft-quoted-branches-in-case/590/1">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/the-case-for-literal-or-soft-quoted-branches-in-case/590/1</link>
        <pubDate>Fri, 13 Apr 2018 03:33:16 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-590-1</guid>
        <source url="https://forum.rebol.info/t/the-case-for-literal-or-soft-quoted-branches-in-case/590.rss">The Case for Literal (or soft-quoted?) branches in CASE</source>
      </item>
  </channel>
</rss>
