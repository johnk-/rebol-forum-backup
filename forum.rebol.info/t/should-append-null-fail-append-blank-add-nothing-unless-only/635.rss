<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Should append null fail, append BLANK! add nothing unless /ONLY?</title>
    <link>https://forum.rebol.info/t/should-append-null-fail-append-blank-add-nothing-unless-only/635</link>
    <description>The Rebol design concept that used to be discussed under the label &quot;none propagation&quot; has become a system of what I think are pretty good rules:

* **Blank input gives Null output...*for non-mutating operations***
* **Mutating operations do not accept BLANK! targets as input**
* **Null input gives an error for operations *that aren&#39;t specifically about null handling***
* **TRY can be used to &quot;defuse&quot; nulls into blanks**

The reason this has merit is because it gives you a &quot;hot potato&quot; in the form of NULL, without going so far as to error in the moment.  You get pinpointed error locality where a problem *might* be, and have an easy mitigation--if you want it--to use TRY to turn the null into a BLANK! and pass through all other results.  And there are a host of null-driven operations to let you pick up the slack, e.g. **first block else [code]**.

*(I&#39;ve suggested that if you ever actually wind up having to put a null state in a variable, test for null later with NULL? and act on it, that you probably could have done it better...reacting to the null without ever using it as a stored state.  But it&#39;s your choice, I guess.)*

So this is being applied across the board.  **first _** is null...just like **first []** is.

### Consequences for APPEND/INSERT/CHANGE...

These rules affect a current feature of things like APPEND that I doubt many people have tried:

     &gt;&gt; append copy [a b c] null
     == [a b c]

    &gt;&gt; append copy [a b c] if false [&#39;d]
    == [a b c]

When it was introduced, I thought it made sense.  Since NULL is not a value you can put in a block, you don&#39;t get confused about what that means.  Then since BLANK! is a legitimate value that can appear in a block, you could append it:

     &gt;&gt; append copy [a b c] _
     == [a b c _]

But quietly accepting NULL loses the hot-potato benefit.  If you say **append foo third block** and there is no third element in the block, *doesn&#39;t that seem like a good time to complain*?  Rebol code can pretty quickly get hard to read and debug, and wouldn&#39;t it be nice if the person who wrote that line could articulate that there may not be a third thing in the block by saying **append foo try third block**?

This suggests making the default behavior of BLANK! to be to add nothing, and you need an /ONLY to override that.  It may sound like a missed opportunity for null to exploit its out-of-band status.  But realistically speaking, I don&#39;t think purposefully adding blanks is all that common--certainly a lot less common than adding a block as-is, and that requires /ONLY!

### No one probably cared (...yet...)

Like I say--most people probably were unaware of this, and so I don&#39;t know there&#39;s a lot of **append block if condition [...]** out there today.  We might need APPEND/OPT to be null tolerant, though the only reason to use it would be with /ONLY since otherwise you could say **append block try if condition [...]**.</description>
    
    <lastBuildDate>Thu, 03 Jun 2021 16:37:57 +0000</lastBuildDate>
    <category>Internals</category>
    <atom:link href="https://forum.rebol.info/t/should-append-null-fail-append-blank-add-nothing-unless-only/635.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Should append null fail, append BLANK! add nothing unless /ONLY?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>I started this thread talking about the two competing opportunities with NULL and APPEND.</p>
<ul>
<li>
<p>The opportunity to have an "escape" out of a value bearing slot to say <em>"no, I actually don't want to append a thing"</em>.</p>
<pre><code>&gt;&gt; append copy [&lt;a&gt; &lt;b&gt; &lt;c&gt;] (if 1 = 1 '[&lt;d&gt; &lt;e&gt;])
== [&lt;a&gt; &lt;b&gt; &lt;c&gt; &lt;d&gt; &lt;e&gt;]

&gt;&gt; append copy [&lt;a&gt; &lt;b&gt; &lt;c&gt;] (if 1 = 2 '[&lt;d&gt; &lt;e&gt;])
== [&lt;a&gt; &lt;b&gt; &lt;c&gt;]
</code></pre>
</li>
<li>
<p>The opportunity to catch an error in intent when NULL is an accident.</p>
<pre><code>&gt;&gt; data: [&lt;a&gt; &lt;b&gt; &lt;c&gt;]
&gt;&gt; block: [&lt;d&gt; &lt;e&gt;]

&gt;&gt; append data third block
** Error: APPEND doesn't accept NULL as its value argument

&gt;&gt; append data try third block
== [&lt;a&gt; &lt;b&gt; &lt;c&gt;]
</code></pre>
</li>
</ul>
<p>As evidenced by the back and forth above, I see both sides.</p>
<h2>Null Behavior With The ^ Operator Shifts the Balance</h2>
<p>There is an interesting property <a href="https://forum.rebol.info/t/emergent-behavior-of-x-x-y-x-y/1596">in the new ^ mechanisms</a> that shows a way we could make blanks disappear and still be taking advantage of NULL's unique status.</p>
<p>Here is the property:</p>
<pre><code> &gt;&gt; absent: null

 &gt;&gt; ^absent
 == null

 &gt;&gt; try absent
 == _

 &gt;&gt; append [a b c] _
 == [a b c]

  &gt;&gt; append [a b c] absent
 ** Error: APPEND doesn't accept NULL as its value argument

  &gt;&gt; append [a b c] try absent
  == [a b c]

  &gt;&gt; append [a b c] ^absent
** Error: APPEND doesn't accept NULL as its value argument

  &gt;&gt; append [a b c] try ^absent
  == [a b c]
</code></pre>
<p>Don't see what's special about that yet?  Think about how it would work with BLANK! instead.</p>
<pre><code>  &gt;&gt; present: _

  &gt;&gt; append [a b c] present
  == [a b c]

  &gt;&gt; append [a b c] try present
  == [a b c]

  &gt;&gt; append [a b c] ^present
  == [a b c _]

  &gt;&gt; append [a b c] try ^present
  == [a b c _]
</code></pre>
<p>The magic of TRY here is that you can use the TRY on the <em>outside</em> of the literalizing operator and not wind up putting in blanks that get quoted.</p>
<h2>So...Is This The Answer?</h2>
<p>It's now a strong argument to say that APPEND and friends act with /ONLY semantics on QUOTED!, splice BLOCK!, do nothing on BLANK!, error on NULL.</p>
<pre><code>&gt;&gt; append [a b c] "text"
== [a b c "text"]

&gt;&gt; append [a b c] &lt;tag&gt;
== [a b c &lt;tag&gt;]

&gt;&gt; append [a b c] [d e f]
== [a b c d e f]

&gt;&gt; append [a b c] _
== [a b c]

&gt;&gt; append [a b c] ^ _
== [a b c _]

&gt;&gt; append [a b c] [_]
== [a b c _]

&gt;&gt; append [a b c] null
** Error: APPEND doesn't accept NULL as its value argument
</code></pre>
<p>With quoting in reach as easily as <strong>^var</strong> instead of <strong>var</strong>, or <strong>^ some expression</strong> instead of <strong>some expression</strong>... it spins my view toward where we'd be instead wasting blank if we didn't take advantage of its unique status as being a thing you can put in a block and opt out of an operation with.</p>
<p>Then it will error unless you use QUOTE or ^:</p>
<pre><code>&gt;&gt; append [a b c] 'd
** Error: Use QUOTE or ^ to literalize evaluative types with APPEND

&gt;&gt; append/only [a b c] 'd
== [a b c d]

&gt;&gt; append [a b c] ^ 'd
== [a b c d]

&gt;&gt; append [a b c] ^ ''d
== [a b c d]

&gt;&gt; append [a b c] [d]
== [a b c d]

&gt;&gt; append [a b c] ['d]
== [a b c 'd]

&gt;&gt; var: the 'd
&gt;&gt; append [a b c] ^var
== [a b c 'd]
</code></pre>
<p>One way of looking at this is that evaluative types are the ones that have the most to lose by conflating their quoted forms with their non-quoted forms on accident.</p>
<p>Another way of looking at it is that inert types exist in other languages as being able to be added to arrays, so making that simple gives parity on the common feature...while the domain of code building costs you an <strong>^</strong>.  Moreover, I think changing COMPOSE so that it leverages null and uses (( )) for splicing gives a powerful alternative for building up blocks of code.</p>
<p><strong>It's certainly the best proposal so far.</strong>  My confidence is fairly high it's about as good as this is going to get.</p>
          <p><a href="https://forum.rebol.info/t/should-append-null-fail-append-blank-add-nothing-unless-only/635/9">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/should-append-null-fail-append-blank-add-nothing-unless-only/635/9</link>
        <pubDate>Mon, 10 May 2021 10:37:55 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-635-9</guid>
        <source url="https://forum.rebol.info/t/should-append-null-fail-append-blank-add-nothing-unless-only/635.rss">Should append null fail, append BLANK! add nothing unless /ONLY?</source>
      </item>
      <item>
        <title>Should append null fail, append BLANK! add nothing unless /ONLY?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-post="7" data-topic="635">
<div class="title">
<div class="quote-controls"></div>
<img alt width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>(All of this is really just some experimental tinkering. I'm getting back into the rhythm of dealing with Rebol, so it's good to do something fun...but...what needs to happen is the Travis and other planning. So I'll probably put this down while I let the questions sink in a bit. Again, this was all just solidifying the answer to the topic of this thread, which I feel is settled now.)</p>
</blockquote>
</aside>
<p>I found the branch where I experimented with the zany idea...and I'm deleting it.</p>
<p>This was a product of the death throes of trying to preserve the concept that NULL accesses produce errors.  Doing so was a uniquely Ren-C concept to try and enforce.  Parallel situations in Rebol2, R3-Alpha, and Red would neither raise errors nor have unique states for "no value".  Having a unique state is a strong improvement already...and is part of a pretty clever answer to "none propagation".  So being paranoid about raising errors on simple accesses likely causes about as many problems as it solves.</p>
<p>I explain the decision to <a href="https://forum.rebol.info/t/are-nulls-the-best-representation-for-unused-refinements/1140/9">finally bite the bullet on NULL variable access here</a></p>
          <p><a href="https://forum.rebol.info/t/should-append-null-fail-append-blank-add-nothing-unless-only/635/8">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/should-append-null-fail-append-blank-add-nothing-unless-only/635/8</link>
        <pubDate>Fri, 06 Dec 2019 07:44:49 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-635-8</guid>
        <source url="https://forum.rebol.info/t/should-append-null-fail-append-blank-add-nothing-unless-only/635.rss">Should append null fail, append BLANK! add nothing unless /ONLY?</source>
      </item>
      <item>
        <title>Should append null fail, append BLANK! add nothing unless /ONLY?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>Now having worked with Zany Proposal experimentally for about 24 hours, it clearly shows some coolness...though it has some mind-bending properties. (!)</p>
<p><strong>But whether the idea is viable or not as conceived so far...it just is another way of looking at the answer to the title of this thread as being NO.</strong>  APPEND and COMPOSE should remain purely mechanical.  If they get a null, that means nothing.  If they get a value that can legitimately appear in a block, then they should put <em>that value</em> in the block...and not editorialize, via refinements.</p>
<p>Whether it's via an old-school OPT or a creative new evaluative behavior that can bring about more brevity...it's up to the caller to pass the right value.  Operations like APPEND and COMPOSE should not editorialize via refinements, /ONLY or otherwise.  (And <a href="https://github.com/metaeducation/ren-c/pull/1009" rel="nofollow noopener">if all atomic additions are forced to use /ONLY</a> as being proposed, it wouldn't even be an option to control it that way.)</p>
<hr>
<p>The biggest concern I have about the idea of blanks decaying to null has nothing to do with TRY.  Because if blanks are just reified nulls, then making it easier to reconstitute that null via evaluation <em>seems like a pretty neat feature</em>.  I see several places where that neatness is indeed showing off well.</p>
<p>But my point about Redbol compatibility problems also show up in Ren-C scenarios where you are using BLANK! for a generic placeholder in the fashion that NONE! may have been used before.  For instance, let's say you have:</p>
<pre><code>data: [
    "Foo" 10 &lt;alpha&gt;
    "Bar" 20 _
    "Baz" 30 &lt;beta&gt;
]
</code></pre>
<p>If this is a kind of "CSV-style" tabular data, you might enumerate over it and try to extract the third column, doing some transformation:</p>
<pre><code>map-each/only [x y z] data [
    case [
        z = &lt;alpha&gt; [&lt;gamma&gt;]
        z = &lt;beta&gt; [&lt;delta&gt;]
        default [z]
    ]
]
</code></pre>
<p>The author of this code wanted to get <code>[&lt;gamma&gt; _ &lt;delta&gt;]</code>.  But under the proposed "zany" rule, they'd get <code>[&lt;gamma&gt; $void$ &lt;delta&gt;]</code>.  Because the blank would decay to a null, and conditional branches voidify null results... to reserve null for the "no branch ran" case.</p>
<p><strong>But this may suggest we're really talking about two different datatypes.</strong>  One is a reified null, that itches to reconstitute null whenever it can.  And one is an inert placeholder, in the spirit of classical NONE!</p>
<p>In R3-Alpha, you could use <strong>#</strong> for NONE!, which had a bit more heft to it than the light-looking BLANK!</p>
<pre><code>data: [
    "Foo" 10 &lt;alpha&gt;
    "Bar" 20 #
    "Baz" 30 &lt;beta&gt;
]
</code></pre>
<p>This wasn't a popular choice, but it had some more visibility.</p>
<p>However, maybe with the non-decaying <span class="mention">@word</span>, <span class="mention">@pa</span>/th, @[bl o ck], and @(gr o up... there could be a place for a non-decaying...LIT-NULL!, <strong>@</strong>, which would be evaluatively inert, but also falsey?</p>
<pre><code>data: [
    "Foo" 10 &lt;alpha&gt;
    "Bar" 20 @
    "Baz" 30 &lt;beta&gt;
]
</code></pre>
<p>Doesn't seem like a terrible idea.  But by the arguments given, you probably wouldn't want <a href="https://forum.rebol.info/t/the-holy-grail-of-hello-world-and-print-solved/1197">wacky decaying BLANK! for spacing in your non-implicitly spaced prints</a>.  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=9" title=":frowning:" class="emoji" alt=":frowning:">  You might want to do processing on those blocks with similar mappings, and casual coders could get burned by the same issues that would affect those doing the CSV-style data.</p>
<p>But who knows...maybe it could just be a buyer-beware thing; if you are the kind of person who takes advantage of the feature you have to be careful.</p>
<hr>
<p><em>(All of this is really just some experimental tinkering.  I'm getting back into the rhythm of dealing with Rebol, so it's good to do something fun...but...what needs to happen is the Travis and other planning.  So I'll probably put this down while I let the questions sink in a bit.  Again, this was all just solidifying the answer to the topic of this thread, which I feel is settled now.)</em></p>
          <p><a href="https://forum.rebol.info/t/should-append-null-fail-append-blank-add-nothing-unless-only/635/7">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/should-append-null-fail-append-blank-add-nothing-unless-only/635/7</link>
        <pubDate>Tue, 27 Aug 2019 02:13:11 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-635-7</guid>
        <source url="https://forum.rebol.info/t/should-append-null-fail-append-blank-add-nothing-unless-only/635.rss">Should append null fail, append BLANK! add nothing unless /ONLY?</source>
      </item>
      <item>
        <title>Should append null fail, append BLANK! add nothing unless /ONLY?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-post="5" data-topic="635">
<div class="title">
<div class="quote-controls"></div>
<img alt width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Zany, I know. But what this means is that while blanks can come back from a function or evaluation, you wouldn't get them out of an ordinary variable unless you were kind of trying.</p>
</blockquote>
</aside>
<p>This is seeming <em>extremely</em> promising, for how it shifts the responsibility away from constructs like APPEND or COMPOSE and onto the caller to say what they mean.  Because you're not getting blanks unless they are really intended.  I have a cautious optimism of how this looks.</p>
<p><strong>BUT</strong> it messes with the idea that BLANK! is the equivalent in Redbol to NONE!.  In Rebol2 you can say:</p>
<pre><code>rebol2&gt; x: none
rebol2&gt; y: x
rebol2&gt; none? y
== #[true]
</code></pre>
<p>Yet under these rules, that becomes <strong>x: blank</strong>, so then <strong>y: x</strong> will act as <strong>y: null</strong>.  Meaning <strong>none? y</strong> will fail on an unset variable.  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=9" title=":frowning:" class="emoji" alt=":frowning:"></p>
<p>While we can change many things in Redbol emulation, the concept is that it still uses the same evaluator.  So the only way to get around this and still use blank for none would be if assigning nulls to variables set them to blank instead of unsetting them.  Then, routines that are under the emulation's control would have to be smart about handling both null and blank... (e.g. <strong>none?</strong> would accept either null or blank and return true).</p>
<p>The (uncomfortable) consequence would mean that <strong>x: null</strong> would not be a synonym for <strong>unset 'x</strong>:</p>
<pre><code> &gt;&gt; x: null
 ; null (but it *actually* stored a BLANK!)

 &gt;&gt; :x
 == _

 &gt;&gt; null? x  ; won't error, regenerates the null
 == #[true]

 &gt;&gt; unset 'x
 ; null (or should unset's return value be the old value?)

 &gt;&gt; :x
 ; null

 &gt;&gt; null? x
 ** Error: x is unset
</code></pre>
<p>One casualty of this is error handling.  Suddenly:</p>
<pre><code> &gt;&gt; x: third ["Hello" "World"]
 ; null (but stored a blank)

 &gt;&gt; append [a b c] x
 == [a b c]  ; hrmph, no error anymore :-(
</code></pre>
<p>Some might ask, is there any good reason why the above code should act any differently from if you said <strong>append [a b c] third ["Hello" "World"]</strong> directly?</p>
<p>Red and R3-Alpha don't think so:</p>
<pre><code>&gt;&gt; x: third ["Hello" "World"]
== none

&gt;&gt; append [a b c] x
== [a b c #[none]]   ; though it renders as [a b c none]

&gt;&gt; append [a b c] third ["Hello" "World"]
== [a b c #[none]]
</code></pre>
<p>It may seem a reasonable argument, but what makes me queasy is not <em>just</em> about error handling.  The null state really is distinct...and being <em>able</em> to not conflate it with a value that's there is critical.  Assignment is foundational, and if assignment itself throws away the null/blank distinction then something powerful was lost.  So my beef is actually with this:</p>
<pre><code>&gt;&gt; append [a b c] second ["Hello" _]
== [a b c _]

&gt;&gt; append [a b c] third ["Hello" _]
== [a b c]

&gt;&gt; s: second ["Hello" _]
== _

&gt;&gt; t: third ["Hello" _]
; null

&gt;&gt; append [a b c] :s
== [a b c _]

&gt;&gt; append [a b c] :t
== [a b c _]  ; ...ack!
</code></pre>
<p>That's the <a href="https://www.youtube.com/watch?v=a8EuHJ2xRAU" rel="nofollow noopener">bad mojo</a>.  Even a motivated individual wanting to know the difference...who is using a GET-WORD! to know...can't tell.  Then, add onto that the loss of the error handling in the plain WORD! case.</p>
<p>I'm aware that my radical proposal about "blank-to-null-decay" is all about conflating blank and null <em>somewhat</em>.  But because it doesn't happen with a GET-WORD!, I'm saying that it becomes the option of the user of the variable to decide if they care, in the context they are using it.  <em>The variable is still holding the actual state that it captured at the time of the assignment, you just have the choice to decide if that matters at the point of retrieval.</em>  A similar decision is made when you distinguish <strong>append</strong> from <strong>:append</strong>; the word looks up to a function, but did you want the function invoked or did you want its ACTION! value?  You choose.  If you could only run the function but were unable to fetch its value, that would be a problem!</p>
<p>Hence I'm pretty sure I'm not cool with <strong>x: null</strong> doing anything other than unsetting <strong>x</strong>...as a distinct state from <strong>x: _</strong> or <strong>x: second [a _ b]</strong>.</p>
<hr>
<p><strong>So in the event that BLANK! takes this path of "null decay"...Redbol needs another solution for its NONE! than reusing BLANK!, because it just won't have the same evaluative properties.</strong>  So what's the workaround?  Perhaps a special NONE! legacy type that is falsey, but does not translate to a null when fetched through WORD! or PATH! access?  It could reuse the same cell as BLANK!, but just have a flag set to say "don't decay".</p>
<p>Or it could use something that simply didn't exist in Rebol2/etc., that is inert...like <strong><code>@none</code></strong>.  That wouldn't conflate with anything Rebol2 uses the way something like <strong><code>#none</code></strong> might.  But since it's not intrinsically falsey, anything that did tests would have to be hooked pretty deeply in their sense of logic testing.  Some could be easy:</p>
<pre><code> true?: func [v] [
     either :v = @none [false] [lib/did :v]
 ]

 if: adapt 'lib/if [
     condition: true? :condition
 ]
</code></pre>
<p>Others would be more difficult, such as digging into the behavior of CASE.  Though maybe not, <a href="https://forum.rebol.info/t/brave-switch-new-world-skippable-predicates/1045">using predicates</a>, which could have similar overrides on the tests.  Redbol's CASE could just be Ren-C CASE specialized with Redbol TRUE? as the predicate.  Same for ANY, ALL, etc.</p>
<p>These things are certainly profound tests of the flexibility of Ren-C.  And when we think about performance, the idea that TRUE? would be making so many appearances gives the kind of motivation of something where it's worth coding as a native in the Redbol extension, as optimized C against the internal API.</p>
<p>But the interoperability will face limits at some point.  How could PARSE be hooked to treat <span class="mention">@none</span> as an empty rule that is simply skipped?  Some compatibility points like this might just require making a non-decaying blank for NONE! that gets thrown in, and loading the Redbol extension enables that datatype to become visible.</p>
<p>I'd rather do something like that to bridge the gap, than not do a good idea for compatibility's sake!</p>
          <p><a href="https://forum.rebol.info/t/should-append-null-fail-append-blank-add-nothing-unless-only/635/6">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/should-append-null-fail-append-blank-add-nothing-unless-only/635/6</link>
        <pubDate>Mon, 26 Aug 2019 17:24:02 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-635-6</guid>
        <source url="https://forum.rebol.info/t/should-append-null-fail-append-blank-add-nothing-unless-only/635.rss">Should append null fail, append BLANK! add nothing unless /ONLY?</source>
      </item>
      <item>
        <title>Should append null fail, append BLANK! add nothing unless /ONLY?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-post="4" data-topic="635">
<div class="title">
<div class="quote-controls"></div>
<img alt width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Blanks are values first and foremost, and nothings second.</p>
</blockquote>
</aside>
<p>I just had a weird idea on this that I'd not had before: <strong>make words and paths that look up to blank yield null by default, and need a GET-WORD! to say they're actually BLANK!</strong>.</p>
<pre><code>&gt;&gt; x: _
== _

&gt;&gt; x
; null

&gt;&gt; :x
== _

&gt;&gt; get 'x
== _

&gt;&gt; y: null
; null

&gt;&gt; y
** Error: y is not set

&gt;&gt; :y
; null
</code></pre>
<p>So blanks themselves are inert and have no evaluator behavior.  And if a blank comes back from a function call you get it.  But plain words and plain paths that look up to blank variables evaluate to null.  While plain words and plain paths that look up to null variables error, and plain words and plain paths that look up to ACTION!s run them.</p>
<p>Zany, I know.  But what this means is that while blanks can come back from a function or evaluation, you wouldn't get them out of an ordinary variable unless you were kind of trying.</p>
<p>You might think of it as an enhancement of "blank-in-null-out", just bringing the feature to ordinary variable references.</p>
<p>I actually thought of this while thinking about mapping blanks to spaces.  I wondered if this could be done e.g.</p>
<pre><code>&gt;&gt; unspaced ["some" "stuff" _ "other" "stuff"]
== "somestuff otherstuff"
</code></pre>
<p>But this ran up against a desire to be able to say:</p>
<pre><code>&gt;&gt; var: try third ["stuff" "morestuff"]
== _  ; e.g. no third item, TRY blankified null

&gt;&gt; unspaced ["a" var "b"]  ; look ma, no `:var`
== "ab"  ; and no error...but blank var gave null
</code></pre>
<p>Plain WORD! <strong>var</strong> couldn't serve both roles; it would be either a synonym for null that didn't cause an error on regular references, or a synonym for space.</p>
<p>I've also been noticing that I think the version of REDUCE that a GET-BLOCK! runs needs to be able to vaporize nulls and not error, otherwise you couldn't write:</p>
<pre><code>append b :[if true [&lt;append&gt;] if false [&lt;skip&gt;]]
</code></pre>
<p>Not being able to handle nulls to drop data entirely would be a shame for this very cool solution to REPEND.</p>
          <p><a href="https://forum.rebol.info/t/should-append-null-fail-append-blank-add-nothing-unless-only/635/5">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/should-append-null-fail-append-blank-add-nothing-unless-only/635/5</link>
        <pubDate>Sun, 25 Aug 2019 01:19:38 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-635-5</guid>
        <source url="https://forum.rebol.info/t/should-append-null-fail-append-blank-add-nothing-unless-only/635.rss">Should append null fail, append BLANK! add nothing unless /ONLY?</source>
      </item>
      <item>
        <title>Should append null fail, append BLANK! add nothing unless /ONLY?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group quote-modified" data-post="3" data-topic="635">
<div class="title">
<div class="quote-controls"></div>
<img alt width="20" height="20" src="//forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>"It’s likely better to embrace blank’s “nothingness-without-triggering-errors-on-access” as its primary facet, with its ability to be represented in a block as secondary."</p>
</blockquote>
</aside>
<p>To put myself on the other side of this statement: <em>both</em> aspects are going to come into play, whether you like it or not.  It's not going to be all one way or the other.   You're going to sometimes be thinking of a blank as a "thing", and sometimes as a "nothing".</p>
<p>Let's look away from APPEND and COMPOSE for a moment, and think about maps.  Today these are different:</p>
<pre><code>my-map/key: _ // sets the key to a blank value
my-map/key: null // removes the key
</code></pre>
<p>Here you don't have the option of an /ONLY.  So if blanks were treated as nothings, you'd lose the ability to put them into maps with this mechanism.  But as long as they are distinct, you have the choice to say either:</p>
<pre><code>my-map/key: thing-that-might-be-blank
my-map/key: opt thing-that-might-be-blank
</code></pre>
<p>Going back to APPEND and COMPOSE, the /ONLY is already controlling one aspect: splicing or not.  But...</p>
<ul>
<li>...what if you want to splice if it's a block, and treat it like a literal blank if it isn't?</li>
<li>...what if you want to not splice if it's a block, but treat it as nothing if it's a blank?</li>
</ul>
<h2>When in Doubt, Favor the Mechanically Consistent Behavior</h2>
<p>Sometimes things seem annoying when you look at them as individual cases, but you realize their necessity if the big picture is taken into account.</p>
<p>I think needing OPT at the callsite is just one of these necessary evils--that's not even that evil.</p>
<p>For historical perspective: When I initially complained about NONE!s not "vaporizing" in things like COMPOSE, BrianH was very adamant that NONE!s were things.  He believed a lot of Rebol's idiomatic behavior involved having empty placeholders in slots of regular record-like structures.  So he was generally resistant to using them to opt-out when blocks were being produced.</p>
<p>So I guess this just kind of informs what the system's bias is: <em>Blanks are values first and foremost, and nothings second.</em></p>
          <p><a href="https://forum.rebol.info/t/should-append-null-fail-append-blank-add-nothing-unless-only/635/4">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/should-append-null-fail-append-blank-add-nothing-unless-only/635/4</link>
        <pubDate>Tue, 18 Dec 2018 22:09:40 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-635-4</guid>
        <source url="https://forum.rebol.info/t/should-append-null-fail-append-blank-add-nothing-unless-only/635.rss">Should append null fail, append BLANK! add nothing unless /ONLY?</source>
      </item>
      <item>
        <title>Should append null fail, append BLANK! add nothing unless /ONLY?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-post="2" data-topic="635">
<div class="title">
<div class="quote-controls"></div>
<img alt width="20" height="20" src="//forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>NULLs will continue to append or compose without error.</p>
</blockquote>
</aside>
<p>This now has a fairly strong philosophical defense in <a href="https://forum.rebol.info/t/null-first-class-values-and-safety/895">NULL, first-class values, and safety</a>.</p>
<p>The way I've started to feel comfortable with this is saying that NULL is what you use when you're talking about a <strong>"what"</strong>.  You can use a null to opt-out of that.  But you can't use a null to opt-out of a <strong>"where"</strong>.  Only BLANK! can do that.</p>
<aside class="quote no-group quote-modified" data-post="2" data-topic="635">
<div class="title">
<div class="quote-controls"></div>
<img alt width="20" height="20" src="//forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>But if you have a BLANK! in your hand, that is a “normal” value that will be COMPOSE’d in, or APPEND’d, etc.:</p>
</blockquote>
</aside>
<p>This is a really tough one to think about.</p>
<p>As the rules have shaped up, I often feel this should probably change to requiring an APPEND/ONLY or COMPOSE/ONLY, otherwise blanks should act like nulls.  The premise is this:</p>
<blockquote>
<p><strong>It's likely better to embrace blank's "nothingness-without-triggering-errors-on-access" as its primary facet, with its ability to be represented in a block as secondary.</strong></p>
</blockquote>
<p>It's hard to see a clear answer purely from a nuts-and-bolts point of view.  But it just seems like it's more natural.  Consider:</p>
<pre><code>  foo: try case [...]
  ...
  compose [... (opt foo) ...]
</code></pre>
<p>There's arguably a nice aspect to the annotation that it's optional, and you might say the random blanks popping up to tell you that you left off an OPT is a feature and not a bug.</p>
<p>But in practice I'm not feeling that.  I didn't invoke the TRY because <em>I wanted to create a thing</em>.  I put the TRY there because I wanted to say that my tolerance of nothingness was intentional, and I expect this variable to be defined...but conditionally false.</p>
<p>If I were nervous and felt I needed some kind of additional signaling not to use it in an optional sense, I'd have left off the TRY...so foo would have been unset.  Why should I have to repeat myself by way of an OPT annotation when I use the variable in this casual circumstance?  Doesn't it kind of undermine the convenience of having blank in the first place?</p>
<p>I've made the argument that wanting to append literal blanks is probably less common than wanting to append literal blocks, and that takes an /ONLY.  You can append a literal blank as easily as <strong><code>append block [_]</code></strong> if you want to, so it's not like there aren't good options for the cases when you need it.</p>
<p>What's tough about it is that it is a slippery slope.  This makes one think "oh, well then should refinement arguments go back to being blank when they're not supplied?"  And some of these things that sound good then turn around and bite you because conflating values with nulls loses the rigor of null and compromises the features it enabled.  :-/</p>
<p>It's definitely a serious consideration to change this.  So please speak up with any observations...</p>
          <p><a href="https://forum.rebol.info/t/should-append-null-fail-append-blank-add-nothing-unless-only/635/3">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/should-append-null-fail-append-blank-add-nothing-unless-only/635/3</link>
        <pubDate>Tue, 18 Dec 2018 08:37:29 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-635-3</guid>
        <source url="https://forum.rebol.info/t/should-append-null-fail-append-blank-add-nothing-unless-only/635.rss">Should append null fail, append BLANK! add nothing unless /ONLY?</source>
      </item>
      <item>
        <title>Should append null fail, append BLANK! add nothing unless /ONLY?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>So the answer, after delving and thinking on this issue, has come up as NO.</p>
<p>NULLs will continue to append or compose without error.</p>
<pre><code>&gt;&gt; data: copy [a b c]
&gt;&gt; append data null
== [a b c]

&gt;&gt; compose [a (if false [&lt;omitted&gt;]) b]
== [a b]
</code></pre>
<p>But if you have a BLANK! in your hand, that is a "normal" value that will be COMPOSE'd in, or APPEND'd, etc.:</p>
<pre><code>&gt;&gt; data: copy [a b c]
&gt;&gt; append data _
== [a b c _]

&gt;&gt; compose [a (_) b]
== [a _ b]
</code></pre>
<p>It's your job to OPT something that might be blank, if you want blanks to be turned into NULLs and evaporate.</p>
<p>Sound a bit awkward, given how many routines return BLANK!s when they fail?  Well, no worries...</p>
<h3>NULLs are taking over a lot of former BLANK! roles</h3>
<p>A failed ANY or ALL, a FIND that didn't find anything, a MATCH that didn't take... <em>these will all be returning NULL, and not blank</em>.  This is the new return value protocol, where BLANK! is no longer used as a return value meaning "no match".  <a href="https://forum.rebol.info/t/the-benefits-of-a-falsey-null-any-major-drawbacks/675/2">And it will be tolerable because NULLs will be conditionally false</a>.</p>
<p>This gives BLANK!s a renewed purpose, but a purpose for which they should be thought of as "things".</p>
<p>It's a good feeling to pin down this previously oft-speculated-upon question, since it really was inelegant to have to say <strong>compose [a (opt any [...]) b]</strong>, etc.  But we need wonder no longer...you will be able to omit the OPT because ANY will now return NULL!</p>
          <p><a href="https://forum.rebol.info/t/should-append-null-fail-append-blank-add-nothing-unless-only/635/2">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/should-append-null-fail-append-blank-add-nothing-unless-only/635/2</link>
        <pubDate>Wed, 13 Jun 2018 00:07:26 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-635-2</guid>
        <source url="https://forum.rebol.info/t/should-append-null-fail-append-blank-add-nothing-unless-only/635.rss">Should append null fail, append BLANK! add nothing unless /ONLY?</source>
      </item>
      <item>
        <title>Should append null fail, append BLANK! add nothing unless /ONLY?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>The Rebol design concept that used to be discussed under the label "none propagation" has become a system of what I think are pretty good rules:</p>
<ul>
<li><strong>Blank input gives Null output...<em>for non-mutating operations</em></strong></li>
<li><strong>Mutating operations do not accept BLANK! targets as input</strong></li>
<li><strong>Null input gives an error for operations <em>that aren't specifically about null handling</em></strong></li>
<li><strong>TRY can be used to "defuse" nulls into blanks</strong></li>
</ul>
<p>The reason this has merit is because it gives you a "hot potato" in the form of NULL, without going so far as to error in the moment.  You get pinpointed error locality where a problem <em>might</em> be, and have an easy mitigation--if you want it--to use TRY to turn the null into a BLANK! and pass through all other results.  And there are a host of null-driven operations to let you pick up the slack, e.g. <strong>first block else [code]</strong>.</p>
<p><em>(I've suggested that if you ever actually wind up having to put a null state in a variable, test for null later with NULL? and act on it, that you probably could have done it better...reacting to the null without ever using it as a stored state.  But it's your choice, I guess.)</em></p>
<p>So this is being applied across the board.  <strong>first _</strong> is null...just like <strong>first []</strong> is.</p>
<h3>Consequences for APPEND/INSERT/CHANGE...</h3>
<p>These rules affect a current feature of things like APPEND that I doubt many people have tried:</p>
<pre><code> &gt;&gt; append copy [a b c] null
 == [a b c]

&gt;&gt; append copy [a b c] if false ['d]
== [a b c]
</code></pre>
<p>When it was introduced, I thought it made sense.  Since NULL is not a value you can put in a block, you don't get confused about what that means.  Then since BLANK! is a legitimate value that can appear in a block, you could append it:</p>
<pre><code> &gt;&gt; append copy [a b c] _
 == [a b c _]
</code></pre>
<p>But quietly accepting NULL loses the hot-potato benefit.  If you say <strong>append foo third block</strong> and there is no third element in the block, <em>doesn't that seem like a good time to complain</em>?  Rebol code can pretty quickly get hard to read and debug, and wouldn't it be nice if the person who wrote that line could articulate that there may not be a third thing in the block by saying <strong>append foo try third block</strong>?</p>
<p>This suggests making the default behavior of BLANK! to be to add nothing, and you need an /ONLY to override that.  It may sound like a missed opportunity for null to exploit its out-of-band status.  But realistically speaking, I don't think purposefully adding blanks is all that common--certainly a lot less common than adding a block as-is, and that requires /ONLY!</p>
<h3>No one probably cared (...yet...)</h3>
<p>Like I say--most people probably were unaware of this, and so I don't know there's a lot of <strong>append block if condition [...]</strong> out there today.  We might need APPEND/OPT to be null tolerant, though the only reason to use it would be with /ONLY since otherwise you could say <strong>append block try if condition [...]</strong>.</p>
          <p><a href="https://forum.rebol.info/t/should-append-null-fail-append-blank-add-nothing-unless-only/635/1">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/should-append-null-fail-append-blank-add-nothing-unless-only/635/1</link>
        <pubDate>Sat, 19 May 2018 19:17:28 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-635-1</guid>
        <source url="https://forum.rebol.info/t/should-append-null-fail-append-blank-add-nothing-unless-only/635.rss">Should append null fail, append BLANK! add nothing unless /ONLY?</source>
      </item>
  </channel>
</rss>
