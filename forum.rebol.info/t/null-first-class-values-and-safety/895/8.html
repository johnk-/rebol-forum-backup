<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>NULL, first-class values, and safety - #8 by hostilefork - Philosophy - AltRebol</title>
    <meta name="description" content="I found a post from Carl titled &amp;quot;UNSET! is not first class&amp;quot;. 

It’s important to understand the unset! datatype; otherwise, we run the risk of assuming that it is  first class  (assignable, passable, returnable) when it’&amp;hellip;">
    <meta name="generator" content="Discourse 2.7.0.beta4 - https://github.com/discourse/discourse version 3fc72543de22c329cf2156f28b781821adc496ae">
<link rel="icon" type="image/png" href="../../../uploads/default/optimized/1X/cbd70027b53fa165575e5b665f00eb3b8ae7ea31_2_32x32.ico">
<link rel="apple-touch-icon" type="image/png" href="../../../uploads/default/optimized/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d_2_180x180.png">
<meta name="theme-color" content="#ffffff">
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, user-scalable=yes, viewport-fit=cover">
<link rel="canonical" href="https://forum.rebol.info/t/null-first-class-values-and-safety/895" />
<script type="application/ld+json">{"@context":"http://schema.org","@type":"WebSite","url":"https://forum.rebol.info","potentialAction":{"@type":"SearchAction","target":"https://forum.rebol.info/search?q={search_term_string}","query-input":"required name=search_term_string"}}</script>
<link rel="search" type="application/opensearchdescription+xml" href="../../../opensearch.xml" title="AltRebol Search">

      <link href="https://forum.rebol.info/stylesheets/desktop_e71c7b3a0694e7f6434c54a663bfb42821f8bd81.css?__ws=forum.rebol.info" media="all" rel="stylesheet" data-target="desktop" />
    
    
        <link rel="alternate" type="application/rss+xml" title="RSS feed of &#39;NULL, first-class values, and safety&#39;" href="../895.rss" />
    <meta property="og:site_name" content="AltRebol" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:image" content="https://forum.rebol.info/uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png" />
<meta property="og:image" content="https://forum.rebol.info/uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png" />
<meta property="og:url" content="https://forum.rebol.info/t/null-first-class-values-and-safety/895/8" />
<meta name="twitter:url" content="https://forum.rebol.info/t/null-first-class-values-and-safety/895/8" />
<meta property="og:title" content="NULL, first-class values, and safety" />
<meta name="twitter:title" content="NULL, first-class values, and safety" />
<meta property="og:description" content="Here I&#39;m pointing out a difference between Rebol2 and Ren-C:  data: [] x: find [a b c] &#39;d append data x   ; no error in Rebol2, error in Ren-C (x is unset)  Rebol2 would not only have not errored, but it would be adding a blank there...so data would be mutated.  Yet in Ren-C, you wouldn&#39;t have gotten an error if you had said:  data: [] append data find [a b c] &#39;d  This would have appended nothing, as NULL &quot;opts out&quot; of appends (since there is no way to put a null in a block, it is not a &quot;value&quot;..." />
<meta name="twitter:description" content="Here I&#39;m pointing out a difference between Rebol2 and Ren-C:  data: [] x: find [a b c] &#39;d append data x   ; no error in Rebol2, error in Ren-C (x is unset)  Rebol2 would not only have not errored, but it would be adding a blank there...so data would be mutated.  Yet in Ren-C, you wouldn&#39;t have gotten an error if you had said:  data: [] append data find [a b c] &#39;d  This would have appended nothing, as NULL &quot;opts out&quot; of appends (since there is no way to put a null in a block, it is not a &quot;value&quot;..." />
<meta property="article:published_time" content="2019-06-01T15:51:54+00:00" />
<meta property="og:ignore_canonical" content="true" />



    
  </head>
  <body class="crawler">
    
    <header>
      <a href="https://forum.rebol.info/">
          <img src="../../../uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png" alt="AltRebol" id="site-logo" style="max-width: 150px;">
      </a>
    </header>
    <div id="main-outlet" class="wrap">
        <div id="topic-title">
    <h1>
      <a href="https://forum.rebol.info/t/null-first-class-values-and-safety/895">NULL, first-class values, and safety</a>
    </h1>

      <div class="topic-category" itemscope itemtype="http://schema.org/BreadcrumbList">
          <span itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
            <a href="https://forum.rebol.info/c/usage/7" class="badge-wrapper bullet" itemprop="item">
              <span class='badge-category-bg' style='background-color: #3AB54A'></span>
              <span class='badge-category clear-badge'>
                <span class='category-name' itemprop='name'>Usage</span>
              </span>
            </a>
            <meta itemprop="position" content="1" />
          </span>
          <span itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
            <a href="../../../c/usage/philosophy.html" class="badge-wrapper bullet" itemprop="item">
              <span class='badge-category-bg' style='background-color: #3AB54A'></span>
              <span class='badge-category clear-badge'>
                <span class='category-name' itemprop='name'>Philosophy</span>
              </span>
            </a>
            <meta itemprop="position" content="2" />
          </span>
      </div>

  </div>

  


      <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
        <div class='crawler-post-meta'>
          <div itemprop='publisher' itemscope itemtype="http://schema.org/Organization">
            <meta itemprop='name' content='AltRebol'>
              <div itemprop='logo' itemscope itemtype="http://schema.org/ImageObject">
                <meta itemprop='url' content='https://forum.rebol.info/uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png'>
              </div>
          </div>
          <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
            <a itemprop="url" href='https://forum.rebol.info/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
            
          </span>

          <link itemprop="mainEntityOfPage" href="https://forum.rebol.info/t/null-first-class-values-and-safety/895">


          <span class="crawler-post-infos">
              <meta itemprop='datePublished' content='2018-11-07T17:17:54Z'>
              <time itemprop='dateModified' datetime='2019-02-18T23:41:24Z' class='post-time'>
                February 18, 2019, 11:41pm
              </time>
          <span itemprop='position'>#1</span>
          </span>
        </div>
        <div class='post' itemprop='articleBody'>
          <p>I found a post from Carl titled <a href="http://www.rebol.net/r3blogs/0318.html" rel="nofollow noopener"><strong>"UNSET! is not first class"</strong></a>.</p>
<blockquote>
<p><strong>It's important to understand the unset! datatype; otherwise, we run the risk of assuming that it is  <em>first class</em>  (assignable, passable, returnable) when it's really not intended for that kind of usage!</strong></p>
</blockquote>
<p>He gets to the idea that it's not a "normal" value.  While not taking the step to make it illegal to put in blocks, I think that was just a matter of not having thought through how to prevent it.  You see the notion of a wish to quarantine something that is a "necessary evil".</p>
<p>Tuning the model in Ren-C, the roles of the two cases of <code>NONE!/UNSET!</code> were reshaped to into NULL, VOID!, and BLANK!.  This has been very successful, putting the "hot potato" nature of null to good use by keeping it something you cannot assign...while allowing it to be conditionally false.  The "neither true-nor-false" role then falls to VOID!, as a prickly value that is nonetheless <em>a value</em> and can be put in blocks if you insist.</p>
<h2>Should NULL assigns via SET-WORD! unset variables?</h2>
<p>When NULL was first being introduced, it wasn't the failure result from ANY or FIND.  Those still used blank, which was more convenient since that era's null was neither true nor false (like UNSET! had been).</p>
<p>Instead, null was sneaking in as the outcome of failed conditionals...as well as trying to be a "more correct" answer to things like <strong>select [a 10 b 20] 'c</strong>.  There, a null result distinguished from a literal blank in a block, such as <strong>select [a 10 b 20 c _] 'c</strong>.</p>
<p>But with null being such a hot potato, there were difficulties.  So it was tried that <strong>foo: null</strong> would unset the <code>foo</code> variable, vs. be an error.  This made it a bit less awkward to work with if you wanted to write something like:</p>
<pre><code>if not null? x: select block value [
   ...do stuff with x...
] else [
   ...x is unset, maybe do error handling here...
]
</code></pre>
<p>If SET-WORD!s caused errors, that would be more tricky--you'd have to test the result of SELECT for null, but the test would return LOGIC! and lose your result for assigning.</p>
<p><strong>But, enfix to the rescue</strong>...once operations like ELSE and THEN came on the scene, they offered a new possibility...instead of needing IF and a test for a branch, the branch could react to the nullness <em>before</em> the assignment.  Whether you needed error handling or default values, this pattern addressed most needs.</p>
<pre><code> x: select block value else [&lt;default-value&gt;]
</code></pre>
<p>Then null changed to be conditionally false, with VOID! picking up its neither-true-nor-false duties.  Routines like ANY and ALL and FIND began returning NULL on failure, which could be used in conditionals without any extra work.  Then conversion of nulls to blanks was made as easy as <a href="../../if-at-first-you-dont-select-try-try-again/589.html">the short, repurposed word TRY</a>.</p>
<p>With this change, it was moved back to where null assignments to SET-WORD! were errors, though I've sometimes wondered if there would be an advantage to letting NULL implicitly unset variables.  Should you be able to say <strong>pos: find block value</strong> and then <strong>if set? 'pos [...]</strong> or do you really need to say <strong>pos: try find block value</strong>?</p>
        </div>

        <meta itemprop='headline' content='NULL, first-class values, and safety'>
          <meta itemprop='keywords' content=''>

        <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
           <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
           <meta itemprop="userInteractionCount" content="1" />
           <span class='post-likes'>1 Like</span>
         </div>

         <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
            <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
            <meta itemprop="userInteractionCount" content="0" />
          </div>

            <div class='crawler-linkback-list' itemscope itemtype='http://schema.org/ItemList'>
                  <div itemprop='itemListElement' itemscope itemtype='http://schema.org/ListItem'>
                    <a href="../../should-append-null-fail-append-blank-add-nothing-unless-only/635/3.html" itemscope itemtype='http://schema.org/DiscussionForumPosting' itemprop='item'>
                      <meta itemprop='url' content='http://forum.rebol.info/t/should-append-null-fail-append-blank-add-nothing-unless-only/635/3'>
                      <span itemprop='name'>Should append null fail, append BLANK! add nothing unless /ONLY?</span>
                    </a>
                    <meta itemprop='position' content='3'>
                  </div>
                  <div itemprop='itemListElement' itemscope itemtype='http://schema.org/ListItem'>
                    <a href="../../does-set-any-get-any-thing-matter-anymore/1053.html" itemscope itemtype='http://schema.org/DiscussionForumPosting' itemprop='item'>
                      <meta itemprop='url' content='https://forum.rebol.info/t/does-set-any-get-any-thing-matter-anymore/1053'>
                      <span itemprop='name'>Does SET/ANY, GET/ANY-thing matter anymore?</span>
                    </a>
                    <meta itemprop='position' content='4'>
                  </div>
                  <div itemprop='itemListElement' itemscope itemtype='http://schema.org/ListItem'>
                    <a href="../../default-values-and-make-frame/1412/3.html" itemscope itemtype='http://schema.org/DiscussionForumPosting' itemprop='item'>
                      <meta itemprop='url' content='https://forum.rebol.info/t/default-values-and-make-frame/1412/3'>
                      <span itemprop='name'>Default Values And MAKE FRAME!</span>
                    </a>
                    <meta itemprop='position' content='5'>
                  </div>
            </div>
      </div>
      <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
        <div class='crawler-post-meta'>
          <div itemprop='publisher' itemscope itemtype="http://schema.org/Organization">
            <meta itemprop='name' content='AltRebol'>
              <div itemprop='logo' itemscope itemtype="http://schema.org/ImageObject">
                <meta itemprop='url' content='https://forum.rebol.info/uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png'>
              </div>
          </div>
          <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
            <a itemprop="url" href='https://forum.rebol.info/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
            
          </span>

          <link itemprop="mainEntityOfPage" href="https://forum.rebol.info/t/null-first-class-values-and-safety/895">


          <span class="crawler-post-infos">
              <meta itemprop='datePublished' content='2018-11-12T01:27:51Z'>
              <time itemprop='dateModified' datetime='2019-02-18T23:48:38Z' class='post-time'>
                February 18, 2019, 11:48pm
              </time>
          <span itemprop='position'>#2</span>
          </span>
        </div>
        <div class='post' itemprop='articleBody'>
          <p>This is rather important, so I don't want to take it lightly.  We want to get it right, and after Beta/One will be too late.  So here's some more thought:</p>
<p>The core issue is two competing applications we might want to use NULL's special status for:</p>
<ol>
<li>
<p>Representing the absence of a value in order to "opt out" of a parameter where a BLANK! has a legitimate purpose.  e.g. <strong>append block _</strong> has a reasonable interpretation as adding a blank to a block just as <strong>append block 1020</strong> has a reasonable interpretation of adding an integer.  But since <strong>append data null</strong> cannot add a value, it can distinctly be used to signal not adding one.</p>
</li>
<li>
<p>Representing the absence of a value in order to indicate a failure to find a necessary value, allowing errors to trigger at appropriate places.  For instance, if <strong>select data key</strong> returns <strong>null</strong>, then it's convenient to have <strong>first second third select data key</strong> trigger an error at <code>third</code>--since that helps isolate where the problem occurred in the chain.</p>
</li>
</ol>
<p>Case 2 led to a convention called "BLANK! in, NULL out".  This is the idea that while most routines will error on NULL input, if they get a BLANK! input (and don't have a significant meaning for blank) then they will provide a null output.  This can be mitigated with TRY to convert nulls to blanks.  So you could say <strong>third try select data key</strong> and not get an error, rather a null.</p>
<p>Yet the needs of Case 1 are everywhere.  Consider MAP-EACH:</p>
<pre><code>&gt;&gt; map-each x [1 2 3 4] [if odd? x [x]]
== [1 3]
</code></pre>
<p>Or even just:</p>
<pre><code>&gt;&gt; map-each x [1 2 3 4] [match odd? x]
== [1 3]
</code></pre>
<p>Doesn't it seem nice and natural to assume that if the MAP-EACH branch returns null that nothing gets added?  Isn't that better than having BLANK! mean add nothing, and null be an error?  Plus if blanks were signaling adding nothing, how would you map to a blank?</p>
<h2>All Parameters are not Created Equal</h2>
<p>It's important to point out that when we're looking at routines, different parameters are different...and may not have the same null philosophy.  So <strong>append block null</strong> is distinct from <strong>append null block</strong>.  A policy about parameter handling can discern and say one of these is an error and one not, without being a blanket statement about all arguments.</p>
<p>What has been the going idea so far with operations like APPEND is that <em>null is legal to opt-out of the material to append, but not the thing to append to</em>.  If append didn't mutate, you'd be able to say <strong>append _ block</strong> if you want to opt-out of the append operation by way of its series parameter, and that--in turn--would return a null.  But since it mutates, the concern is that blank is used too casually as nothing-ness that if no one checks the result, you don't want <code>append obj/series data</code> to silently have no effect when you'd said <code>obj: make object! [series: _]</code> to hold an initial value.</p>
<p>For the first argument I think this is solid reasoning...no nulls, no blanks.  But for the second--as with the MAP-EACH--I can't help but feel that something is lost here if the thing-to-append can't be NULL.  Not only that, but you are getting the normal return result...the series you passed into APPEND, vs. the NULL you would get if you passed a blank for the series.</p>
<p>I feel like this is right, and the error-raising desires of bullet point (2) just have to take a back seat when it comes to that second parameter.</p>
<h2>Is the rule "if BLANK! has meaning here, NULL means opt out?"</h2>
<p>This rule feels rather weird.  But can we say that all routines where passing in a BLANK! to a parameter is meaningful (e.g. does not mean opt-out), should those routines accept NULL in that parameter to mean opt out of that parameter?</p>
<p>MAP-EACH fits this rule in the sense of its body result's blank significance (but wanting null to opt out), and APPEND does in its second parameter.  Is it truly general?  You can REPLACE blanks...</p>
<pre><code> &gt;&gt; block: copy [1 _ 2 _]
 &gt;&gt; replace/all block _ 0
 [1 0 2 0]
</code></pre>
<p>And you can REPLACE things with blanks:</p>
<pre><code> &gt;&gt; block: copy [3 0 4]
 &gt;&gt; replace block 0 _
 [3 _ 4]
</code></pre>
<p>So does this suggest that you should be able to opt out of those parameters with nulls?  <strong>Note that opting out of a <em>parameter</em> doesn't necessarily mean the <em>operation</em> is a no-op</strong>:</p>
<pre><code> &gt;&gt; block: copy [3 0 4]
 &gt;&gt; replace block 0 null
 [3 4]
</code></pre>
<p>But it could wind up having no effect:</p>
<pre><code> &gt;&gt; block: copy [3 0 4]
 &gt;&gt; replace block (if 10 &gt; 20 [0]) blank
 [3 0 4]
</code></pre>
<p>And do notice that opting out of what-to-replace like that, and being sure it won't replace any content, couldn't be done with blank (or a Rebol2/R3-Alpha none!).</p>
<p>This kind of thing has been applied unevenly in experiments.  Making it a generality and committing to it would offer a lot of power...and it's hard to see how in the scheme of things, erring on the side of "safety" instead would really help Rebol's big picture.</p>
<h2>But how does that rule apply with SET?</h2>
<p>We know that <strong>set 'foo _</strong> should be legal, as setting a variable to blank is legal.  But passing a null needs to either be an error or unset the variable..."opting out" of the value cannot "opt out" of the <em>assignment</em> and leave it with its existing value!</p>
<pre><code>&gt;&gt; foo: 10

&gt;&gt; set 'foo select [a 20 b 30] 'c

&gt;&gt; print foo
10  ; this would pretty clearly be bad mojo
</code></pre>
<h2>What about map removals?</h2>
<p>If you have a map, how would you take an element out of it?  It lacks positioning.  Red's lack of a non-value like NULL which is distinct from the valued BLANK! ("none!") means <a href="https://github.com/red/red/wiki/%5BNOTES%5D-Design-notes-on-removing-keys-from-MAP!-values" rel="nofollow noopener">they struggle with this issue</a>.  It seems a waste to not take advantage of Ren-C's hard-earned upper hand, here.</p>
<p>One option would be  <strong>poke m key null</strong>, which might be good enough.  But what about <strong>m/(key): null</strong>?  If SET-PATH! (and likely SET-WORD!) allowed that, then it could work too.</p>
<p>But as I mentioned in the initial post on this thread, I've been pretty personally sold on not allowing null assignments via SET-WORD!s.  This means you're covered with an error when you write stuff like:</p>
<pre><code> x: &lt;foo&gt;
 ...
 num: switch x [
     &lt;bar&gt; [1 + 2]
     &lt;baz&gt; [3 + 4]
 ]
</code></pre>
<p>You don't have to be paranoid and throw in some default case or failure branch.  You know null assignments are going to be illegal so you can just code in the cases that match if those are all you're expecting.  If you want to indicate you're okay with failing, you can say <strong>try switch</strong>.  I don't think it's just CASE and SWITCH that benefit...it's across the board.  And it allows more comfort in making things like GET be willing to return NULL without a special "GET/ANY"-like refinement.</p>
<p>But how valuable is that error locality vs. being able to unset map keys or variables more easily?  Tough decisions, here!</p>
<p>I'm not sure exactly what all this points to.  But it feels that null parameters likely do have to be tolerated for the second argument of routines like APPEND...and by extension, probably for the second and third arguments of REPLACE, etc.</p>
        </div>

        <meta itemprop='headline' content='NULL, first-class values, and safety'>

        <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
           <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
           <meta itemprop="userInteractionCount" content="2" />
           <span class='post-likes'>2 Likes</span>
         </div>

         <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
            <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
            <meta itemprop="userInteractionCount" content="0" />
          </div>

      </div>
      <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
        <div class='crawler-post-meta'>
          <div itemprop='publisher' itemscope itemtype="http://schema.org/Organization">
            <meta itemprop='name' content='AltRebol'>
              <div itemprop='logo' itemscope itemtype="http://schema.org/ImageObject">
                <meta itemprop='url' content='https://forum.rebol.info/uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png'>
              </div>
          </div>
          <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
            <a itemprop="url" href='../../../u/IngoHohmann.html'><span itemprop='name'>IngoHohmann</span></a>
            
          </span>

          <link itemprop="mainEntityOfPage" href="https://forum.rebol.info/t/null-first-class-values-and-safety/895">


          <span class="crawler-post-infos">
              <time itemprop='datePublished' datetime='2018-11-13T07:54:41Z' class='post-time'>
                November 13, 2018,  7:54am
              </time>
              <meta itemprop='dateModified' content='2018-11-13T07:54:41Z'>
          <span itemprop='position'>#3</span>
          </span>
        </div>
        <div class='post' itemprop='articleBody'>
          <p>My gut feeling is, it should unset variables and be a noop in append/replace cases, though not for the first value.<br>
I can think of places, where having it error may be desirable.<br>
I could imagine 'set's being errors, and otherwise it being noops.</p>
        </div>

        <meta itemprop='headline' content='NULL, first-class values, and safety'>

        <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
           <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
           <meta itemprop="userInteractionCount" content="1" />
           <span class='post-likes'>1 Like</span>
         </div>

         <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
            <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
            <meta itemprop="userInteractionCount" content="2" />
          </div>

      </div>
      <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
        <div class='crawler-post-meta'>
          <div itemprop='publisher' itemscope itemtype="http://schema.org/Organization">
            <meta itemprop='name' content='AltRebol'>
              <div itemprop='logo' itemscope itemtype="http://schema.org/ImageObject">
                <meta itemprop='url' content='https://forum.rebol.info/uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png'>
              </div>
          </div>
          <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
            <a itemprop="url" href='https://forum.rebol.info/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
            
          </span>

          <link itemprop="mainEntityOfPage" href="https://forum.rebol.info/t/null-first-class-values-and-safety/895">


          <span class="crawler-post-infos">
              <meta itemprop='datePublished' content='2018-11-13T09:12:03Z'>
              <time itemprop='dateModified' datetime='2019-02-18T23:50:07Z' class='post-time'>
                February 18, 2019, 11:50pm
              </time>
          <span itemprop='position'>#4</span>
          </span>
        </div>
        <div class='post' itemprop='articleBody'>
          <aside class="quote no-group" data-post="3" data-topic="895">
<div class="title">
<div class="quote-controls"></div>
<img alt width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/ingohohmann/40/195_2.png" class="avatar"> IngoHohmann:</div>
<blockquote>
<p>My gut feeling is, it should unset variables</p>
</blockquote>
</aside>
<p>I think the preponderance of evidence is on the side of unsetting.</p>
<h3>Substitution principle</h3>
<p>We know that we want you to be able to say things like <strong>print [... if false [...] ...]</strong> or otherwise have complex expressions evaluate to null and errorlessly signal an opt-out.  But when this can be an arbitrarily complex expression, shouldn't you be able--without thinking about how to rewrite it--factor it out?</p>
<pre><code>print [
    ...
    some complex expression returning null
    ...
]
</code></pre>
<p>=&gt;</p>
<pre><code> sub: some complex expression returning null
 print [... :sub ...]
</code></pre>
<p><em>It seems it shouldn't be harder than that.</em>  If you try to accomplish the same thing with TRY and OPT, then by definition you are losing information...since you conflated nulls with blanks just for the sake of getting things into a variable.  That's an opportunity to screw this up--and it's more typing/code.</p>
<h3>Safety injection requirement may make code LESS safe</h3>
<p>For instance, imagine a world where null assignments unset:</p>
<pre><code>all [
    foo: select some-data item
    bar: any [whatever whatever-else]
] then [
    do stuff with foo and bar
]
; if foo or bar caused a failure, they'll be unset and trigger errors
</code></pre>
<p>This kind of pattern gets you into the THEN with the knowledge that FOO and BAR are not null (in this case, you also know they're not false or blank).  But a null that caused the THEN not to run will leave whatever variable was involved in a state where accessing it gives an error.</p>
<p>Now think about the rote addition of TRY to dodge mandatory errors from set-word assignment:</p>
<pre><code>all [
    foo: try select some-data item
    bar: try any [whatever whatever-else]
] and [
    do stuff with foo and bar
]
; but if foo or bar caused a failure, they contain a "safe" blank now
</code></pre>
<p>Firstly, you can't use a THEN anymore...because you're not testing for value-ness.  You need to use AND to test for truthy-ness so blank doesn't count to run the clause.  To use THEN you'd have to get even hairier, with <strong>opt foo: try select ...</strong></p>
<p>Plus, the TRY made the situation worse after it.  Pursuant to some of the arguments about why "blankification" is dangerous for branches (and hence voidification is better), NULL causing "unsetification" in assignment is better than having people manually blankify with TRY.  Being unset is a more ornery state for a variable, and ornery is good here.</p>
<p><em>(Note: Phrasing is important here, variables cannot "hold null".  So "unsetification" is not such a ludicrous term.)</em></p>
<h3>Will seem more natural to Rebol2 users, vs. needing to "junk things up"</h3>
<p>You don't need a "fancy" example like the ALL above with multiple assignments to see how it looks more polluted.  From Rebol2, people are used to writing <code>if pos: find data item [...]</code>.  Telling them they need a TRY to do so would likely seem like a step back, and you don't want to force them to use a THEN if that's not how they want to write it.  Having lots of choices is the goal.</p>
<p>This way, they'll only need to throw on the TRY if they have some reason for reading the pos later.  But knowing the POS isn't a valid position has merit.</p>
<h3>It's easier than ever to trigger your own failures in conditionals</h3>
<p>I brought up the idea that a switch statement that doesn't match could error by default:</p>
<pre><code>num: switch x [
    &lt;bar&gt; [1 + 2]
    &lt;baz&gt; [3 + 4]
]
</code></pre>
<p>But switch is evaluative now, with an <a href="../../default-now-usable-in-case-switch/739.html">evaluative DEFAULT mechanism</a>:</p>
<pre><code>num: switch x [
    &lt;bar&gt; [1 + 2]
    &lt;baz&gt; [3 + 4]
    default [fail "switch didn't match"]
]
</code></pre>
<p>But it goes further than that, because FAIL's argument is optional...it will just report an error where it is if you say <code>default [fail]</code>.  And <em>even further than that</em>, you don't need the default at all, just fail if you get there:</p>
<pre><code>num: switch x [
    &lt;bar&gt; [1 + 2]
    &lt;baz&gt; [3 + 4]
    fail
]
</code></pre>
<p>That actually pinpoints the error better, because if there's a problem outside the switch at the point of assignment you don't know what happened (e.g. did one of the branches return void?)  This applies to CASE too, and anywhere else (end of a condition branch, if you like...just FAIL with no further args is fine)</p>
<h3>SET-WORD! behavior can't be customized to be more lax</h3>
<p>Programming constructs like SWITCH can be modified arbitrarily to error on more situations.  You could change your SWITCH to require a special refinement or flag to allow fallthrough--for instance.  Or you could make a switch that didn't match any conditions return a VOID! value, whose sole purpose in life is to be a pain and cause errors on assignments or tests for conditional truth and falsehood.</p>
<p>I think in the grand scheme of things, if you really notice you're having a problem, the language has tools to shape around that.  But the behavior of SET-WORD! is part of the evaluator.  It's a strictness you wouldn't be able to remove.</p>
<h3>VOID! assignments are disallowed and cover several classic cases</h3>
<p>While VOID! has nothing in particular to do with variables being unassigned, it comes up in other "no value" situations:</p>
<pre><code> &gt;&gt; x: do []
 ** Script Error: x: can't be VOID! (use TRY, OPT, or SET*)

 &gt;&gt; x: print "hi"
 hi
 ** Script Error: x: can't be VOID! (use TRY, OPT, or SET*)
 
 &gt;&gt; x: if true [print "hi"]
 hi
 ** Script Error: x: can't be VOID! (use TRY, OPT, or SET*)
</code></pre>
<p>And GROUP!s don't synthesize values, but also prohibit <code>x: ()</code> (albeit with a <a href="https://github.com/metaeducation/ren-c/issues/876" rel="nofollow noopener">bad error message</a>, that is a low-priority to come up with a clever way to improve without slowing down the evaluator).</p>
<p>Allowing NULL to do an assign is more akin to where Rebol2 casually allowed NONE! assignments these days.  It still provides a bit more rigor, because if you try to use the variable on some code path where it wasn't set, you'll find out about that when you try to use it...vs silently having it accessible.</p>
<h3>Gives a syntax to unset map keys</h3>
<p>I already covered this and how <a href="https://github.com/red/red/wiki/%5BNOTES%5D-Design-notes-on-removing-keys-from-MAP!-values" rel="nofollow noopener">Red wrote up trouble with it</a>.  Maps also may not be the only types where conveying an interest in "unsetification" is worthwhile.</p>
<p>And it's a nicer syntax for just unsetting variables.  <strong>foo: null</strong> seems a pretty clear way to do it, as opposed to <strong>unset 'foo</strong>.  It may confuse people that they can't follow up with <strong>if foo = null [...]</strong>, and need to say <strong>if :foo = null [...]</strong> or <strong>if unset? 'foo</strong>.  But if someone can't get past that they probably aren't going to be very successful in using the language.</p>
<h3>Unsetting is better for Code Golf</h3>
<p>While I don't want to ruin the usability of the language for the sake of code golf, it's clearly better for making shorter programs to remove the need for TRY.</p>
<hr>
<h2>Seems "unsetification" of null assignment is the winner</h2>
<p>I've mentioned that unsetting variables on nulls was the original behavior in the design of null.  It was useful and didn't really cause any problems.  The main thing I wasn't happy about was that things like <strong>x: print "Hello"</strong> didn't error, because print wasn't supposed to return a result...and null was the only way to do that at the time.</p>
<p>VOID! values came along and picked up the responsibility for triggering those kinds of errors, while null took its special non-value status on to greater and greater duties.  The existence of constructs like ELSE made it seem like maybe it was good to increase the safety by erroring on SET-WORD!s that weren't actually sets, so null became errors.</p>
<p>But I think the arguments above--especially the first two--show <strong>it didn't necessarily get safer overall</strong>.  You're not improving safety if you're forcing people to generate values they have to turn around and transform to get the values they actually wanted...especially when that transformation loses information (conflating blanks and nulls).  This is why blankification was changed to voidification, and manual blankification done by the user at callsites has all the downsides plus it junks up the code.</p>
<p><em>(As it happens, the R3-MAKE we are currently bootstrapped to still has the null-unset convention.  So it's a good thing to have this decided before <a href="https://github.com/metaeducation/ren-c/issues/868" rel="nofollow noopener">committing a new r3-make</a>)</em></p>
        </div>

        <meta itemprop='headline' content='NULL, first-class values, and safety'>

        <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
           <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
           <meta itemprop="userInteractionCount" content="1" />
           <span class='post-likes'>1 Like</span>
         </div>

         <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
            <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
            <meta itemprop="userInteractionCount" content="2" />
          </div>

            <div class='crawler-linkback-list' itemscope itemtype='http://schema.org/ItemList'>
                  <div itemprop='itemListElement' itemscope itemtype='http://schema.org/ListItem'>
                    <a href="../../do-not-collect-keep-if-false-100/923/6.html" itemscope itemtype='http://schema.org/DiscussionForumPosting' itemprop='item'>
                      <meta itemprop='url' content='http://forum.rebol.info/t/do-not-collect-keep-if-false-100/923/6'>
                      <span itemprop='name'>Do not COLLECT [keep if false [$100]]</span>
                    </a>
                    <meta itemprop='position' content='5'>
                  </div>
            </div>
      </div>
      <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
        <div class='crawler-post-meta'>
          <div itemprop='publisher' itemscope itemtype="http://schema.org/Organization">
            <meta itemprop='name' content='AltRebol'>
              <div itemprop='logo' itemscope itemtype="http://schema.org/ImageObject">
                <meta itemprop='url' content='https://forum.rebol.info/uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png'>
              </div>
          </div>
          <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
            <a itemprop="url" href='https://forum.rebol.info/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
            
          </span>

          <link itemprop="mainEntityOfPage" href="https://forum.rebol.info/t/null-first-class-values-and-safety/895">


          <span class="crawler-post-infos">
              <meta itemprop='datePublished' content='2018-11-13T13:40:41Z'>
              <time itemprop='dateModified' datetime='2018-11-13T13:44:54Z' class='post-time'>
                November 13, 2018,  1:44pm
              </time>
          <span itemprop='position'>#5</span>
          </span>
        </div>
        <div class='post' itemprop='articleBody'>
          <p>I'm convinced.  So as far as SET-WORD! and SET-PATH! is concerned, the deed is now done, and I feel enough scrutiny was given to justify it:</p>
<aside class="onebox githubpullrequest">
  <header class="source">
      <a href="https://github.com/metaeducation/ren-c/pull/877" target="_blank" rel="noopener">github.com/metaeducation/ren-c</a>
  </header>
  <article class="onebox-body">
    <div class="github-row">
  <div class="github-icon-container" title="Pull Request">
    <svg width="60" height="60" class="github-icon" viewBox="0 0 12 16" aria-hidden="true"><path d="M11 11.28V5c-.03-.78-.34-1.47-.94-2.06C9.46 2.35 8.78 2.03 8 2H7V0L4 3l3 3V4h1c.27.02.48.11.69.31.21.2.3.42.31.69v6.28A1.993 1.993 0 0 0 10 15a1.993 1.993 0 0 0 1-3.72zm-1 2.92c-.66 0-1.2-.55-1.2-1.2 0-.65.55-1.2 1.2-1.2.65 0 1.2.55 1.2 1.2 0 .65-.55 1.2-1.2 1.2zM4 3c0-1.11-.89-2-2-2a1.993 1.993 0 0 0-1 3.72v6.56A1.993 1.993 0 0 0 2 15a1.993 1.993 0 0 0 1-3.72V4.72c.59-.34 1-.98 1-1.72zm-.8 10c0 .66-.55 1.2-1.2 1.2-.65 0-1.2-.55-1.2-1.2 0-.65.55-1.2 1.2-1.2.65 0 1.2.55 1.2 1.2zM2 4.2C1.34 4.2.8 3.65.8 3c0-.65.55-1.2 1.2-1.2.65 0 1.2.55 1.2 1.2 0 .65-.55 1.2-1.2 1.2z"></path></svg>
  </div>

  <div class="github-info-container">
    <h4>
      <a href="https://github.com/metaeducation/ren-c/pull/877" target="_blank" rel="noopener">Allow null to unset a SET-WORD! or SET-PATH!</a>
    </h4>

    <div class="branches">
      <code>metaeducation:master</code> ← <code>hostilefork:unsetification</code>
    </div>

    <div class="github-info">
      <div class="date">
        opened <span class="discourse-local-date" data-format="ll" data-date="2018-11-13" data-time="13:05:18" data-timezone="UTC">01:05PM - 13 Nov 18 UTC</span>
      </div>

      <div class="user">
        <a href="https://github.com/hostilefork" target="_blank" rel="noopener">
          <img alt="hostilefork" src="https://avatars1.githubusercontent.com/u/20440?v=4" class="onebox-avatar-inline" width="20" height="20">
          hostilefork
        </a>
      </div>

      <div class="lines" title="1 commits changed 6 files with 37 additions and 15 deletions">
        <a href="https://github.com/metaeducation/ren-c/pull/877/files" target="_blank" rel="noopener">
          <span class="added">+37</span>
          <span class="removed">-15</span>
        </a>
      </div>
    </div>

  </div>
</div>

  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<p>For what it is worth, <em>I don't think the amount of concern given over such issues is excessive</em>.  It's a pretty important decision.</p>
<aside class="quote no-group" data-username="IngoHohmann" data-post="3" data-topic="895">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/ingohohmann/40/195_2.png" class="avatar"> IngoHohmann:</div>
<blockquote>
<p>it should unset variables and be a noop in append/replace cases, though not for the first value.</p>
</blockquote>
</aside>
<p>Seems this is how it's shaping up, but it might suggest that APPEND and friends not take VOID! unless you use an /ONLY.</p>
        </div>

        <meta itemprop='headline' content='NULL, first-class values, and safety'>

        <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
           <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
           <meta itemprop="userInteractionCount" content="1" />
           <span class='post-likes'>1 Like</span>
         </div>

         <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
            <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
            <meta itemprop="userInteractionCount" content="1" />
          </div>

      </div>
      <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
        <div class='crawler-post-meta'>
          <div itemprop='publisher' itemscope itemtype="http://schema.org/Organization">
            <meta itemprop='name' content='AltRebol'>
              <div itemprop='logo' itemscope itemtype="http://schema.org/ImageObject">
                <meta itemprop='url' content='https://forum.rebol.info/uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png'>
              </div>
          </div>
          <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
            <a itemprop="url" href='https://forum.rebol.info/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
            
          </span>

          <link itemprop="mainEntityOfPage" href="https://forum.rebol.info/t/null-first-class-values-and-safety/895">


          <span class="crawler-post-infos">
              <meta itemprop='datePublished' content='2018-11-25T06:35:45Z'>
              <time itemprop='dateModified' datetime='2019-02-18T23:50:44Z' class='post-time'>
                February 18, 2019, 11:50pm
              </time>
          <span itemprop='position'>#6</span>
          </span>
        </div>
        <div class='post' itemprop='articleBody'>
          <aside class="quote no-group quote-modified" data-post="5" data-topic="895">
<div class="title">
<div class="quote-controls"></div>
<img alt width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I’m convinced.</p>
</blockquote>
</aside>
<p>..and I'm not having any regrets so far about the SET-WORD! assignment.</p>
<p>Consider INPUT, which once returned a BLANK! when it aborted (e.g. you hit Escape/Ctrl-D instead of enter, not Ctrl-C which would halt the script).  As of a shortly pending commit, it will return a NULL:</p>
<pre><code>while [i: input] [
    ...
]
</code></pre>
<p>When you're done with that loop (assuming you didn't BREAK), <code>i</code> is not set.  This makes sense: <em>There was no more input.</em>  You shouldn't be using <code>i</code> anymore.  If you accidentally try to use it, you should get an error at the moment of use.</p>
<p>But it's still very clean and convenient to write the loop just like that.  It's the best of both worlds.</p>
<p>If you want to deliberately set it up so that <code>i</code> is testable after the loop...for instance to know if the loop broke or not, you have that option:</p>
<pre><code>while [i: try input] [
    ...  ; code that may BREAK
]

... ; more code

if i [
    ...  ; there was a BREAK, hence `i` is still a TEXT!
]
</code></pre>
<p>The TRY is needed here if you want to avoid using more complicated things like <strong>if set? 'i</strong> ... which I think you generally should try to structure your program <em>not</em> to do, unless you have a really good reason.  Unsetting a variable should not be treated like a way to track state you intend to use...it's only applicable for that when you really are using <em>every</em> possible value type (generic code that operates on ANY-VALUE! in a BLOCK! for instance) and so you have no other option without making a LOGIC! variable to track "usedness".</p>
        </div>

        <meta itemprop='headline' content='NULL, first-class values, and safety'>

        <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
           <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
           <meta itemprop="userInteractionCount" content="1" />
           <span class='post-likes'>1 Like</span>
         </div>

         <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
            <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
            <meta itemprop="userInteractionCount" content="0" />
          </div>

      </div>
      <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
        <div class='crawler-post-meta'>
          <div itemprop='publisher' itemscope itemtype="http://schema.org/Organization">
            <meta itemprop='name' content='AltRebol'>
              <div itemprop='logo' itemscope itemtype="http://schema.org/ImageObject">
                <meta itemprop='url' content='https://forum.rebol.info/uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png'>
              </div>
          </div>
          <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
            <a itemprop="url" href='../../../u/BlackATTR.html'><span itemprop='name'>BlackATTR</span></a>
            
          </span>

          <link itemprop="mainEntityOfPage" href="https://forum.rebol.info/t/null-first-class-values-and-safety/895">


          <span class="crawler-post-infos">
              <time itemprop='datePublished' datetime='2018-11-25T15:30:40Z' class='post-time'>
                November 25, 2018,  3:30pm
              </time>
              <meta itemprop='dateModified' content='2018-11-25T15:30:40Z'>
          <span itemprop='position'>#7</span>
          </span>
        </div>
        <div class='post' itemprop='articleBody'>
          <p>This is a great summary of considerations and justifications for these design changes. Essential reading.</p>
        </div>

        <meta itemprop='headline' content='NULL, first-class values, and safety'>

        <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
           <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
           <meta itemprop="userInteractionCount" content="1" />
           <span class='post-likes'>1 Like</span>
         </div>

         <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
            <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
            <meta itemprop="userInteractionCount" content="0" />
          </div>

      </div>
      <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
        <div class='crawler-post-meta'>
          <div itemprop='publisher' itemscope itemtype="http://schema.org/Organization">
            <meta itemprop='name' content='AltRebol'>
              <div itemprop='logo' itemscope itemtype="http://schema.org/ImageObject">
                <meta itemprop='url' content='https://forum.rebol.info/uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png'>
              </div>
          </div>
          <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
            <a itemprop="url" href='https://forum.rebol.info/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
            
          </span>

          <link itemprop="mainEntityOfPage" href="https://forum.rebol.info/t/null-first-class-values-and-safety/895">


          <span class="crawler-post-infos">
              <meta itemprop='datePublished' content='2019-06-01T15:51:54Z'>
              <time itemprop='dateModified' datetime='2019-06-01T16:33:30Z' class='post-time'>
                June 1, 2019,  4:33pm
              </time>
          <span itemprop='position'>#8</span>
          </span>
        </div>
        <div class='post' itemprop='articleBody'>
          <aside class="quote no-group" data-post="4" data-topic="895">
<div class="title">
<div class="quote-controls"></div>
<img alt width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>From Rebol2, people are used to writing <code>if pos: find data item [...]</code> . Telling them they need a TRY to do so would likely seem like a step back, and you don't want to force them to use a THEN if that's not how they want to write it. Having lots of choices is the goal.</p>
<p>This way, they'll only need to throw on the TRY if they have some reason for reading the pos later. But knowing the POS isn't a valid position has merit.</p>
</blockquote>
</aside>
<p>Here I'm pointing out a difference between Rebol2 and Ren-C:</p>
<pre><code>data: []
x: find [a b c] 'd
append data x   ; no error in Rebol2, error in Ren-C (x is unset)
</code></pre>
<p>Rebol2 would not only have not errored, but it would be adding a blank there...so data would be mutated.</p>
<p>Yet in Ren-C, you wouldn't have gotten an error if you had said:</p>
<pre><code>data: []
append data find [a b c] 'd
</code></pre>
<p>This would have appended nothing, as NULL "opts out" of appends (since there is no way to put a null in a block, it is not a "value").</p>
<p>There's a whole line of reasoning laid out above as to why allowing the SET-WORD! without an error is good.  And one of the reasons given is "substitution principle".  But if the substitution principle has legs, is there a reason why you should have a different result here when you go through an intermediate variable?</p>
<h2>Hence....should the NULL state be more friendly (like NONE! was)?</h2>
<p>Switching over to <a href="../../are-nulls-the-best-representation-for-unused-refinements/1140.html">NULL-valued refinements</a> lets us leverage the null-vs-blank distinction.  That distinction is particularly important for BLANK!-in, null-out scenarios...and then uses like BLANK! for "quiet NaN" with null as "noisy NaN" with TRY as the converter.</p>
<p>But it has created a headache of needing some kind of special access to read the refinement state.  So you can't say <strong>foo: func [/a] [if a [...]]</strong>.  You get an error on that today...as part and parcel of a holding null.  So it actually has no value (no datatype, no representation, and shows up as C's NULL when spoken about in the API).  No place to store a newline flag, it can't be in a block, etc. etc.</p>
<p><em>Yet is erroring on word-or-path-access truly implied just because it has that feature set?</em>  What would happen if these unset variables were still not accepted as an argument to most functions after they were fetched, but were friendly as far as WORD! or PATH! based fetching was concerned?  Then the <a href="../../why-void-is-not-like-unset-and-why-its-more-ornery/947.html">job of fetch-ornery-ness was left to VOID!</a>?  Void is not conditionally true or false, can't be passed as a function argument by default either, but mechanically it is a value (can be put in blocks, does have a newline flag because it has a cell, etc.)</p>
<h2>This puts more pressure on VOID!-ification</h2>
<p>What this would do would mean that catching typos would mean that out-of-band values (created by automatic context expansions) would probably have to be set to VOID!.</p>
<pre><code>&gt;&gt; foo: does [print mold type of :asdf]

&gt;&gt; foo
== void!

&gt;&gt; asdf
** Script Error: asdf is VOID!
</code></pre>
<p>That work is done by BIND/NEW, and it would need to be changed from making bindings to null context variables to being bindings to VOID! context variables.</p>
<p>This would impact things like DEFAULT, which currently do not consider VOID! as one of the states that it is willing to override (currently only NULL and BLANK!).</p>
<h2>To be clear, NULL as a <em>parameter</em> would still default to erroring</h2>
<p>This is purely speaking about making unset variables give back NULL from WORD! and PATH! access.  As NULL has become very much the surrogate for many return results that used to give NONE!, it seems to make sense.</p>
<p>But if parameters weren't demanding of non-null arguments in most cases, the BLANK!-in NULL-out convention wouldn't work.</p>
<p>This feels like it makes sense to me.  As much as I feel that null is very much the right state for unused refinements, I've had an uncomfortable feeling going around changing:</p>
<pre><code> foo: func [/a] [if a [...]]  =&gt;  foo: func [/a] [if /a [...]]  ; hrrrrm :-/
</code></pre>
<p>There's a couple things not right with it.  But reimagining it so that plain WORD! access wouldn't error on null variables, and being more strategic about VOID!-ification in the binding mechanics (to be more like Rebol2 use of UNSET!), seems to clean this up and keep from wrecking every routine ever written.</p>
<h2>Dialects could still distinguish NULL and BLANK!</h2>
<p>This is discussing a tweak to how the evaluator behind DO fetches WORD! and PATH! lookups that give back NULL.  But that's not where the buck stops.  You've still got to pass that to a function that accepts NULL.  And as I've said, <em>they still won't by default</em>.</p>
<pre><code> foo: func [bar] [print "bar can't be null, not an &lt;opt&gt; parameter"]
 x: if false ["x will be null"]
 foo x  ; the fetch of x succeeds to get null, but this call fails
</code></pre>
<p>So now it's up to a dialect to decide if it wants to say NULL is an error, and you have to BLANK!-ify things.  Maybe PARSE wants to be picky?  It wasn't in Rebol2, e.g. you could write:</p>
<pre><code>rebol2&gt;&gt; rule: if false ["a"]

rebol2&gt;&gt; parse "b" [rule "b"]
== true

rebol2&gt;&gt; test: func [/local rule] [parse "b" [rule "b"]]

rebol2&gt;&gt; test
== true
</code></pre>
<p>So now this would just be the same behavior in Ren-C, but with nulls taking the place of NONE!s.</p>
        </div>

        <meta itemprop='headline' content='NULL, first-class values, and safety'>

        <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
           <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
           <meta itemprop="userInteractionCount" content="0" />
           <span class='post-likes'></span>
         </div>

         <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
            <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
            <meta itemprop="userInteractionCount" content="0" />
          </div>

            <div class='crawler-linkback-list' itemscope itemtype='http://schema.org/ItemList'>
                  <div itemprop='itemListElement' itemscope itemtype='http://schema.org/ListItem'>
                    <a href="../../should-unset-var-name-check-for-void-not-null/1171.html" itemscope itemtype='http://schema.org/DiscussionForumPosting' itemprop='item'>
                      <meta itemprop='url' content='https://forum.rebol.info/t/should-unset-var-name-check-for-void-not-null/1171'>
                      <span itemprop='name'>Should UNSET? &#39;VAR-NAME check for VOID!, not NULL?</span>
                    </a>
                    <meta itemprop='position' content='3'>
                  </div>
                  <div itemprop='itemListElement' itemscope itemtype='http://schema.org/ListItem'>
                    <a href="../../are-nulls-the-best-representation-for-unused-refinements/1140/6.html" itemscope itemtype='http://schema.org/DiscussionForumPosting' itemprop='item'>
                      <meta itemprop='url' content='https://forum.rebol.info/t/are-nulls-the-best-representation-for-unused-refinements/1140/6'>
                      <span itemprop='name'>Are nulls the best representation for unused refinements?</span>
                    </a>
                    <meta itemprop='position' content='4'>
                  </div>
            </div>
      </div>






    </div>
    <footer class="container wrap">
      <nav class='crawler-nav'>
        <ul>
        <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
          <span itemprop='name'>
            <a href='https://forum.rebol.info/' itemprop="url">Home </a>
          </span>
        </li>
        <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
          <span itemprop='name'>
            <a href='https://forum.rebol.info/categories' itemprop="url">Categories </a>
          </span>
        </li>
        <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
          <span itemprop='name'>
            <a href='https://forum.rebol.info/guidelines' itemprop="url">FAQ/Guidelines </a>
          </span>
        </li>
        <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
          <span itemprop='name'>
            <a href='https://forum.rebol.info/tos' itemprop="url">Terms of Service </a>
          </span>
        </li>
        <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
          <span itemprop='name'>
            <a href='https://forum.rebol.info/privacy' itemprop="url">Privacy Policy </a>
          </span>
        </li>
        </ul>
      </nav>
      <p class='powered-by-link'>Powered by <a href="https://www.discourse.org">Discourse</a>, best viewed with JavaScript enabled</p>
    </footer>
    
    
  </body>
  
</html>
